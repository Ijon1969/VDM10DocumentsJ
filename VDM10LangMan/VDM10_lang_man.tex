% Overture Language Manual
\documentclass{overturerepchap}
\usepackage{url}
\usepackage{graphics}
\usepackage{times}
\usepackage{listings}

% \usepackage{color}
% \usepackage{graphicx}
\usepackage[dvipdfmx]{graphicx,color}
%
\usepackage{comment}

\usepackage{latexsym}
\usepackage{longtable} % ,multirow
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage{fancyhdr}

\newcommand{\nonstandard}[1]{}
\newcommand{\vdmtools}{VDMTools}
\newcommand{\vdmstyle}[1]{\texttt{#1}}
\newcounter{exerciseno}
\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newcounter{exerciseno}
\newcommand{\MYEQUIV}{$\equiv$}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  Operator Name & Semantics Description \\ \hline\hline \endhead}%
  {\hline\end{longtable}}

\newcommand\thebookexercise{\thechapter.\arabic{exerciseno}}
\newenvironment{myexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise}\enskip}{$\Box$\\
}
\newenvironment{myhardexercise}{\par
  \refstepcounter{exerciseno}%
  \indent\textbf{Exercise\ \thebookexercise $\star$}\enskip}{$\Box$\\
}
\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
%\newenvironment{mysolution}{
%} %% This will be replaced by a perl script extracting the solutions
  %% and inserting them automatically into the solutions chapter.
\newcommand{\insertfig}[4]{ % Filename, epsheight, epswidth, caption,  label
\begin{figure}[htb]
\begin{center}
\includegraphics[width=#2]{#1}
\end{center}
\caption{{\em #3}} #4
\end{figure}
}

\newcommand{\insertfignw}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\includegraphics{#1}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\newcommand{\insertfignwrot}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\scalebox{1}%
{\rotatebox{270}{%
\includegraphics{#1}}}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

%\newcommand{\insertcommentedvdm*}[2]{}
  %% This macro is identified by perl script which will move the
  %% parameter to the solutions chapter.
% definition of VDM++, JavaCC, JJTree, JTB, ANTLR and SableCC for listings
\include{customlangdef}
% define the layout for listings
\lstdefinestyle{tool}{basicstyle=\ttfamily,
                         frame=trBL,
			 showstringspaces=false,
			 frameround=ffff,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
\lstdefinestyle{mystyle}{basicstyle=\ttfamily,
                         frame=trBL,
%                         numbers=left,
%			 gobble=0,
			 showstringspaces=false,
%			 linewidth=\textwidth,
			 frameround=fttt,
			 aboveskip=5mm,
			 belowskip=5mm,
			 framexleftmargin=0mm,
			 framexrightmargin=0mm}
%\lstdefinestyle{mystyle}{basicstyle=\sffamily\small,
%			 frame=tb,
%                         numbers=left,
%			 gobble=0,
%			 showstringspaces=false,
%			 linewidth=345pt,
%			 frameround=ffff,
%			 framexleftmargin=8mm,
%			 framexrightmargin=8mm,
%			 framextopmargin=1mm,
%			 framexbottommargin=1mm,
%			 aboveskip=7mm,
%			 belowskip=5mm,
%			 xleftmargin=10mm,}

\lstset{style=mystyle}
\lstset{language=VDM++}
\lstset{alsolanguage=Java}
% The command below enables you to escape into normal LaTeX mode inside your 
% VDM chunks by starting with a `!��? character and ending with a `!��?
\lstset{escapeinside=!!}

%\newcommand{\kw}[1]{{\tt #1}}

%%%%%%%%%%%%%%%%%% Commands for bibtex %%%%%%%%%%%%%%%%%%%%%%%
%************************************************************************
%                                                                       *
%       Bibliography and Terminology supporting commands                *
%                                                                       *
%************************************************************************

\newcommand{\bthisbibliography}[1]{\chapter*{References}%
   \begin {list} {}%
     {\settowidth {\labelwidth} {[#1]XX}%
      \setlength {\leftmargin} {\labelwidth}%
      \addtolength{\leftmargin} {\labelsep}%
      \setlength {\parsep} {1ex}%
      \setlength {\itemsep} {2ex}%
     }
  }
\newcommand{\ethisbibliography}{\end{list}}
\newcommand{\refitem}[2]
  {\bibitem[#1]{#2}}

% Requirements environment
\newenvironment{reqs}{%
\begin{enumerate}
%\renewcommand{\labelenumi}{\textbf{R\theenumi}}
\renewcommand{\theenumi}{\textbf{R\arabic{enumi}}}
}{%
\end{enumerate}}

%\newcommand{\Exercise}[1]{%
%    \textbf{Exercise \thechapter.\theexerciseno}
%   \refstepcounter{exerciseno} #1 $\Box$\\ }%}
%\newcommand{\initexercise}{\setcounter{exerciseno}{0}}
\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index

  \end{tabbing}\end{quote}
  }
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\bf\ttfamily #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt
    #1}\makebox[\kwlen][l]{{\bf\ttfamnily #1}}}
\newcommand{\keyw}[1]{{\bf\ttfamily #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{lstlisting}\input{#1}\end{lstlisting}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\keyw{map }#1\keyw{ to }#2}
\newcommand{\INMAP}[2]{\keyw{inmap }#1\keyw{ to }#2}
\newcommand{\SEQ}[1]{\keyw{seq of }#1}
\newcommand{\NSEQ}[1]{\keyw{seq1 of }#1}
\newcommand{\SET}[1]{\keyw{set of }#1}
\newcommand{\SETONE}[1]{\keyw{set1 of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{#1 $\To$ #2}
\newcommand{\FUN}[2]{#1 $\To$ #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}

\newcommand{\experience}[1]{%
\begin{center}
\fbox{
\begin{minipage}[t]{.8\textwidth}
#1
\end{minipage}}
\end{center}}


\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{VDM-10 Language Manual}
\fancyhead[RO,LE]{\resizebox{0.05\textwidth}{!}{\includegraphics{overture}}}
\fancyfoot[C]{\thepage}
\makeindex

\begin{document}

\title{VDM-10 Language Manual}
\author{Peter Gorm Larsen\\
        Kenneth Lausdahl\\
        Nick Battle\\
        John Fitzgerald\\
        Sune Wolff\\
        Shin Sahara\\
        Marcel Verhoef\\
        Peter W. V. Tran-J\o{}rgensen\\
        Tomohiro Oda\\
        Paul Chisholm}

\date{September 2016}
\reportno{TR-001}

\pagenumbering{roman}
\maketitle


{\textbf{Document history}}

\begin{tabular}{|l|l|l|l|l|}\hline
Month   & Year & Version & Version of Overture.exe & Comment \\ \hline
April   & 2010 &         & 0.2   & \\ \hline
May     & 2010 & 1       & 0.2   &  \\ \hline
February& 2011 & 2       & 1.0.0 &  \\ \hline
July    & 2012 & 3       & 1.2.2 & \\ \hline
April   & 2013 & 4       & 2.0.0 & \\ \hline
March & 2014 & 5 & 2.0.4 &
Includes RMs \#16, \#17, \#18, \#20 \\ \hline
November & 2014 & 6 & 2.1.2 &
Includes RMs \#25, \#26, \#29 \\ \hline
August & 2015 & 7 & 2.3.0 &
Includes RMs \#27 \\ \hline
April & 2016 & 8 & 2.3.4 & Review inputs from Paul Chisholm \\ \hline
September & 2016 & 9 & 2.4.0 & RMs \#35, \#36 \\ \hline
\end{tabular}

%\addtocounter{page}{2}
\tableofcontents
\newpage
\mbox{}
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{はじめに}

The Vienna Development Method (VDM)
\cite{Bjorner&78,Jones90a,Fitzgerald&08c} は、元々ウィーンのIBM研究所で
1970年代に開発され、最も初期に確立された形式手法の一つだ。
このドキュメントは、合意されたVDM-10仕様から派生した3つの方言、VDM-SL、VDM++、そして
VDM-RTを同時に説明する共通言語マニュアルである。
これらの方言はVDMTools \cite{Fitzgerald&08a} （但し VDM-RTを除く）と、
Eclipse プラットフォーム上に構築された Overture オープンソースツール \cite{Larsen&10a}
の両者でサポートされている。
ある特徴が3つの方言に共通している場合には「VDM言語」という表現が用いられるが、
特定の方言に固有の特徴を説明している場合には、それがどの方言に対する特徴かを明記する。

\section{VDM Specification 言語 (VDM-SL)}

VDM-SL言語のシンタックスとセマンティクスは、本質的には ISO標準の VDM-SL \cite{ISOVDM96}
にモジュール拡張を加えたものだ\footnote{その他の拡張も若干含まれている。}。
% Notice that all syntactically correct VDM-SL specifications are also correct in
%  VDM-SL. ... トートロジー？
ISO/VDM-SL に準拠したすべての構文的に正しい仕様記述は、
VDM-10/VDM-SLとしても構文的に正しいことに注目して欲しい。
言語に関して明快で理解しやすい説明を行うが、このドキュメント自身は
完全なVDM-SLのレファレンスマニュアルではない。
言語に対するより完全な解説としては、既存の文献を示す\footnote{よりチュートリアル
風の解説については \cite{Fitzgerald&98b,Fitzgerald&09} を参照、VDM-SLを用いた証明に関しては
 \cite{Jones90a} と \cite{Bicarregui&94}が詳しい。}。
VDM-10/VDM-SLの記法がISO標準/VDM-SLと異なる場合には、もちろん注意深い解説が加えられる。

\section{VDM++ 言語}

VDM++ は、主にエンジニアリング環境で、平行性ならびにリアルタイム性を持つ
オブジェクト指向システムの記述を行うことが意図された、
形式仕様記述言語である~\cite{Fitzgerald&05}。
この言語はVDM-SL~\cite{ISOVDM96}に基き、その上に、Smalltalk-80 や Java といった言語の
中に見出だせるような、クラスやオブジェクトの概念が拡張されたものだ。

\section{VDM Real Time 言語 (VDM-RT)}

VDM-RT 言語 (以前は VICE「VDM++ In Constrained Environments」と呼ばれていた）は、
VDM++ 言語の拡張である。
分散したリアルタイム組み込みシステムを適切にモデル化し、
分析するために用いられる \cite{Mukherjee&00,Verhoef&06b,Verhoef&07,Verhoef08,Larsen&09b}。

% \section{Purpose of This Document}
\section{このドキュメントの目的}

\begin{comment}
This document is the language reference manual for all the VDM-10 dialects.  The
syntax of VDM language constructs is defined using grammar rules.
The meaning of each language construct is explained in an informal
manner and some small examples are given. The description is supposed
to be suited for `looking up' information rather than for `sequential
reading'; it is a manual rather than a tutorial.  The reader is
expected be familiar with the concepts of object oriented
programming/design.
\end{comment}

このドキュメントは、VDM-10から派生した全ての方言をカバーした言語レファレンスマニュアルである。
VDM言語の言語要素の構文は文法規則を用いて定義される。
それぞれの言語要素の意味はインフォーマルなスタイルで説明され、小さな例題が与えられる。
記述は「必要に応じて参照する」スタイルに向いていて、最初から順番に読んでいくことは
特に想定されていない。すなわちチュートリアルではなくマニュアルなのである。
読者はオブジェクト指向プログラミング/設計の概念をよく知っていることを期待されている。

\begin{comment}
We will use the ASCII (also called the interchange)
concrete syntax but we will display all reserved words in a special
keyword font. Note that general Unicode identifiers are allowed so
it is for example possible to write Japanese characters directly.
\end{comment}

ドキュメント中では ASCII （交換用）構文を用いるが、
全ての予約語は特別なキーワードフォントを用いいて表現する、
一般的な Unicode 識別子が許されるので、例えば日本語の文字を直接書くことも可能だ。

% \section{Structure of the Document}
\section{ドキュメントの構造}

\begin{comment}
Chapter~\ref{syntax-notation} presents the BNF notation used for the
description of syntactic constructs.  The VDM notations are described
in Chapter~\ref{typedef} to Chapter~\ref{chap:trace}.
%Section~\ref{diff} provides a complete list of the differences between
%ISO/VDM-SL and the VDM-10 notations while s
The complete syntax of the language is described in
Appendix~\ref{app-a}, the lexical specification in
Appendix~\ref{app-b} and the operator precedence in
Appendix~\ref{app-c}. Appendix~\ref{sec:diff} presents a list of the
differences between symbols in the mathematical syntax and the ASCII
concrete syntax.
%In Appendex~\ref{stdlib} details of the Standard
%libraries and how to use it are given. Finally, an index of the
%defining occurrences of all the syntax rules in the document is given.
\end{comment}

Chapter~\ref{syntax-notation} では BNF 記法を用いて構文構成要素が示される。
VDM の記法に関しては Chapter~\ref{typedef} から Chapter~\ref{chap:trace}で
記述される。
言語の完全な構文については Appendix~\ref{app-a} で、
字句仕様は Appendix~\ref{app-b} で、
そして演算子の優先度については Appendix~\ref{app-c} で説明する。
Appendix~\ref{sec:diff} では数学構文とASCII構文で使われるシンボルの違いに
ついての一覧を示した。

\chapter{具象構文表記}
\label{syntax-notation}

\begin{comment}
Wherever the syntax for parts of the language is presented in the
document it will be described in a BNF dialect. The BNF notation
used employs the following special symbols:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  the concatenate symbol \\
  = & the define symbol \\
  \dsepl & the definition separator symbol (alternatives)\\
  \OptPt{} & enclose optional syntactic items \\
  \SeqPt{} & enclose syntactic items which may occur zero or more times \\
  \Lit{ } & single quotes are used to enclose terminal symbols \\
    meta identifier & non-terminal symbols are written in lower-case letters
    (possibly including spaces) \\
  ;  & terminator symbol to denote the end of a rule \\
  (\ ) & used for grouping, e.g. ``a, (b\dsepl c)'' is equivalent to
    ``a, b\dsepl a, c''. \\
  -- & denotes subtraction from a set of terminal symbols
    (e.g. ``character -- (\Lit{\singleQuote})'' denotes all characters
    excepting the double quote character.)
\end{tabular}
\end{comment}

本書で、言語構文について表現する場合には、派生BNF表記を用いる。
使用される派生BNF表記法には、以下に示す特殊記号が用いられる:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  連結記号 \\
  = &  定義記号 \\
  \dsepl & 定義分離記号(選択肢)\\
  \OptPt{} & オプションの構文項目を囲む \\
  \SeqPt{} & 0回以上出現する構文項目を囲む \\
  \Lit{ } & 単引用符は終端記号を囲むのに使用される \\
    メタ識別子 & 非終端記号は小文字(空白も含む)で記される \\
  ;  & 1つの規則の終わりを表わす終了記号\\
  (\ ) & グループ化に用いられる、つまり``a, (b\dsepl c)'' は
    ``a, b\dsepl a, c''と等しい。 \\
  -- & 終端記号の集合からの減算を表す(つまり ``character -- (\Lit{\singleQuote})'' はダブル引用リテラルを除くすべての文字を表す。)
\end{tabular}

\chapter{データ型定義}
\label{typedef}

\begin{comment}
As in traditional programming languages it is possible to define data
types in the VDM languages and give them appropriate names.
Such an equation might look like:

\begin{lstlisting}
types

  Amount = nat
\end{lstlisting}

Here we have defined a data type with the name ``{\tt Amount}'' and
stated that the values which belong to this type are natural numbers
(\keyw{nat} is one of the basic types described below). One general
point about the type system of the VDM languages which is
worth mentioning at this point is that equality and inequality can be
used between any value. In programming languages it is often required
that the operands have the same type. Because of a
construct called a union type (described below) this is not the case
for the VDM languages.

In this chapter we will present the syntax of data type
definitions. In addition, we will show how values belonging to a type
can be constructed and manipulated (by means of built-in operators).
We will present the basic data types first and then we will proceed
with the compound types.
\end{comment}

伝統的なプログラミング言語と同様に、VDM言語でもデータ型を定義し適切な名称を与えることができる。
そうした名前を与えるための等式は以下のような形式になる：

\begin{lstlisting}
  Amount = nat
\end{lstlisting}

ここでは``{\tt Amount(合計)}''という名のデータ型を定義して、更にこの型に属する値は自然数であると述べている(\keyw{nat(自然数)} は以下説明する基本型の1つである)。
この時点で述べておく価値のある、VDM言語の型体系全般に共通する性質の1つは、相等と不等はどのような値間にも用いることができるということである。 
他のプログラミング言語においてはしばしば、演算対象が同じ型であることを要求される。
しかしVDM言語には合併型(後述する)と呼ばれる構造があるので、これには当てはまらない。

この節では、データ型定義の構文について述べる。
加えて、ある型に属する値は(組込み演算子を用いて)
どのように構成され操作され得るのかについて述べる。
最初に基本データ型を示し、次に合成型の説明へと進もう。

\begin{comment}
\section{Basic Data Types}

In the following a number of basic types will be presented. Each of
them will contain:

\begin{itemize}
\item Name of the construct.
\item Symbol for the construct.
\item Special values belonging to the data type.
\item Built-in operators for values belonging to the type.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.%
  \footnote{In these examples the Meta symbol `$\equiv$' will be used
    to indicate what the given example is equivalent to.}
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt a}, {\tt b}, {\tt x}, {\tt y}
etc.

The basic types are the types defined by the language with distinct
values that cannot be analysed into simpler values. There are five
fundamental basic types: booleans, numeric types,
characters, tokens and quote types. The basic types will be explained one by
one in the following.

\subsection{The Boolean Type}\label{bool}

In general the VDM languages allow one to specify systems in
which computations may fail to terminate or to deliver a result. To
deal with such potential undefinedness,
the VDM languages employ a three valued logic: values may be
true, false or bottom (undefined).
The semantics of the VDM interpreters differs from the ISO/VDM-SL standard
in that it does
not have an LPF (Logic of Partial Functions) three valued logic where
the order of the operands is
unimportant (see \cite{Jones90a}).  The \keyw{and} operator, the
\keyw{or} operator and the imply operator, though, have a conditional
semantics meaning that if the first operand is sufficient to determine
the final result, the second operand will not be evaluated. In a sense
the semantics of the logic in the VDM interpreter can still be considered
to be three-valued as for ISO/VDM-SL. However, bottom values may
either result in infinite computation or a run-time error in the
VDM interpreter.

\begin{description}
\item[Name:] \Index{Boolean}
\item[Symbol:] \Index{\keyw{bool}}
\item[Values:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[Operators:] Assume that {\tt a} and {\tt b} in the following
  denote arbitrary boolean expressions:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name       & Type                       \\ \hline
    {\tt \keyw{not} b}& Negation   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& Conjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& Disjunction & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& Implication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& Biimplication & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & Equality   & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& Inequality & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[Semantics of Operators:] Semantically {\tt <=>} and {\tt =} are
  equivalent when we deal with boolean values. There is a conditional
  semantics for \keyw{and}, \keyw{or} and {\tt=>}.

  We denote undefined terms (e.g. \ applying a map with a key outside
  its domain)  by $\perp$. The truth tables for the boolean operators
  are then%
  \footnote{Notice that in standard VDM-SL all these truth tables
  (except {\tt =>}) would be symmetric.}:

  \begin{tabular}{ll}
    Negation {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    Conjunction {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Disjunction {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Implication {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    Biimplication {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}

\item[Examples:]
  Let {\tt a = \keyw{true}} and {\tt b = \keyw{false}} then:

  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsection{The Numeric Types}\label{numeric}

There are five basic numeric types: positive naturals, naturals,
integers, rationals and reals.  Except for three, all the
numerical operators can have mixed operands of the three types. The
exceptions are integer division, modulo and the remainder operation.

The five numeric types denote a subset hierarchy where \Index{\keyw{real}} is
the most general type followed by \Index{\keyw{rat}}\footnote{From the
VDM interpreter's point of view there is no
  difference between \keyw{real} and \keyw{rat} because only rational
  numbers can be represented in a computer.}, \Index{\keyw{int}},
\Index{\keyw{nat}} and \Index{\keyw{nat1}}. Note that no ``casting''
like it is done in many programming languages is needed in the VDM
languages.

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  Type & Values \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
This means that any number of type \keyw{int} is also automatically of type
\keyw{real} but not necessarily of type \keyw{nat}.  Another way to
illustrate this is to say that the positive natural numbers are a subset of
the natural numbers which again are a subset of the integers which again
are a subset of the rational numbers which finally are a subset of the real
numbers. The following table shows some numbers and their associated
type:

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  Number & Type \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
Note that all numbers are necessarily of type \keyw{real} (and
\keyw{rat}).

\begin{description}
\item[Names:] real, rational, integer, natural and positive natural
  numbers.
\item[Symbols:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[Values:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[Operators:] Assume in the following that {\tt x} and {\tt y} denote
  numeric expressions. No assumptions are made regarding their type.

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name & Type \\ \hline
    {\tt -x}& Unary minus & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& Absolute value & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& Floor  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& Sum    & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& Difference & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& Product  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& Division & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& Integer division & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& Remainder & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& Modulus   & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& Power & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& Less than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& Greater than & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& Less or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& Greater or equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& Equal  & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& Not equal & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  The types stated for operands are the most general types allowed.  This
  means for instance that unary minus works for operands of all five types
  (\keyw{nat1}, \keyw{nat}, \keyw{int}, \keyw{rat} and \keyw{real}).

\input{sem-numtypes}

\item[Examples:] Let {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} then:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6
  \end{longtable}
\end{description}

\subsection{The Character Type}

The character type contains all the single character
elements of the VDM character set
(see Table~\ref{charSetTable} on page~\pageref{charSetTable}).

\begin{description}
\item[Name:] \Index{Char}
\item[Symbol:] \Index{\keyw{char}}
\item[Values:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[Operators:] Assume that {\tt c1} and {\tt c2} in the following denote arbitrary
  characters:

  \begin{tabular}{|l|l|l|}\hline
    Operator       & Name      & Type \\ \hline
    {\tt c1 = c2}  & Equal     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & Not equal & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[Examples:] \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsection{The Quote Type}

The quote type corresponds to enumerated types in a programming
language like Pascal. However, instead of writing the different quote
literals between curly brackets in VDM it is done
by letting a quote type consist of a single quote literal and
then let them be a part of a union type.
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[Name:] \Index{Quote}
\item[Symbol:] e.g. {\tt <QuoteLit>}\index{\texttt{<>}!quote value}
\item[Values:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[Operators:] Assume that \texttt{q} and \texttt{r} in the
  following denote arbitrary quote values belonging to an enumerated
  type {\tt T}:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt q = r}  & Equal     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & Not equal & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[Examples:] Let \texttt{T} be the type defined as:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  If for example {\tt a = <France>}
  then:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsection{The Token Type}

The token type consists of a countably infinite set of distinct
values, called tokens. The only operations that can be carried out on
tokens are equality and inequality. In VDM,
tokens cannot be individually represented whereas they can be written
with a \keyw{mk\_token} around an arbitrary expression. This is a way
of enabling testing of specifications that contain token
types. However, in order to resemble the ISO/VDM-SL standard these token
values cannot be decomposed by means of any pattern matching and they
cannot be used for anything other than equality and inequality
comparisons.

\begin{description}
\item[Name:] \Index{Token}
\item[Symbol:] \Index{\keyw{token}}
\item[Values:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[Operators:] Assume that {\tt s} and {\tt  t} in the following denote arbitrary
  token values:

  \begin{tabular}{|l|l|l|}\hline
    Operator     & Name      & Type \\ \hline
    {\tt s = t}  & Equal     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & Not equal & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[Examples:] Let for example {\tt s = \keyw{mk\_token}(6)},  let {\tt t
    = \keyw{mk\_token}(1)} and  {\tt u = mk\_token(\{1,2\})} in:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
    {\tt u = \keyw{mk\_token}(\{2,1\})} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\section{Compound Types}

In the following compound types will be presented. Each of
them will contain:
\begin{itemize}
\item The syntax for the compound type definition.
\item An equation illustrating how to use the construct.
\item Examples of how to construct values belonging to the type. In
  most cases there will also be given a forward reference to the
  section where the syntax of the basic constructor expressions is given.
\item Built-in operators for values belonging to the
  type\footnote{These operators are used in either unary or binary
    expressions which are given with all the operators in
    section~\ref{unandbin}.}.
\item Semantics of the built-in operators.
\item Examples illustrating how the built-in operators can be used.
\end{itemize}
For each of the built-in operators the name, the symbol used and the
type of the operator will be given together with a description of its
semantics (except that the semantics of Equality and Inequality is not
described, since it follows the usual semantics). In the semantics
description identifiers refer to those used in the corresponding
definition of operator type, e.g.\ {\tt m}, {\tt m1}, {\tt s}, {\tt
  s1} etc.

\subsection{Set Types}
\label{sets}

A set is an unordered collection of values, all of the same
type\footnote{Note however that it is always possible to find a common
  type for two values by the use of a union type (see
  section~\ref{unions}.)}, which is treated as a whole. All sets in
VDM languages are finite, i.e.\ they contain only a finite
number of elements. The elements of a set type can be arbitrarily
complex, they could for example be sets themselves. Sets may include the
empty set (set0 type), or may require at least one element (set1 type).

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt S} is a set type, {\tt s}, {\tt s1}, {\tt s2} are set
values, {\tt ss} is a set of set values, {\tt e}, {\tt e1}, {\tt e2}
and {\tt en} are elements from the sets, {\tt bd1,} {\tt bd2}, \ldots,
{\tt bdm} are bindings of identifiers to sets or types, and {\tt P} is
a logical predicate.

\begin{description}
\item[Syntax:]
  \Rule{type}{
   \Ruleref{set type} \dsep
    \ldots
    }

  \Rule{set type}{\Ruleref{set0 type} \dsep
    \Ruleref{set1 type}
  }

  \Rule{set0 type}{\Lop{set of}, \Ruleref{type}}
  \Rule{set1 type}{\Lop{set1 of}, \Ruleref{type}}

\item[Equation:] {\tt S = \keyw{set of} A }\index{\keyw{set of}} or {\tt S = \keyw{set1 of} A}\index{\keyw{set1 of}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Set enumeration:] \verb|{e1, e2, ..., en}| constructs a set of the
    enumerated elements. The empty set is denoted by {\tt \{\}}.

  \item[Set comprehension:] \verb+{e | bd1, bd2, ..., bdm & P}+
    constructs a set by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}.
    A binding is either a set binding, a sequence binding, or a type
    binding\footnote{Notice that type bindings over infinite types (discharging the invariant limitations) cannot be executed by
      the VDM interpreters because in general
      they are not executable (see section~\ref{bind} for further
      information about this).}.  A set bind {\tt bdn} has the form
    {\tt pat1, \ldots, patp \keyw{in set} s}, where {\tt pati} is a
    pattern (normally simply an identifier), and {\tt s} is a set
    constructed by an expression. A sequence (or type) binding is similar, in the
    sense that \keyw{in set} is replaced by \keyw{in seq} (or a colon) and {\tt s} is
    replaced with a sequence (or type) expression.
  \end{description}
  The syntax and semantics for all set expressions are given in
  section~\ref{setexpr}.%
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt e \keyw{in set} s1} & Membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & Not membership & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& Union & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& Intersection & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& Difference & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& Subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & Proper subset & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& Equality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& Inequality & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& Cardinality & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& Distributed union& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&Distributed intersection & \TO{\SETONE{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&Finite power set & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  Note that the types {\tt A, \SET{A}} and {\tt \SET{\SET{A}}} are only
  meant to illustrate the structure of the type. For instance it is
  possible to make
  a union between two arbitrary sets {\tt s1} and {\tt s2} and the type of
  the resultant set is the union type of the two set types. Examples
  of this will be given in section \ref{unions}.

\input{sem-settypes}

\item[Examples:]%
 Let {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}},
{\tt s2 = \{2, 4, 6, 8, 11\}} and {\tt s3 = \{\}} then:

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsection{Sequence Types}
\label{sequences}

A sequence value is an ordered collection of elements of some type
indexed by {\tt 1, 2, \ldots, n}; where {\tt n} is the length of the
sequence. A sequence type is the type of finite sequences of elements
of a type, either including the empty sequence (seq0 type) or
excluding it (seq1 type). The elements of a sequence type can be
arbitrarily complex; they could e.g.\ be sequences themselves.

In the following this convention will be used: {\tt A} is an arbitrary
type, {\tt L} is a sequence type, {\tt S} is a set type, {\tt l}, {\tt
  l1}, {\tt l2} are sequence values, {\tt ll} is a sequence of
sequence values.  {\tt e1}, {\tt e2} and {\tt en} are elements in
these sequences, {\tt i} will be a natural number, {\tt P} is a
predicate and {\tt e} is an arbitrary expression.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{seq type} \dsep
    \ldots
    }

  \Rule{seq type}{\Ruleref{seq0 type} \dsep
    \Ruleref{seq1 type}}

  \Rule{seq0 type}{\Lop{seq of}, \Ruleref{type}}

  \Rule{seq1 type}{\Lop{seq1 of}, \Ruleref{type}}
\item[Equation:] {\tt L = \keyw{seq of} A} or {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements.

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Sequence enumeration:] \verb+[e1, e2,..., en]+ constructs a
    sequence of the enumerated elements. The empty sequence is written
    as \verb+[]+.  A text literal is a shorthand for enumerating a sequence
    of characters (e.g.\ {\tt "ifad" = ['i','f','a','d']}).

  \item[Sequence comprehension:] 

    {\tt [e | id \keyw{in seq} S \& P]} constructs a sequence by
    evaluating the expression \texttt{e} on all the bindings for which
    the predicate \texttt{P} evaluates to \keyw{true}. The expression
    \texttt{e} will use the identifier \texttt{id}. \texttt{S} is a
    sequence of elements and \texttt{id} will be matched with the
    elements preserving the order of \texttt{S}.

{\tt [e | id \keyw{in set} S \& P]}
    constructs a sequence by evaluating the expression {\tt e} on all the
    bindings for which the predicate {\tt P} evaluates to \keyw{true}. The
    expression {\tt e} will use the identifier {\tt id}. {\tt S} is a set
    of numbers and {\tt id} will be matched to the numbers in the
    normal order (the smallest number first).
  \end{description}
  The syntax and semantics of all sequence expressions are given in
  section~\ref{seqexpr}.%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}


\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt \keyw{hd} l} & Head & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & Tail & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & Length & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & Elements & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & Indexes & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt \keyw{reverse} l} & Reverse & \TO{\SEQ{A}}{\SEQ{A}}\\
    {\tt l1 \char'136\ l2} & Concatenation & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & Distributed concatenation & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & Sequence modification & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & Sequence application & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & Equality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & Inequality & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\keyw{reverse}}\index{Reverse sequence}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


  The type {\tt A} is an arbitrary type and the operands for the
  concatenation and distributed concatenation operators do not have
  to be of the same ({\tt A}) type. The type of the resultant sequence
  will be the union type of the types of the operands. Examples will
  be given in section \ref{unions}.

\input{sem-seqtypes}

\item[Examples:] Let \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 =
    [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} then:

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{reverse} l1}  & $\equiv$ & \texttt{[2,9,5,1,4,1,3]} \\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2}
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2}
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)}
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsection{Map Types}\label{maps}

A map type from a type {\tt A} to a type {\tt B} is a type that
associates with each element of {\tt A} (or a subset of {\tt A}) an
element of {\tt B}.  A map value can be thought of as an unordered
collection of pairs.  The first element in each pair is called a key,
because it can be used as a key to get the second element (called the
information part) in that pair. All key elements in a map must therefore
be unique. The set of all key elements is called the domain of the map,
while the set of all information values is called the range of the map.
All maps in VDM languages are finite. The domain and range
elements of a map type can be arbitrarily complex, they could e.g. be
maps themselves.

A special kind of map is the injective map. An injective map is one
for which no element of the range is associated with more than one
element of the domain. For an injective map it is possible to invert
the map.

In the following this convention will be used: {\tt m}, {\tt m1} and {\tt
  m2} are maps from an arbitrary type {\tt A} to another arbitrary type
{\tt B}, {\tt ms} is a set of map values, {\tt a}, {\tt a1}, {\tt a2} and
{\tt an} are elements from {\tt A} while {\tt b}, {\tt b1}, {\tt b2} and
{\tt bn} are elements from {\tt B} and {\tt P} is a logic predicate. {\tt
  e1} and {\tt e2} are arbitrary expressions and {\tt s} is an arbitrary
set.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{map type} \dsep
    \ldots
    }

  \Rule{map type}{\Ruleref{general map type} \dsep
    \Ruleref{injective map type}}

  \Rule{general map type}{\Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

  \Rule{injective map type}{\Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}}

\item[Equation:] {\tt M = \keyw{map} A \keyw{to} B} or {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[Constructors:] \mbox{}

  \begin{description}
  \item[Map enumeration:] {\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    con\-structs a mapping of the enumerated maplets. The empty map is
    written as {\tt \{|->\}}.

  \item[Map comprehension:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}
    constructs a mapping by evaluating the expressions {\tt ed} and {\tt
      er} on all the possible bindings for which the predicate {\tt P}
    evaluates to \keyw{true}. {\tt bd1, \ldots, bdn} are bindings of
    free identifiers from the expressions {\tt ed} and {\tt er} to sets, sequences or types.
  \end{description}
  The syntax and semantics of all map expressions are given in
  section~\ref{mapexpr}.%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[Operators:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt \keyw{dom} m} & Domain & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & Range & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & Merge & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & Override & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & Distributed merge & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & Domain restrict to & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & Domain restrict by & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & Range restrict to & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & Range restrict by & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & Map apply & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & Map composition & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & Map iteration & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & Equality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & Inequality & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & Map inverse & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\input{sem-maptypes}

\item[Examples:] Let

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  then:

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ &
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{5cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2,
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\

    \texttt{\keyw{merge}\{}
         \parbox[t]{6.5cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ &
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsection{Product Types}\label{tuples}

The values of a product type are called tuples. A tuple is a fixed
length list where the i'th element of the tuple must belong to the
i'th element of the product type.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{product type} \dsep
    \ldots
    }

  \Rule{product type}{
    \Ruleref{type}, \Lop{{\tt *}}, \Ruleref{type}, \SeqPt{\Lop{{\tt *}}, \Ruleref{type}}
    }

  A product type consists of at least two subtypes.

\item[Equation:] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!tuple type}

\item[Constructors:] The tuple constructor: {\tt \keyw{mk\_}(a1, a2,
    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}

    The syntax and semantics for the tuple constructor are given in
    section~\ref{tupexpr}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    \texttt{t.\#n}   & Select     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & Equality   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  The only operators working on tuples are component select, equality
  and inequality. Tuple components may be accessed using the select
  operator or by matching against a tuple pattern. Details of the
  semantics of the tuple select operator and an example of its use are
  given in section \ref{app-expr}.

\item[Examples:] Let {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} then:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{Composite Types}\label{records}

Composite types correspond to record types\index{record type} in programming languages.
Thus, elements of this type are somewhat similar to the tuples
described in the section about product types above. The difference
between the record type and the product type is that the different
components of a record can be directly selected by means of
corresponding selector functions. In addition records are tagged with
an identifier which must be used when manipulating the record. The
only way to tag a type is by defining it as a record. It is therefore
common usage to define records with only one field in order to give it
a tag. This is another difference to tuples as a tuple must have at
least two entries whereas records can be empty.

In VDM languages, \keyw{is\_} is a reserved prefix for names
and it is used in an {\it is expression}. This is a built-in operator
which is used to determine which record type a record value belongs to.
It is often used to discriminate between the subtypes of a union type
and will therefore be explained further in section~\ref{unions}. In
addition to record types the \keyw{is\_} operator can also determine if
a value is of one of the basic types.

In the following this convention will be used: {\tt A} is a record
type, {\tt A1, \ldots, Am} are arbitrary types, {\tt r}, {\tt r1}, and
{\tt r2} are record values, {\tt i1, \ldots, im} are selectors from
the {\tt r} record value (and these must be unique entrances inside one record definition), {\tt e1, \ldots, em} are arbitrary
expressions.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{composite type} \dsep
    \ldots
    }

  \Rule{composite type}{
    \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list},
    \Lop{end}
    }

  \Rule{field list}{\SeqPt{\Ruleref{field}}}

  \Rule{field}{\OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type}
  \dsep  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

  or the shorthand notation

  \Rule{composite type}{
    \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}}

  where identifier denotes both the type name and the tag name.

\item[Equation:]\mbox{}\label{a-type}
  \begin{lstlisting}
    A :: selfirst : A1
         selsec   : A2
  \end{lstlisting}%
\index{\texttt{::}}

  or

  \begin{lstlisting}
    A :: selfirst :  A1
         selsec   :- A2
  \end{lstlisting}%
\index{\texttt{:-}}

  or

  \begin{lstlisting}
    A :: A1 A2
  \end{lstlisting}

  In the second notation, an {\it equality abstraction\/} field
  \index{equality abstraction field} is
  used for the second field {\tt selsec}. The minus indicates that
  such a field is ignored when comparing records using the equality
  operator.  In the last notation the fields of {\tt A} can only be
  accessed by pattern matching (like it is done for tuples) as the
  fields have not been named.

 % In the last notation the fields of {\tt A} can only be accessed by
  %pattern matching (as is done for tuples) since the fields have not
  %been named.

  The shorthand notation {\tt ::} used in the two previous examples
   where the tag name equals the type
  name, is the notation most used.
  The more general \keyw{compose} notation is typically used if a
  composite type has to be specified directly as a component of a more
  complex type:
  \begin{lstlisting}
    T = map S to compose A of A1 A2 end
  \end{lstlisting}
  It should be noted however that composite types can only be used in
  type definitions, and not e.g.\ in signatures to functions or
  operations.

  Typically composite types are used as alternatives in a union type
  definition (see section~\ref{unions}) such as:

  \begin{lstlisting}
   MasterA = A | B | ...
  \end{lstlisting}
  where \texttt{A} and \texttt{B} are defined as composite types
  themselves. In this situation the \keyw{is\_} predicate can be used
  to distinguish the alternatives.

\item[Constructors:] The record constructor: {\tt \keyw{mk\_}A(a, b)} where
  {\tt a} belongs to the type {\tt A1} and {\tt b} belongs to the type {\tt
    A2}.

  The syntax and semantics for all record expressions are given in
  section~\ref{recexpr}.%
\index{\keyw{mk\_}!record constructor}

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt r.i} & Field select & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Is & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\input{sem-comtypes}

\item[Examples:] Let \texttt{Score} be defined as
\begin{lstlisting}
   Score :: team   : Team
            won    : nat
            drawn  : nat
            lost   : nat
            points : nat;
   Team = <Brazil> | <France> | ...
\end{lstlisting}
\label{scoredef}
and let

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} and \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}.
\end{tabular}

\noindent%
Then

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}
  \end{tabular}

  The equality abstraction field, written using `{\tt :-}' instead of
  `{\tt :}', may be useful, for example, when working with lower level
  models of an abstract syntax of a programming language. For example,
  one may wish to add a position information field to a type of
  identifiers without affecting the true identity of identifiers:

\begin{lstlisting}
  Id :: name :  seq of char
        pos  :- nat
\end{lstlisting}

The effect of this will be that the {\tt pos} field is
ignored in equality comparisons, e.g.\
the following would evaluate to true:

\begin{lstlisting}
  mk_Id("x",7) = mk_Id("x",9)
\end{lstlisting}

In particular this can be useful when looking up in an environment
which is typically modelled as a map of the following form:

\begin{lstlisting}
  Env = map Id to Val
\end{lstlisting}

Such a map will contain at most one index for a specific identifier,
and a map lookup will be independent of the {\tt pos} field.

Moreover, the equality abstraction field will affect set expressions.
For example,
\begin{lstlisting}
  {mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)}
\end{lstlisting}

will be equal to

\begin{lstlisting}
  {mk_Id("x",?),mk_Id("y",8)}
\end{lstlisting}

where the question mark stands for 7 or 9.

Finally, note that for equality abstraction fields valid patterns are
limited to don't care and identifier patterns. Since equality
abstraction fields are ignored when comparing two values, it does not
make sense to use more complicated patterns.
\end{description}

\subsection{Union and Optional Types}\label{unions}

The union type corresponds to a set-theoretic union, i.e.\ the type
defined by means of a union type will contain all the elements from
each of the components of the union type. It is possible to use types
that are not disjoint in the union type, even though such usage
would be bad practice.  However, the union type is normally used when
something belongs to one type from a set of possible types.  The
types which constitute the union type are often composite types.  This
makes it possible, using the \keyw{is\_} operator, to decide which of
these types a given value of the union type belongs to.

The optional type {\tt [T]} is a kind of shorthand for a union type {\tt T |
  \keyw{nil}}, where \keyw{nil} is used to denote the absence of a
value. However, it is not possible to use the set {\tt \{\keyw{nil}\}}
as a type so the only types \keyw{nil} will belong to will be optional
types.


\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{union type} \dsep
    \Ruleref{optional type} \dsep
    \ldots
    }

  \Rule{union type}{
    \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
    }

  \Rule{optional type}{\Lit{[}, \Ruleref{type}, \Lit{]}}

\item[Equation:] {\tt B = A1 | A2 | \ldots\ | [An]}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[Constructors:] None.

\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[Examples:] In this example {\tt Expr} is a union type whereas
  {\tt Const}, {\tt Var}, {\tt Infix} and {\tt Cond} are composite
  types defined using the shorthand {\tt ::} notation.

\begin{lstlisting}
  Expr  = Const | Var | Infix | Cond;
  Const :: nat | bool;
  Var   :: id:Id
           tp: [<Bool> | <Nat>];
  Infix :: Expr * Op * Expr;
  Cond  :: test : Expr
           cons : Expr
           altn : Expr
\end{lstlisting}
\label{exprdef}
  and let {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} then:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
    {\tt expr.altn.tp} =} {\tt \keyw{nil} &$\equiv$& \keyw{true}\\
  \end{tabular}

  Using union types we can extend the use of previously defined
    operators. For instance, interpreting \texttt{=} as a test over
    \texttt{\keyw{bool} | \keyw{nat}} we have

 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  Similarly we can take use union types for taking unions of sets and
    concatenating sequences:

  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ &
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

  In the set union, we take the union over sets of type
    \texttt{\keyw{nat} | \keyw{bool}}; for the sequence concatenation
    we are manipulating sequences of type \texttt{\keyw{char} | <c> |
    <d>}.
\end{description}
\end{comment}

%%% Japanese Trans.
\section{基本データ型}

以下にいくつかの基本型を提示する。
その各々は次を含む:

\begin{itemize}
\item 構成の名称
\item 構成の記号
\item そのデータに属する特殊な値
\item そのデータ型に属する値のための組込み演算子。
\item 組込み演算子の意味定義。
\item 組込み演算子の使用例
  \footnote{これらの例題中では、メタ記号`$\equiv$'を用いて与えられた例題が何と同等であるかを示す。}
\end{itemize}
組込み演算子の各々については、その意味定義の記述と共に、名称、記号、そして演算子の型が与えられる(ただし相等と不等の意味については、通常の意味に従うので、記述されていない。)
意味定義の記述において、識別子は例えば\ {\tt a}, {\tt b}, {\tt x}, {\tt y}他 といったもので、対応する演算子型の定義で使用されるものを参照している。

基本型とは、言語により定義されていて、それ以上単純な値には分解することができない異なる値をもっている型とされる。
主要な基本型として5つ：ブール型、数値型、文字型、トークン型、引用型 が挙げられる。
以下にこの基本型について1つずつ説明していこう。

\subsection{ブール型}\label{bool}

一般的にVDM言語では、その中で計算が終了しなかったり結果を出せなかったりするかもしれないシステムを対象とすることも許されている。
このような潜在的な未定義状態を取り扱うために、VDM言語では3値論理：値は「true(真)」、「false(偽)」、「bottom/undefined(未定義)」のいずれかであるとする、を取り入る。
インタプリターの意味定義は、演算対象の順番に重きをおかないLPF (Logic of Partial Functions、部分関数の論理) の3値論理(\cite{Jones90a}参照)をもつものではないという意味において、 \vdmsl\ のものとは異なる。
それでも、論理積\keyw{and}、論理和\keyw{or}、それに含意演算子は、最初の演算対象のみで結果を決定するのに十分であるならば、次の演算対象をあえて評価しようとはしない、という条件つきの意味定義をもつ。
ある意味で、インタプリターの論理の意味定義は3値であると、VDM-SLに関してはまだ考えることができるであろう。
しかしながら、未定義値は無限大ループやランタイムエラーになる可能性がある。

\begin{description}
\item[名称:] \Index{ブール}
\item[記号:] \Index{\keyw{bool}}
\item[値:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[演算子:] 下記の{\tt a} と {\tt b} は任意のブール式を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称       & 型                       \\ \hline
    {\tt \keyw{not} b}& 否定   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& 論理積& \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& 論理和 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& 含意 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& 同値 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & 相等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& 不等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[演算子の意味定義:] 意味定義では、ブール値を扱う場合の {\tt <=>} と {\tt =} は等しい。 
\keyw{and}、 \keyw{or}、および {\tt=>}においては条件つきの意味定義がある。
$\perp$によって定義されていない項目 (たとえば定義域外のキーをもつ写像に適用される)を表示しよう。
ブール演算子に対する真理値表は次のとおり%
  \footnote{標準 VDM-SL ではこれらの真理値表は({\tt =>}以外は)対称性をもつことに注目しよう。}:
     
  \begin{tabular}{ll}
    否定 {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    論理積 {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    論理和 {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    含意 {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    同値 {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}     

\item[例題:] 
   {\tt a = \keyw{true}} で {\tt b = \keyw{false}} と仮定すると次のとおり:
  
  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}
%%%
\subsection{数値型}\label{numeric}

数値型には5つの基本型：正の自然数、自然数、整数、有理数、そして実数がある。
3つを除きどの数値演算子も、演算対象として5つの型の混在を許す。
例外である3つとは、整数除算、法算、剰余算、である。

5つの数値型は階層構造をなし、\Index{\keyw{実数(real)}}が最も一般的な型で{\keyw{有理数(rat)}}\footnote{VDM言語Toolboxの見地からすれば \keyw{実数(real)} と \keyw{有理数(rat)} は違いがない。コンピューター上では有理数しか表現できないからである。}、\Index{\keyw{整数(int)}}、\Index{\keyw{自然数(nat)}}、\Index{\keyw{正の自然数(nat1)}}と続く。 

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  型 & 値 \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
この表より、\keyw{int}ならばどのような数でも自動的に\keyw{real}であるが、\keyw{nat}であるとは限らないということがわかる。
言い換えると、正の自然数は自然数の一部であり、その自然数は整数の、その整数は有理数の、有理数は最終的には実数の一部である、と表現することができる。
次の表でいくつかの数が属する型を示す：

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  数 & 型 \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
すべての数が必然的に \keyw{real}型 (そして\keyw{rat}型)であることに注意。

\begin{description}
\item[名称:] 実数, 有理数, 整数, 自然数、そして 正の自然数
\item[記号:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[値:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[演算子:]  以下における{\tt x} と {\tt y} は数式を表すとする。  
 これらの型について仮定はなされない。

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称 & 型 \\ \hline
    {\tt -x}& 負符号 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& 絶対値 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& 底値  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& 加算 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& 減算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& 乗算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& 除算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& 整数除算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& 剰余算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& 法算 & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& べき算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& より小さい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& より大きい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& より小さいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& より大きいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& 相等 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& 不等& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline     
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  演算対象として書かれた型は、許される限りでの最も広範な型である。
 例えば負符号は5つのすべての型 (\keyw{nat1}, \keyw{nat}, \keyw{int} \keyw{rat} そして \keyw{real})を演算対象とする、ことを示している。
     
\item[演算子の意味:] 演算子であるマイナス符号、総和、差、積、商、小さい、大きい、等しいか小さい、等しいか大きい、相等関係、不等関係はこのような演算の通常の意味をもつ。

 \vspace{1ex}
 \begin{TypeSemantics}
    底値 &  {\tt x}と等しいかより小さい整数のうちで最大のもの \\ \hline

    絶対値 &  {\tt x}の絶対値、つまり {\tt x >= 0} ならば\ {\tt   x} そのままで{\tt x < 0}ならば {\tt -x}となる \\ \hline

    冪 &  {\tt x} を {\tt y}回乗じたもの \\ \hline
  \end{TypeSemantics}

  \vspace{1ex}
 整数商、剰余、そして法　が負の数にどのように作用するかについては、しばしば混乱がおきる。 
事実  {\tt -14 \keyw{div} 3}に対して有効な答えが２つある:  Toolboxにおいてと同様{\tt -4} (the intuitive)となるか、たとえば\ Standard ML  \cite{Paulson91}においてと同様に{\tt -5}となるかである。
したがってこれらの演算については詳細に説明しておくべきであろう。

  整数除算は {\sf floor} と実数除算を用いて定義される:

  \begin{lstlisting}
    x/y <  0:   x \keyw{div} y = -\keyw{floor}(\keyw{abs}(-x/y))
    x/y >= 0:   x \keyw{div} y =  \keyw{floor}(\keyw{abs}(x/y))
  \end{lstlisting}

 右辺の \keyw{floor}と \keyw{abs}の順により違いが生じ、その順を交換することで上記の例題は{\tt -5} となる。 
これは \keyw{floor} は常により小さい（か等しい）整数に従うからである、たとえば\ {\tt \keyw{floor} (14/3)} は {\tt    4}である一方  {\tt \keyw{floor} (-14/3)} は {\tt -5}である。

剰余 {\tt x \keyw{rem} y} と　法 {\tt x \keyw{mod} y} は、
 {\tt x} と {\tt y} の符号が同じであれば同じ値となるが、そうでない場合は異なる値となり、 \keyw{rem}は{\tt x}の符号を\keyw{mod}は{\tt y}の符号をとる。
剰余と法の公式は次のとおり:
  \begin{lstlisting}
    x \keyw{rem} y = x - y * (x \keyw{div} y)
    x \keyw{mod} y = x - y * \keyw{floor}(x/y)
  \end{lstlisting}
 そのため, {\tt -14 \keyw{rem} 3} は {\tt -2} に等しく、 {\tt -14
    \keyw{mod} 3} は {\tt 1}に等しい。 
実数軸をたどり、 {\tt -14} から進め {\tt 3}づつジャンプすることで、これらの結果を確認することができる。 
剰余はたどった負の数の最後の値であるが、それは{\tt x}にあたる最初の引数が負であるからであり、一方の法はたどった正の数の最初の値であるが、それは {\tt y} にあたる２番目の引数が正であるからである。

\item[例題:]  {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} とすると:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6       
  \end{longtable}
\end{description}
%%%
\subsection{文字型}

文字型は、VDM 文字集合(~\pageref{charSetTable}ページの表~\ref{charSetTable}を参照)中の単一の文字すべてを含む。

\begin{description}
\item[名称:] \Index{文字}
\item[記号:] \Index{\keyw{char}}
\item[値:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[演算子:]  次の{\tt c1} と {\tt c2} は任意の文字を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称      & 型 \\ \hline
    {\tt c1 = c2}  & 相等     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & 不等 & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[例題:] 
 \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsection{引用型}

引用型は、パスカルのようなプログラミング言語においては列挙型に相当する。
しかしながらVDM言語においては、中括弧の中に様々な引用リテラルを書く代わりに引用型というシングル引用リテラルからなるものを用いて、それらを合併型の一部をなすものとする。
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[名称:] \Index{引用}
\item[記号:] たとえば {\tt <QuoteLit>}\index{\texttt{<>}!引用値}
\item[値:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[演算子:] 以下の \texttt{q} と \texttt{r} が、列挙型{\tt T}に属する任意の引用値を表していると仮定すると: 

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt q = r}  & 相等     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[例題:]  \texttt{T} を次に定義された型とする:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  ここで {\tt a = <France>}であるならば次のとおり:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsection{トークン型}

トークン型は、トークンと呼ばれる異なる値の可算無限集合からなる。
トークンに対して実行される操作は、相等と不等のみである。
VDM言語におけるトークンは、\keyw{mk\_token}を用いて任意の式を囲む記述ができるのにもかかわらず、単独に表現することはできない。
これが、トークン型を含む仕様のテストを可能にする方法である。
しかしながらISO/VDM-SL標準に似せるためには、これらのトークン値はどんなパターンマッチングによっても分解できず、相等または不等の比較以外どのような演算にも用いることはできない。

\begin{description}
\item[名称:] \Index{トークン}
\item[記号:] \Index{\keyw{token}}
\item[値:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[演算子:] 以下の {\tt s} と {\tt  t} は任意のトークン値を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt s = t}  & 相等     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & 不等 & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[例題:] 次においてたとえば {\tt s = \keyw{mk\_token}(6)} 、 {\tt t
    = \keyw{mk\_token}(1)} とすると:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}
%%%
\section{合成型}

以下に合成型について説明する。 
各々の説明には以下の項目が含まれている：
\begin{itemize}
\item 合成型定義の構文
\item 構成要素をどのように用いるか示す等式
\item この型に属する値をどのように構成するか示す例題
ほとんどの場合に、基本構成子式の構文が与えられている前の節への参照が示される。
\item この型に属する値に対する演算子 \footnote{これらの演算子は、第~\ref{unandbin}節で全演算子が与えられるなかの単項式か2項式に用いられている。}
\item 演算子の意味定義
\item 演算子の使用例
\end{itemize}
演算子の各々に対し、名称、記号、演算子の型がその意味定義と共に与えられる (ただし相等と不等については、通常の意味に従うとして除かれる)。 
意味定義記述において、識別子はたとえば \ {\tt m}, {\tt m1}, {\tt s}, {\tt s1} 他 というような、対応する演算子型定義で用いられたものを参照する。
%%% 集合型
\subsection{集合型}
\label{sets}

集合とは、値を順番をつけずに集めたものであり、それらはすべて同じ型のもので\footnote{ただし合併型を用いれば、2つの値に共通な型を見つけ出すのは常に可能であることに注意 (第~\ref{unions}節参照)。}、全体は1つとして扱われる。
VDM言語におけるすべての集合は有限である、なぜならばもともと有限個の要素しか含められないからだ。 
集合型の要素は任意の合成型でありうるし、例えば集合自身の集合であってもよい。

以下の記述には次の合意を用いる：{\tt A}は任意の型、 {\tt S} は集合型、 {\tt s}、 {\tt s1}、 {\tt s2} は集合値、 {\tt ss} は集合値の集合、 {\tt e}、 {\tt e1}、 {\tt e2}、 {\tt en} は集合の要素、 {\tt bd1,} {\tt bd2}、 \ldots、{\tt bdm} は集合または型を示す識別子を束ねたもの、そして {\tt P} は論理述語である。

\begin{description}
\item[構文:] 
  \Rule{型}{
   \Ruleref{集合型} \dsep
    \ldots
    }
  
  \Rule{集合型}{\Lop{set of}, \Ruleref{型}}

\item[等式:] {\tt S = \keyw{set of} A}\index{\keyw{set of}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[集合列挙:] \verb|{e1, e2, ..., en}|  は列挙された要素の集合を構成する。
空集合は {\tt \{\}}と表記される。
  
  \item[集合内包:] \verb+{e | bd1, bd2, ..., bdm & P}+
    は、述語{\tt P}が\keyw{true}となるすべての束縛について式{\tt e} を評価することにより集合を定義する。
    束縛は集合束縛と型束縛のどちらかとなる\footnote{型束縛は実行可能ではないので一般的にはインタープリタで実行されない (これについては第~\ref{bind}節を参照)。}。  
集合束縛 {\tt bdn} は {\tt pat1, \ldots, patp \keyw{in set} s}という形式をもつが、ここでの{\tt pati}はパターン (通常は単純な識別子である)であり、 {\tt s} は1つの式で構成される集合である。 
型束縛も、\keyw{in set}がコロンに換わり {\tt s}が型式となるという意味において、同様のものである。 
  \end{description}
  すべての集合式に対する構文と意味定義は、第~\ref{setexpr}節に与えられる
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt e \keyw{in set} s1} & 帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & 非帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& 合併 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& 共通部分 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& 差 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& 包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & 真包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& 相等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& 不等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& 濃度 & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& 分配的合併& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&分配的共通部分 & \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&有限べき集合 & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  {\tt A, \SET{A}}型と {\tt \SET{\SET{A}}}型は単に型の構造を表すだけではないことに注意。 
たとえば、任意の集合 {\tt s1} と {\tt s2}の合併を行った場合、結果の集合の型は2つの集合型の合併型とすることができる。
これについての例は第 \ref{unions}節に与えられる。
      
\item[演算子の意味:] \mbox{}

\begin{TypeSemantics}
帰属関係 &  {\tt e} が集合 {\tt s1}の要素であるかどうか検査する \\ \hline
非帰属関係 &  {\tt e} が集合 {\tt s1}の要素でないことを検査する \\ \hline
合併 & 集合 {\tt s1} と {\tt s2}の合併、つまり\  {\tt s1} と {\tt s2}の両方の要素をすべて含む集合である。 \\ \hline
共通部分 & 集合 {\tt s1} と {\tt s2}の共通部分、つまり\  {\tt s1} と{\tt s2}の両方にある要素を含む集合である。 \\ \hline
差 &  {\tt s2}に含まれていない{\tt s1}の要素をすべて含む集合。 {\tt s2} は{\tt s1}の部分集合である必要はない。 \\ \hline
包含関係 &  {\tt s1}が {\tt s2}の部分集合であるかどうかを検査する、つまり\  {\tt s1} のすべての要素が {\tt s2}の要素であるかどうかである。どの集合もそれ自身の部分集合であることには注意。 \\ \hline
真包含関係 &  {\tt s1} が {\tt s2}の真部分集合であることを検査する、つまり\ 部分集合でありしかも {\tt s2$\backslash$s1} が空集合でないことである。 \\ \hline
濃度 &  {\tt s1}の要素の数。 \\ \hline
分配的合併 & 結果の集合は{\tt ss}のすべての要素(それら自身が集合である)の合併である、つまり{\tt ss}のすべての要素／集合のすべての要素を含む。 \\ \hline
分配的共通部分 & 結果の集合はすべての要素の共通部分であり、つまり\ {\tt ss}のすべての要素／集合の中の要素を含むということ。 {\tt ss}は空集合であってはならない。 \\ \hline
有限べき集合 & {\tt s1}のべき集合である、つまり\  {\tt s1}のすべての部分集合の集合である。 \\ \hline
\end{TypeSemantics}

\item[例題:]%
  {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}}、{\tt s2 = \{2, 4, 6, 8, 11\}} 、 {\tt s3 = \{\}} であるときには以下のとおり: 

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

%%% 列型
\subsection{列型}
\label{sequences}

列値とは ある型の要素を順にならべた集まりで{\tt 1, 2, \ldots, n}によって索引づけられるもの；ここでは {\tt n}がこの列の長さとなる。 
列型とはある型の要素を有限個連続させた型であり、空列を含む場合(空列を含む列型)と含まない場合(空列を含まない列型)のいずれかとなる。
列型の要素には任意の混在が許されている; たとえばそれらが連続したものであればよいわけである。

以下はこの合意が用いられる: {\tt A}は任意の型であり、{\tt L}は列型であり、 {\tt S}は集合型であり、  {\tt l}, {\tt  l1}, {\tt l2} は列値であり、 {\tt ll}は列値の列である。 
{\tt e1}, {\tt e2} および {\tt en} はこれらの列の要素、 {\tt i}は自然数、 {\tt P} は述語、 {\tt e}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{列型} \dsep
    \ldots
    }

  \Rule{列型}{\Ruleref{空列を含む列型} \dsep
    \Ruleref{空列を含まない列型}}

  \Rule{空列を含む列型}{\Lop{seq of}, \Ruleref{型}}
  
  \Rule{空列を含まない列型}{\Lop{seq1 of}, \Ruleref{型}}
\item[等式:] {\tt L = \keyw{seq of} A} または {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type 
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements. 

\item[構成子:] \mbox{}

  \begin{description}
  \item[列列挙:] \verb+[e1, e2,..., en]+ は、列挙された要素によって列を構成する。 
空列は \verb+[]+と表現する。 
テキストリテラルは文字の列挙の簡約記法である (たとえば\ {\tt "csk" = ['c','s','k']})

  \item[列内包:] {\tt [e | id \keyw{in set} S \& P]}
    は、述語{\tt P}が  \keyw{true}となるようなすべての束縛に対して式 {\tt e}を評価することで列を構成する。
式 {\tt e} は識別子 {\tt id}を用いる。 
{\tt S} は数の集合であり、 {\tt id} は通常の順で数とマッチする (最小の数を最初として)
  \end{description}
  すべての列式の構文と意味定義については、第~\ref{seqexpr}節で述べる。%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}

      
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{hd} l} & 先頭 & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & 尾部 & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & 長さ & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & 要素集合 & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & 索引集合 & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt l1 \char'136\ l2} & 連結 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & 分配的連結 & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & 列修正 & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & 列適用 & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & 相等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & 不等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


 型{\tt A}は任意の型であって、連結や分配的連結の演算子に対する演算対象は、同じ型({\tt A}) である必要はない。 
結果列の型は、複数の演算対象の型の合併型となる。
第 \ref{unions}節に例題が与えられている。

\item[演算子の意味定義:] \mbox{}

\begin{TypeSemantics}
先頭 & {\tt l}の最初の要素。 {\tt l} は空列であってはならない。 \\ \hline
尾部 &  {\tt l}から最初の要素を取り除いた部分列。 {\tt l} は空列であってはならない。\\ \hline
長さ &  {\tt l}の長さ。 \\ \hline
要素集合 & {\tt l}の要素すべてを含む集合。 \\ \hline
索引集合 &  {\tt l}の索引すべてを含む集合。 \mbox{\tt \{1,...,len l\}}。 \\ \hline
連結 & {\tt l1} と {\tt l2}の連結、つまり順に、 {\tt l1} の列要素のあとに{\tt l2}の列要素を続けた列。 \\ \hline
分配的連結 &  {\tt ll}の列要素(これら自体が列である)が連結された列: 最初と第２の列要素を連結し、次に第３の列要素を連結し、等々。 \\ \hline
列修正 &  列索引が{\tt m}の定義域にある{\tt l} の列要素は、その索引が写像された先の値域値に修正される。 {\tt dom m} は索引 {\tt l}の部分集合でなければならない。 \\ \hline
列適用 &  {\tt l}から始まる索引の要素。 {\tt i} は {\tt l}の索引集合になければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 = [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} とすると以下のとおり： 

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)} 
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}
%%% 写像型
\subsection{写像型}\label{maps}

 {\tt A}型から {\tt B}型への写像型とは、 {\tt A} (または {\tt A}の部分集合)の要素各々を {\tt B}の1つの要素と結合する型のことである。 
写像の値とは、この2つの要素の組を順不同で集めたものと考えることができる。
各々の組の最初の要素をキーと呼ぶが、これは各組で最初の要素を用いて2番目の要素 (情報部分と呼ばれる) を得ることができるからである。
よって1つの写像におけるキー要素は、すべて異なるものでなければならない。
すべてのキー要素の集合をこの写像の定義域と呼び、一方すべての情報値の集合を値域と呼ぶ。
VDM言語におけるすべての写像とは有限のものである。
写像型の定義域と値域の要素には任意の合成が許されていて、たとえば要素を写像とすることもできる。

特別な写像としては1対1写像がある。 
1対1写像とは、値域の要素で2つ以上の定義域の要素と結合するものはない写像のことである。
この1対1写像では、写像を逆にすることが可能である。

以下では次のとおりに用いる: {\tt m}, {\tt m1}、および{\tt m2} は、任意の{\tt A}型からもう1つの任意の{\tt B}型への写像を表し、{\tt ms} は写像値の集合であり。
 {\tt a}, {\tt a1}, {\tt a2}、および{\tt an}は {\tt A}から取り出した要素である一方、 {\tt b}, {\tt b1}, {\tt b2} および{\tt bn}は{\tt B}から取り出した要素である。{\tt P}は論理述語である。
{\tt  e1}、{\tt e2} は任意の式であり、 {\tt s}は任意の集合である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{写像型} \dsep
    \ldots
    }
  
  \Rule{写像型}{\Ruleref{一般写像型} \dsep
    \Ruleref{1対1写像型}}
  
  \Rule{一般写像型}{\Lop{map}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}
  
  \Rule{1対1写像型}{\Lop{inmap}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}

\item[等式:] {\tt M = \keyw{map} A \keyw{to} B} または {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[写像列挙:] 
{\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    は、列挙された写からなる写像を構成する。 
空写像は {\tt \{|->\}}と表す。

  \item[写像内包:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}は、述語{\tt P}が \keyw{true}と判断するすべてのありうる束縛上で、式{\tt ed} と {\tt er}を評価することによって写像を構成する。
  \end{description}
すべての写像式の構文と意味定義については、第~\ref{mapexpr}節で述べる。%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[演算子:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{dom} m} & 定義域 & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & 値域 & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & 併合 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & 上書 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & 分配的併合 & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & 定義域限定 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & 定義域削減 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & 値域限定 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & 値域削減 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & 写像適用 & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & 写像合成 & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & 写像反復 & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & 相等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & 不等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & 逆写像 & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\item[演算子の意味定義:] ２つの写像 {\tt m1} と {\tt m2} は、{\tt dom m1} と {\tt dom m2}に共通の要素が両写像により同じ値に写像されるならば、両立している。

\vspace{1ex}
\begin{TypeSemantics}
定義域 & {\tt m}の定義域 (キーの集合)。 \\ \hline
値域 & {\tt m}の値域 (情報値の集合)。  \\ \hline
併合 &  {\tt m1} と {\tt m2}が結合した写像で、結果の写像は  {\tt m1}と同様に{\tt dom m1}の要素に、 また{\tt m2}と同様に {\tt dom m2} の要素に、写像を行う。２つの写像は両立していなければならない。 \\ \hline
上書 &  {\tt m1} に {\tt m2}を上書または併合する、つまり\  {\tt m1} と {\tt m2}は必ずしも両立する必要はないということを除けば、併合と似ている。
共通の要素はいずれも {\tt m2} によるものとして写像される(したがって {\tt m2} は{\tt m1}を上書する)。 \\ \hline
分配的併合 &  {\tt ms}に含まれるすべての写像を併合することにより構成される写像。 {\tt ms}に含まれる写像は両立していなければならない。 \\ \hline
定義域限定 & {\tt m}の要素のうちでキーが{\tt s}に含まれるもの、から構成される写像をつくりだす。{\tt s}は {\tt dom m}の部分集合である必要はない。 \\ \hline
値域限定 & {\tt m}の要素のうちで情報値が {\tt s}に含まれるもの、から構成される写像をつくりだす。 {\tt s}は {\tt rng m}の部分集合である必要はない。 \\ \hline
写像の適用 & キーが {\tt d}である写像の情報値。 {\tt d} は {\tt m}の定義域に含まれていなければならない。 \\ \hline
写像の合成 &  {\tt  m2} の要素に {\tt m1} の要素を合成してつくった写像。結果は {\tt m2}と同じ定義域をもった１つの写像である。 あるキーに対応する情報値は、最初に{\tt m2} をキーに適用しその後 {\tt m1} をその結果に適用することによって見つけられるものである。{\tt rng m2}は {\tt  dom m1}の部分集合でなければならない。 \\ \hline
写像の反復 &  {\tt m} からそれ自体を{\tt n}回繰り返すことで構成された写像。 {\tt n = 0} は{\tt dom m}の各々の要素がそれ自体への写像である同一写像； {\tt n = 1} は{\tt m} 自体である。{\tt n > 1}に対して、 {\tt m}の値域は {\tt dom m}の集合でなければならない。\\ \hline
逆写像 & {\tt m}の逆写像。 {\tt m} は１対１写像でなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] 次を仮定すると

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  以下のとおり：

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ & 
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ & 
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\ 
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{4cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2, 
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\
    
    \texttt{\keyw{merge}\{}
         \parbox[t]{5.7cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ & 
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}
%%% 組型
\subsection{組型}\label{tuples}

組型の値を組と呼ぶ。
組とは固定長のリストであり、組のｉ番目の要素は組型のｉ番目の要素に属さなければならない。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{組型} \dsep
    \ldots
    }

  \Rule{組型}{
    \Ruleref{型}, \Lop{{\tt *}}, \Ruleref{型}, \SeqPt{\Lop{{\tt *}}, \Ruleref{型}}
    }

  組型は少なくとも2つの部分型から構成される。

\item[等式：] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!組型}

\item[構成子：] 組構成子： {\tt \keyw{mk\_}(a1, a2,
%    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}
    \ldots, an)}\index{\keyw{mk\_}!組構成子}

     組構成子についての構文と意味定義は第~\ref{tupexpr}節で述べられる。 
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    \texttt{t.\#n}   & 選択     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & 相等   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  組に対して有効な演算子は、構成要素選択、相等、不等、のみである。
組構成要素は、選択演算子を用いたり組パターンとマッチングさせることで、アクセスすることもできる。
組選択演算子についての意味定義の詳細および使用例は、第 \ref{app-expr}節に述べる。 

\item[例題:]  {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} とすると以下のとおり:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

%%% レコード型
\subsection{レコード型}\label{records}

レコード型は、プログラミング言語においての構造体に相当する。
したがってこの型の要素は、前述の組型の節で述べられた組にいくぶんか似ている。
レコード型と組型の違いは、レコードの異なる構成要素は相応の選択関数を用いることで、直接選択することができることである。 
さらに加えて、レコードは操作するとき用いられるべき識別子によってタグ付けされる。一般的な使い方として、タグを与えるためにはただ1つの項目からなるレコードも定義される。
組とのもうひとつの違いとなるが、組は少なくとも2つの実体をもつ必要があるが、レコードは空でもよい。

VDM言語における \keyw{is\_} は名称に対する予約接頭辞であって{\it is式}の中で使用される。 
これは、あるレコード値がどのレコード型に属するのか決定するために用いられる、組込演算子である。
しばしば合併型の部分型同士を区別することに用いられるため、更なる説明が第~\ref{unions}節になされている。 
\keyw{is\_}演算子は、レコード型を決定するのに加え、ある値が基本型のひとつであるかどうかの決定も行うことができる。
 
以下では次の約束に従う： {\tt A}はレコード型、 {\tt A1, \ldots, Am}は任意の型、 {\tt r}, {\tt r1}, {\tt r2}はレコード値、 {\tt i1, \ldots, im}はレコード値 {\tt r}からの選択子、 {\tt e1, \ldots, em}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{レコード型} \dsep
    \ldots
    }
  
  \Rule{レコード型}{
    \Lop{compose}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト},
    \Lop{end}
    }
  
  \Rule{項目リスト}{\SeqPt{\Ruleref{項目}}}
  
  \Rule{項目}{\OptPt{\Ruleref{識別子}, \Lit{:}}, \Ruleref{型}
  \dsep  \OptPt{\Ruleref{識別子}, \Lit{:-}}, \Ruleref{型}
  }
  
  または省略型表記法で
  
  \Rule{レコード型}{
    \Ruleref{識別子}, \Lit{::}, \Ruleref{項目リスト}}
  
  この識別子が表すものは型名かタグ名である。

\item[等式:]
\mbox{}\label{a-type}
  \begin{lstlisting}
    A :: selfirst : A1
         selsec   : A2
  \end{lstlisting}%
\index{\texttt{::}}

	または

  \begin{lstlisting}
    A :: selfirst :  A1
         selsec   :- A2
  \end{lstlisting}%
\index{\texttt{:-}}

	または

  \begin{lstlisting}
    A :: A1 A2
  \end{lstlisting}

  2番目の表記では、 {\it 比較対象外\/} 項目
  \index{equality abstraction field} が第2項 {\tt selsec}に対し用いられる。
この負符号は、等号演算子を使ってレコード比較を行うときにこの項が無視されることを指定している。
最後の表記法では {\tt A} の項目はひとつひとつに名称が付けられていないため、パターンマッチングによってのみ(組についてそうだったように)アクセスを行うことができる。
  
省略型表記である {\tt ::} は前の2例でも使われ、タグ名が型名と等しいというものだが、この表記法は最もよく用いられている。
 より一般的である \keyw{compose} 表記法は、次のようにレコード型がそれより複雑な型の構成要素として直接記述されなければならない場合に、典型的に用いられる:

  \begin{lstlisting}
    T = map S to compose A of A1 A2 end
  \end{lstlisting}
しかしながら、レコード型は型定義においてのみ用いることができるもので、例えば関数や操作に対するシグネチャにおいてではないことは明記しておくべきであろう。

レコード型は、合併型定義における代案(~\ref{unions}を参照)として、典型的に用いられる:

  \begin{lstlisting}
   MasterA = A | B | ...
  \end{lstlisting}
ここで \texttt{A} と \texttt{B} は、自身がレコード型として定義されている。
この状態で、 \keyw{is\_} 前置詞を代案と区別するために用いることができる。

\item[構成子:]
レコード構成子: {\tt \keyw{mk\_}A(a, b)} において、 {\tt a} は型 {\tt A1} に属し {\tt b} は型 {\tt A2}に属す。

 すべてのレコード式に対する構文と意味定義は第~\ref{recexpr}節で与えられる。
%\index{\keyw{mk\_}!record constructor}
\index{\keyw{mk\_}!レコード構成子}

\item[演算子:] 
 \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt r.i} & 項目選択 & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & 相等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & 不等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Ｉｓ & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
項目選択 & レコード値 {\tt r}の中で項目名が {\tt i} である項目の値。
{\tt r} は {\tt i} という名の項目をもっていなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] \texttt{Score} は以下のように定義される
\begin{lstlisting}
   Score :: team : Team
            won : nat
            drawn : nat
            lost : nat
            points : nat;
   Team = <Brazil> | <France> | ...
\end{lstlisting}
\label{scoredef}
さらに次の通りとする 

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} そして \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}
\end{tabular}

\noindent%
このとき

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}  
  \end{tabular}

  `{\tt :}'の代わりに`{\tt :-}'を用いて記述する比較対象外項目は、たとえばプログラム言語の抽象構文における低水準モデルにおいて役立つことがある。
例としては、識別子の一意性に影響を与えることなく、それらの識別子の型に位置情報項目を加えたい場合などである。

\begin{lstlisting}
  Id :: name :  seq of char
        pos  :- nat
\end{lstlisting}

この効果は{\tt pos}項が相等比較において無視されることにあり、たとえば次の例はtrueと評価されるであろう：

\begin{lstlisting}
  mk_Id("x",7) = mk_Id("x",9)
\end{lstlisting}

特にこのことは、以下の形の写像の典型的な環境において検索を行う場合に役に立つはずである:

\begin{lstlisting}
  Env = map Id to Val
\end{lstlisting}

このような写像は指定の識別子に対し最大1つの索引を含み、写像検索は {\tt pos}項目から独立したものとなる。

そのうえ、比較対象外項目は集合式に影響を与える。
たとえば、 
\begin{lstlisting}
  \{mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)\}
\end{lstlisting}

は次と等しくなる

\begin{lstlisting}
  \{mk_Id("x",?),mk_Id("y",8)\}
\end{lstlisting}

ここにおける疑問符は7から9までを表している。

最後に比較対象外項目に対する有効なパターンとしては、don't careあるいは識別子パターンに限定されていることには注意しよう。
比較対象外項目は2つの値を比較するときに無視されるものであり、それ以上複雑なパターンを用いることに対しては意味をなさないからである。
\end{description}

%%% 合併型と選択型
\subsection{合併型と選択型}\label{unions}

合併型は集合論理における和に相当する、つまり合併型として定義される型はその合併型の構成要素各々からすべての要素を含むことになる。
合併型の中で互いに素であるとはいえない複数の型を用いることは、あまりよくない使用法だが可能ではある。 
しかし通常は、属する型として可能な複数の型から1つを考える場合には合併型が用いられる。 
合併型を構成する型としてしばしばレコード型がある。
\keyw{is\_}演算子を用いることで、合併型のある値がこういった型のいずれに属するものであるのかを決定することが可能である。

選択型 {\tt [T]} とは合併型{\tt T | \keyw{nil}}に対してのいわゆる省略であり、 この\keyw{nil} は値が存在しないことを表記するために用いられるものである。
ただし集合 {\tt \{\keyw{nil}\}}をひとつの型として用いることはできないので、 \keyw{nil}を含む型のみが選択型となりうる。 


\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{合併型} \dsep
    \Ruleref{選択型} \dsep
    \ldots
    }
  
  \Rule{合併型}{
    \Ruleref{型}, \Lit{|}, \Ruleref{型}, \SeqPt{\Lit{|}, \Ruleref{型}}
    }
  
  \Rule{選択型}{\Lit{[}, \Ruleref{型}, \Lit{]}}

\item[等式:] {\tt B = A1 | A2 | \ldots\ | An}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[構成子:] なし

\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[例題:] この例題中で 
  {\tt Const}, {\tt Var}, {\tt Infix} および {\tt Cond} は省略 {\tt ::} 記法を用いて定義されたレコード型であることから、{\tt Expr} は合併型である。

  \begin{lstlisting}
    Expr  = Const | Var | Infix | Cond;
    Const :: nat | bool;
    Var   :: id:Id
             tp: [<Bool> | <Nat>];
    Infix :: Expr * Op * Expr;
    Cond  :: test : Expr
             cons : Expr
             altn : Expr
  \end{lstlisting}
  \label{exprdef}
  また {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} とすると:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
  \end{tabular}

  合併型を用いることで、今までで定義してきた演算子の使用を拡張することができる。たとえば \texttt{=}を \texttt{\keyw{bool} | \keyw{nat}}上でのテストと解釈することで次を得る。
 
 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  同様に、集合の合併や列の連結の代わりに合併型を用いることができる:
  
  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ & 
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

集合合併においては、 \texttt{\keyw{nat} | \keyw{bool}}型の集合上での合併を考える；一方列連結に対しては、 \texttt{\keyw{char} | <c> | <d>}型の列を操作している。 \end{description}
%%% オブジェクト参照型

\begin{comment}
\subsection{The Object Reference Type (VDM++ and VDM-RT)}

The object reference type has been added as part of the standard
VDM-SL\ types. Therefore there is no direct way of restricting the use
of object reference types (and thus of objects) in a way that conforms
to pure object oriented principles; no additional structuring
mechanisms than classes are foreseen. From these principles it follows
that the use of an object reference type in combination with a type
constructor (record, map, set, etc.) should be treated with caution.

A value of the object reference type can be regarded as a {\em
reference} to an object.  If, for example, an instance variable (see
section \ref{sec:ivars}) is defined to be of this type, this makes the
class in which that instance variable is defined, a `client' of the
class in the object reference type; a {\em clientship relation} is
established between the two classes.

An object reference type is denoted by a class name.  The class name
in the object reference type must be the name of a class defined in
the specification.

The only operators defined for values of this type is the test for
equality (\Lit{=}) and inequality (\Lit{<>}). Equality is based on references rather than
values. That is, if \texttt{o1} and \texttt{o2} are two distinct
objects which happen to have the same contents, \texttt{o1 = o2} will
yield false.

\begin{description}
\item[Constructors] Object references are constructed using the new
expression (see section \ref{sec:creation}).

\item[Operators]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    Operator & Name & Type \\ \hline
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}

\item[Examples]
An example of the use of object references is in the definition of the
class of binary trees:
\begin{lstlisting}
class Tree

types

  protected tree = <Empty> | node;

  public node :: lt   : Tree
                 nval : int
                 rt   : Tree

instance variables

  protected root: tree := <Empty>;
end Tree
\end{lstlisting}
\label{TreeDef}

Here we define the type of nodes, which consist of a node value, and
references to left and right tree objects.
Details of access specifiers may be found in section
\ref{ch:interface}.
\end{description}
\end{comment}

%%%
\subsection{オブジェクト参照型}

オブジェクト参照型が標準\vdmsl\ の型に加えられた。 
したがって純粋なオブジェクト指向原則に従うように、
オブジェクト参照型(およびそのオブジェクト)の使用を制限する直接的な方法は存在しない；
クラス以外の構造化機能の追加は現段階では予定されていない。
こうした原則から考えれば、型構成子(レコード、写像、集合、等々)と組み合わせられた
オブジェクト参照型の使用には、十分な注意を払うべきである。

オブジェクト参照型の値はオブジェクトへの{\em 参照}とみなすことができる。
たとえばもし、あるインスタンス変数 (第\ref{sec:ivars}節参照) がオブジェクト参照型として定義されるならば、このインスタンス変数が定義されているクラスは、オブジェクト参照型の中のクラスの「クライアント」となる；つまり{\em クライアント関係} がこの2つのクラス間に確立する。

オブジェクト参照型はクラス名によって表示される。
オブジェクト参照型に含まれるクラス名は、
その仕様の中で定義された1つのクラスの名称でなければならない。

この型の値に対して定義された演算子は、相等 (\Lit{=}) と不等 (\Lit{<>}) のみである。 
相等は、値ではなく参照に基づくものとなる。
このため、もし \texttt{o1} と \texttt{o2} が2つの異なるオブジェクトならば、
たまたま同じ内容であったとしても、\texttt{o1 = o2} はfalseとなる。

\begin{description}
\item[構成子] オブジェクト参照はnew式 (第 \ref{sec:creation}節参照)を用いて構成される。

\item[演算子]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}

\item[例題]
オブジェクト参照の使用例として二分木のクラス定義を示す:
\begin{lstlisting}
class Tree

  types

    \PROTECTED tree = <Empty> | node;
    
    \PUBLIC node :: lt: Tree
                   nval : int
                   rt : Tree

 instance variables
    \PROTECTED root: tree := <Empty>;
end Tree
\end{lstlisting}
 \label{TreeDef}
ここではnode型を定義している、この型はnodeの値をnvalで、左右のTreeオブジェクトへの参照をそれぞれltとrtで行っている。
アクセス指定子についての詳細は第\ref{ch:interface}節に述べられている。
\end{description}


%%% 関数型

\begin{comment}
\subsection{Function Types}

In the VDM languages function types can also be used in type
definitions.  A function type from a type {\tt A} (actually a list of
types as a tuple type) to a type {\tt B} is a type that associates with each element
of {\tt A} an element of {\tt B}. A function value can be thought of
as a function in a programming language which has no side-effects
(i.e.\ it does not use any global variables).

Such usage can be considered advanced in the sense
that functions are used as values (thus this section
may be skipped during the first reading). Function values may be created by
lambda expressions (see below), or by function definitions, which are
described in section~\ref{functiondef}.  Function values can be of
higher order in the sense that they can take functions as arguments or
return functions as results. In this way functions can be Curried such
that a new function is returned when the first set of parameters are
supplied (see the examples below).

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[Syntax:]
  \Rule{type}{
    \Ruleref{partial function type} \dsep
    \ldots
    }

  \Rule{function type}{
    \Ruleref{partial function type} \dsep
    \Ruleref{total function type}
    }

  \Rule{partial function type}{
    \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}}

  \Rule{total function type}{
    \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}}

  \Rule{discretionary type}{\Ruleref{type} \dsepl \Lit{(},\Lit{)}}

\item[Equation:] {\tt F = A +> B}\footnote{Note that the total
function arrow can only be used in signatures of totally defined
functions and thus not in a type definition.} or {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[Constructors:] In addition to the traditional function
  definitions the only way to construct functions is by the lambda
  expression: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
  where the {\tt patj} are patterns, the {\tt Tj} are type expressions, and
  {\tt body} is the body expression which may use the pattern
  identifiers from all the patterns.

  The syntax and semantics for the lambda expression are given in
  section~\ref{lambda}.
\item[Operators:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    Operator & Name & Type \\ \hline
    {\tt f(a1,\ldots,an)} & Function apply & \TO{A1 * $\cdots$ * An}{B} \\
    {\tt f1 \keyw{comp} f2}& Function composition & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & Function iteration & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & Equality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & Inequality & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}

  Note that equality and inequality between type values should be used
  with great care. In the VDM languages this corresponds to the
  mathematical equality (and inequality) which is not computable for
  infinite values like general functions. Thus, in the
  VDM interpreters the
  equality is on the abstract syntax of the function value (see {\tt
    inc1} and {\tt inc2} below).

\input{sem-functypes}

\item[Examples:] Let the following function values be defined:
  \begin{lstlisting}
    f1 = lambda x : nat & lambda y : nat & x + y
    f2 = lambda x : nat & x + 2
    inc1 = lambda x : nat & x + 1
    inc2 = lambda y : nat & y + 1
  \end{lstlisting}
  then the following holds:

  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}

  Notice that the equality test does not yield the expected result with
  respect to the semantics of the VDM languages. Thus, one should
  be {\bf very} careful with the usage of equality for infinite values
  like functions.
\end{description}

\section{Invariants}

If the data types specified by means of equations as described above
contain values which should not be allowed, then it is possible to restrict
the values in a type by means of an invariant. The result is that the type
is restricted to a subset of its original values. Thus, by means of a
predicate the acceptable values of the defined type are limited to those
where this expression is true.

The general scheme for using invariants looks like this:

\begin{lstlisting}
  Id = Type
  inv pat == expr
\end{lstlisting}

\noindent where {\tt pat} is a pattern matching the values belonging to the type
{\tt Id}, and {\tt expr} is a truth-valued expression, involving some or
all of the identifiers from the pattern {\tt pat}.

If an invariant is defined, a new (total) function is implicitly
created with the signature:
\begin{lstlisting}
  inv_Id : Type +> bool
\end{lstlisting}
This function can be used within other invariant, function or operation
definitions.

For instance, recall the record type \texttt{Score} defined on page
\pageref{scoredef}. We can ensure that the number of points awarded
is consistent with the number of games won and drawn using an invariant:
\begin{lstlisting}
  Score :: team   : Team
           won    : nat
           drawn  : nat
           lost   : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}
The invariant function implicitly created for this type is:
\begin{lstlisting}
  inv_Score : Score +> bool
  inv_Score (sc) ==
    sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}
\end{comment}

%%% 関数型
\subsection{関数型}

VDM言語では、関数型もまた型定義に用いることができる。
型{\tt A} (実際は型のリスト) から型 {\tt B}への関数型というのは、型 {\tt A} の各々の要素に対して {\tt B}の要素を結びつける型である。
関数の値は、プログラム言語においての関数と同じもので他に副作用をおよぼすことのない(つまりグローバル変数を使用していない)ものとして考えることができる。

このような用い方は、関数が値として用いられるという意味で上級向けの使用法と考えることができる(したがって初読ではこの節はとばしていただいてもよい)。
関数値は、ラムダ式 (以下を参照)によって生成されることもあるし、第~\ref{functiondef}節に述べる関数定義による場合もある。 
関数値は、関数を引数としたりまた戻り値にすることができるという意味で、高階なものとなり得る。
この方法を用いれば、最初のパラメーターの組が与えられると新しい関数が1つ返されるというように、関数はカリー化されることが可能である (次の例題を参照)。

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[構文:]
  \Rule{型}{
    \Ruleref{関数型} \dsep
    \ldots
    }
  
  \Rule{関数型}{
    \Ruleref{部分関数型} \dsep
    \Ruleref{全関数型}
    }

  \Rule{部分関数型}{
    \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}}
  
  \Rule{全関数型}{
    \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}}
  
  \Rule{任意の型}{\Ruleref{型} \dsepl \Lit{(},\Lit{)}} 
  
\item[等式:] {\tt F = A +> B}\footnote{全関数矢印は全定義関数のシグネチャにおいてのみ用いることができ、型定義においては用いることはできないことに注意したい。} または {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[構成子:] 伝統的な関数定義に加えて、関数を構成する唯一の方法がラムダ式によるものである: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
ここにおける {\tt patj} はパターン、 {\tt Tj} は型式、そして{\tt body} は本体式で全パターンよりパターン識別子を用いることが許されている。

  ラムダ式に対する構文や意味定義は、第~\ref{lambda}節にある。
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt f(a1,\ldots,an)} & 関数適用 & \TO{A1 * $\cdots$ * An}{B} \\
    {\tt f1 \keyw{comp} f2}& 関数合成 & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & 関数反復 & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}
  
 型値間での相等と不等については、最大の注意を払うべきである。
 VDM言語においてこれは、数学上の相等 (または不等)に相等するが、一般関数と同様に無限値に対して計算不能となる。
このように、インタプリターでの相等は関数値の抽象構文上のものである ( 以下の{\tt
    inc1}と {\tt inc2}を参照)。

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
関数適用 & 関数 {\tt f}を {\tt a$_j$}の値に適用した結果。
第 \protect\ref{app-expr}章の適用式の定義を参照のこと。 \\ \hline
関数合成 & 最初に {\tt f2}を適用して次はその結果に {\tt f1} を適用することと同等な関数。
{\tt f1}はカリー化されてもよいが，{\tt f2}はいけない。 \\ \hline
関数繰り返し & {\tt  f}を{\tt n}回適用することと同等な関数。 {\tt n = 0} の場合はそのパラメーター値をそのまま返す恒等関数となる。 {\tt n = 1} の場合はその関数自身となる。 {\tt n > 1}の場合、 {\tt f} の戻り値はそれ自身のパラメーター型に含まれるものでなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  以下に関数の値を定義してみよう:
  \begin{lstlisting}
    f1 = \keyw{lambda} x : \keyw{nat} \& \keyw{lambda} y : \keyw{nat} \& x + y
    f2 = \keyw{lambda} x : \keyw{nat} \& x + 2
    inc1 = \keyw{lambda} x : \keyw{nat} \& x + 1
    inc2 = \keyw{lambda} y : \keyw{nat} \& y + 1
  \end{lstlisting}
  ここで次のことが導かれる:
  
  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}
  
 相等判定は、VDM言語の意味定義に基づいての期待される結果に従うものではないことに注意したい。 
このように、関数といった無限値に対する相等の使用には{\bf 十分}注意深くなる必要がある。
\end{description}

%\subsection{Recursive Types}
%
%In the data type equations given so far we have only used the equations in
%a hierarchical manner (the data type identifiers occurring on the
%right-hand-side in the equations have already been defined).  However,
%there are occasions when it is appropriate to use a collection of
%equations which are mutually recursive. 
%
%Without going into the mathematical details about how such recursive
%equations are solved, it will shortly be explained what they denote and how
%their usage must be restricted. We define that the semantics of such a
%collection of mutually recursive equations is that the data types become
%the set of all those values which can be constructed by using the equations
%a finite number of times. Thus, types containing infinite values cannot be
%constructed by means of recursive definitions.
%
%In order to achieve this, the recursive equations need to fulfill two
%requirements:
%\begin{enumerate}
%\item There must exist at least one alternative in a union type which is
%  fully defined elsewhere (a so-called base case).
%
%\item It must not be possible for a data value to belong to two different
%  alternatives in a union type. Thus, for recursive equations the
%  alternatives in union types must be disjunct.
%\end{enumerate}
%If these two requirements are fulfilled then the recursive type definitions
%are interpreted as the collection of finite values which are constructed by
%a finite number of steps in this process.
%
%To illustrate the use of recursive type definitions here is an example
%modelling a forest using recursive type definitions.
%
%\begin{lstlisting}
%  Forest = Forest * Node * Forest;
%  Node = \keyw{nat} | Forest
%\end{lstlisting}
%
%\noindent It is clear that the first requirement (1) cannot be fulfilled,
%because there is no base case for the forest type. Thus, these type
%definitions only specify infinite forests, and thus are not valid in
%\vdmslpp{\vdmsl}{\vdmpp}.
%
%Let us try to repair this by letting a node be the base case in the
%first definition:
%
%\begin{lstlisting}
%  Forest = Node | (Forest * Node * Forest);
%  Node = \keyw{nat} | Forest
%\end{lstlisting}
%
%\noindent However, these two definitions do not fulfill the second
%requirement. This can be seen from the fact that a forest can be a node, and 
%that node in turn can be a forest, etc. In this case it is not possible to say
%which alternative a given value belongs to. Thus, these definitions are
% not valid in \vdmslpp{\vdmsl}{\vdmpp}\ either.
%
%Now let us try to repair it by letting the base case be empty (i.e.\ 
%a nil value):
%
%\begin{lstlisting}
%  Forest = [Forest * Node * Forest];
%  Node = \keyw{nat} | Forest
%\end{lstlisting}
%
%\noindent These definitions are valid, but they specify something slightly
%different than the intention behind the definitions above. With these
%definitions an empty forest exists, and this is not the case for the
%definitions above.
%
%Finally we try to repair it by means of tagging:
%
%\begin{lstlisting}
%  Forest = Node | (Forest * Node * Forest);
%  Node :: \keyw{nat} | Forest
%\end{lstlisting}
%
%\noindent By making {\tt Node} a composite type, the definitions are valid,
%because the second requirement is also fulfilled here, due to tagging of
%the node. With these definitions an empty forest will not exist.
%
\section{不変条件}

もし先に述べた等式によって指定されたデータ型が許されるべきでない値を含むような場合、それは1つの不変条件により1つの型の値に制限することができる。
結果として、その型はもともとの値の部分集合に制限されるということである。
このように、述語の手段によって、定義された型の条件にかなう値はこの式がtrueとなる値に制限されるのである。

不変条件の使用についての一般的構成は次の通り:

\begin{lstlisting}
  Id = Type
  inv pat == expr
\end{lstlisting}

\noindent 
 ここで {\tt pat}は{\tt Id}型に属する値にマッチングさせるパターンであり、{\tt expr}はtrueとなる式であり、パターン{\tt pat}から識別子のいくつかまたはすべてを含んでいる。

ある不変条件が定義された場合、1つの新しい (全) 関数がシグネチャと共に暗黙に生成される:
\begin{lstlisting}
  inv_Id : Type +> bool
\end{lstlisting}

この関数は、他の不変条件、関数、あるいは操作の定義中で用いることも可能である。

たとえば、\pageref{scoredef}ページ上に定義されたレコード型\texttt{Score}を思い返してみよう。
不変条件を用いることで、得点数は勝つか引き分けたゲームの数と一致する、ということが保障できる:
\begin{lstlisting}
  Score :: team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}
この型に対して暗黙に作成される不変条件関数は次の通り:
\begin{lstlisting}
  inv_Score : Score +> bool
  inv_Score (sc) == 
    sc.points = 3 * sc.won + sc.drawn;
\end{lstlisting}

%%%

\begin{comment}
\chapter{Algorithm Definitions}
\label{algorithm}


In the VDM languages algorithms can be defined by both
functions and operations.  However, they do not directly correspond to
functions in traditional programming languages. What separates
functions from operations in the VDM languages is the use of
local and global variables. Operations can manipulate both the global
variables and any local variables.  Both
local and global variables will be described later. Functions are pure in
the sense that they cannot access global variables and they are not
allowed to define local variables. Thus, functions are purely
applicative while operations are imperative.

Functions and operations can be defined both explicitly (by means of
an explicit algorithm definition) or implicitly (by means of a
pre-condition and/or a post condition).  An explicit algorithm
definition for a function is called an expression while for an
operation it is called a statement.  A pre-condition is a truth-valued
expression which specifies what must hold before the
function/operation is evaluated. A pre-condition can only refer to
parameter values and global variables (if it is an operation).  A
post-condition is also a truth valued expression which specifies what
must hold after the function/operation is evaluated. A post-condition
can refer to the result identifier, the parameter values, the current
values of global variables and the old values of global variables. The
old values of global variables are the values of the variables as they
were before the operation was evaluated.  Only operations can refer to
the old values of global variables in a post-condition as functions
are not allowed access to the global variables in any way.

However, in order to be able to execute both functions and operations
by the VDM interpreters they must be defined explicitly\footnote{Implicitly
specified functions and operations cannot in general be executed
because their post-condition does not need to directly relate the
output to the input. Often it is done by specifying the properties the
output must satisfy.}. In the VDM languages it is also
possible for explicit function and operation definitions to specify an
additional pre- and a post-condition.  In the post-condition of
explicit function and operation definitions the result value must be
referred to by the reserved word \keyw{RESULT}.
\end{comment}
%%%
\chapter{アルゴリズム定義}
\label{algorithm}

VDM言語では、アルゴリズムが関数と操作の両方により定義できる。 
しかしながら、伝統的なプログラム言語における関数にただちに相当するというものではない。
VDM言語において関数と操作を区別するものは、ローカルおよびグローバル変数の使用である。
操作は、グローバル変数といくらかのローカル変数の両方を扱うことができる。
ローカル変数とグローバル変数の両者については後に述べられる。
関数は、グローバル変数にアクセスすることはできないしローカル変数を定義することも許されていないという意味で、純粋なものである。
このように、操作が命令的なものである一方で、関数は純粋に作用的なものである。

関数と操作は、陽に(明確なアルゴリズム定義によって)あるいは陰に(事前条件または事後条件によって)、両方法で定義することができる。
関数に対する明示的なアルゴリズム定義を式と呼ぶ一方、操作に対するそれは文と呼ぶ。事前条件は、関数や操作が評価される前に何を保持していなくてはならないかを指定するtrueの値をとる式である。
事前条件は、パラメーター値と(操作の場合は)グローバル変数のみを参照することができる。
%事前条件のみは(それが操作である場合に)パラメーター値やグローバル変数を参照することができる。
事後条件もまた、関数や操作が評価された後に何が保持されなければならないかを指定するtrueの値をとる式である。
事後条件は、結果識別子、パラメーター値、グローバル変数の現在値、そしてグローバル変数の旧値、を参照することができる。
グローバル変数の旧値とは、操作が評価される前の変数の値のことである。
関数ではグローバル変数の変更は許されていないが、操作だけはグローバル変数の旧値を参照することができる。

しかしながら、インタープリタにより関数と操作の両方の実行を可能にするためには、それらは明示的に定義されていなければならない\footnote{暗黙に指定された関数と演算は一般的に実行できない、というのもそれらの事後条件は出力を入力に明白に関係づける必要がないからである。出力が満たさなくてはならないプロパティを指定することで、しばしば済む。}。
VDM言語では、陽関数および操作定義に対して追加の事前または事後条件を指定することもできる。
陽関数および操作定義の事後条件において、結果の値は予約語 \keyw{RESULT}によって参照されなければならない。

%%%

\begin{comment}
\chapter{Function Definitions}\label{functiondef}

In the VDM languages we can define first order and higher order
functions. A higher order function is either a Curried function (a
function that returns a function as result), or a function that takes
functions as arguments. Furthermore, both first order and higher order
functions can be polymorphic.

In VDM++ and VDM-RT functions are automatically available in a static
form (i.e.\ without having an instance of the defining class). Thus
there is no need to use the {\bf\ttfamily static} keyword that can be
used for operations in VDM++ and VDM-RT. Functions are executed
atomically - which is consistent with them being able to read instance
variables of objects passed, and there being no sync clauses (see
Chapter \ref{ch:sync}) for functions. In general, the syntax for the
definition of a function is:

\Rule{function definitions}{
  \Lop{functions},
  \OptPt{\Ruleref{access function definition}}, \lfeed
         \SeqPt{\Lit{;}},
         \Ruleref{access function definition}%
         \Ruleref{function definition},
         \OptPt{\Lit{;}}
  }

\Rule{access function definition}{
    \OptPt{\Ruleref{access}},
      \Ruleref{function definition}
  }

\Rule{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }

\Rule{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }

\Rule{explicit function definition}{
  \Ruleref{identifier},
\lfeed
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \Lit{$==$}, \lfeed
  \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }

\Rule{implicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},\lfeed
  \Ruleref{parameter types}, \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
}

\Rule{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types},\lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}

\Rule{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Rule{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Rule{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Rule{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Rule{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Rule{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Rule{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{(},\Lit{)}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern},\SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{function body}{
  \Ruleref{expression} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!functions}
  }

Here \keyw{is not yet specified} may be used as the function body
during development of a model; whereas the \keyw{is subclass
  responsibility} indicates that implementation of this body must be
undertaken by any subclasses so that can only be used in VDM++ and
VDM-RT.

A simple example of an explicit function definition is the function
\texttt{map\_inter} which takes two compatible maps over natural
numbers and returns those maplets common to both
\begin{lstlisting}
map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
map_inter (m1,m2) ==
  (dom m1 inter dom m2) <: m1
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d);
\end{lstlisting}
Note that we could also use the optional post condition to allow
assertions about the result of the function:
\begin{lstlisting}
map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
map_inter (m1,m2) ==
  (dom m1 inter dom m2) <: m1
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom RESULT = dom m1 inter dom m2;
\end{lstlisting}

The same function can also be defined implicitly:
\begin{lstlisting}
map_inter2 (m1,m2: map nat to nat) m: map nat to nat
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom m = dom m1 inter dom m2 and
     forall d in set dom m & m(d) = m1(d);
\end{lstlisting}
\noindent Note that implicitly functions are considered total. Thus if they are exported in VDM-SL they need to be exported using the total function type.
 
A simple example of an extended explicit function definition
is the function \texttt{map\_disj} which takes a pair of
compatible maps over natural numbers and returns the map consisting of
those maplets unique to one or other of the given maps:

\begin{lstlisting}
map_disj (m1:map nat to nat,m2:map nat to nat)
          res : map nat to nat ==
  (dom m1 inter dom m2) <-: m1 munion
  (dom m1 inter dom m2) <-: m2
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
post dom res = (dom m1 union dom m2) \ (dom m1 inter dom m2)
     and
     forall d in set dom res & res(d) = m1(d) or res(d) = m2(d);
\end{lstlisting}
\label{mapdisj}

(Note here that an attempt to interpret the post-condition could
potentially result in a run-time error since \texttt{m1(d)} and
\texttt{m2(d)} need not both be defined simultaneously.)

The functions {\tt map\_inter} and {\tt map\_disj} can be evaluated by the
VDM interpreters, but the implicit function {\tt map\_inter2} cannot be evaluated.
However, in all three cases the pre- and post-conditions can be used
in other functions; for instance from the definition of
\texttt{map\_inter2} we get functions \texttt{\keyw{pre\_}map\_inter2}
and \texttt{\keyw{post\_}map\_inter2} with the following signatures:

\begin{lstlisting}
  pre_map_inter2 : (map nat to nat) * (map nat to nat) +> bool
  post_map_inter2 : (map nat to nat) * (map nat to nat) *
                   (map nat to nat) +> bool
\end{lstlisting}
These kinds of functions are automatically created by the VDM
interpreters and they can be used in other definitions (this technique
is called quoting). In general, for a function \texttt{f} with
signature
\begin{lstlisting}
  f : T1 * ... * Tn -> Tr
\end{lstlisting}
defining a pre-condition for the function causes creation of a
function \texttt{\keyw{pre\_}f} with signature
\begin{lstlisting}
  pre_f : T1 * ... * Tn +> bool
\end{lstlisting}
and defining a post-condition for the function causes creation of a
function \texttt{\keyw{post\_}f} with signature
\begin{lstlisting}
  post_f : T1 * ... * Tn * Tr +> bool
\end{lstlisting}

Functions can also be defined using recursion (i.e.\ by calling
themselves). When this is done one is recommended to add
a \Lop{measure} function that can be used in the proof obligations
generated from the model such that termination proofs can be carried
out. The {\bf\ttfamily measure} function shall take the same type of
parameters as the recursive function itself and it yield a natural
number. A simple example here could be the traditional factorial function
defined as:
\begin{lstlisting}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id;
\end{lstlisting}
where \texttt{id} would be defined as:
\begin{lstlisting}
id: nat +> nat
id(n) == n;
\end{lstlisting}
Here the proof obligation will become:
\begin{lstlisting}
forall n:nat &
  (not (n = 0) =>
    id(n) > id(n - 1))
\end{lstlisting}
\noindent This proof obligation will ensure that the recursive
function will terminate and thus sooner or later reach the base case.

\section{Polymorphic Functions}

Functions can also be polymorphic in VDM. This means that we can create
generic functions that can be used on values of several different
types. For this purpose type parameters (or type variables which are
written like normal identifiers prefixed with a {\tt @} sign) are
used. Consider the polymorphic function to create an empty
bag:\footnote{The examples for polymorphic functions are taken from
\cite{Dawes91}. Bags are modelled as maps from the elements to their
multiplicity in the bag. The multiplicity is at least 1, i.e.\ a
non-element is not part of the map, rather than being mapped to 0.}
\begin{lstlisting}
empty_bag[@elem] : () +> (map @elem to nat1)
empty_bag() ==
  { |-> };
\end{lstlisting}
Before we can use the above function, we have to instantiate the
function {\tt empty\_bag} with a type, for example integers (see also
section~\ref{app-expr}):
\begin{lstlisting}
emptyInt = empty_bag[int]
\end{lstlisting}
Now we can use the function {\tt emptyInt} to create a new bag to store
integers. More examples of polymorphic functions are:
\begin{lstlisting}
num_bag[@elem] : @elem * (map @elem to nat1) +> nat
num_bag(e, m) ==
  if e in set dom m
  then m(e)
  else 0;

plus_bag[@elem] : @elem * (map @elem to nat1) +>
                  (map @elem to nat1)
plus_bag(e, m) ==
  m ++ { e |-> num_bag[@elem](e, m) + 1 };
\end{lstlisting}
If pre- and or post-conditions are defined for polymorphic functions, the
corresponding predicate functions are also polymorphic. For instance
if \texttt{num\_bag} was defined as
\begin{lstlisting}
  num_bag[@elem] : @elem * (map @elem to nat1) +> nat
  num_bag(e, m) ==
    m(e)
  pre e in set dom m;
\end{lstlisting}
then the pre-condition function would be
\begin{lstlisting}
  pre_num_bag[@elem] :@elem * (map @elem to nat1) +> bool
\end{lstlisting}

\noindent Finally, VDM makes no assumptions about the type bound to a type parameter. This binding must be made explicitly, either by making an assertion as part of the pre-condition of the function, or by making a test before the part of the function body that restricts the type parameter. For example, consider the function given below:

\begin{lstlisting}
public f[@T]: seq of @T -> seq of @T
f(s) ==
  if is_(s, seq of real) then
  	[r + 1 | r in seq s]
  else
  	reverse s;
\end{lstlisting}

Here the type parameter \texttt{@T} denotes the element type of the sequence \texttt{s} passed to the function. Note how the body of the function assumes the type parameter to be defined for the \texttt{+} operator. This only works since the \texttt{\textbf{if}}-clause explicitly states that the parameter \texttt{s} is of type \texttt{\textbf{seq of real}}. Without the \texttt{\textbf{if}}-clause use of the \texttt{+} operator would fail due to \texttt{@T} not being of a numeric type. Alternatively, the assumption could be stated using a pre-condition e.g.\ using {\texttt{\keyw{is\_real}}. This puts a restriction on the type parameter that applies to the entire body of the function, though with simple examples like this the effect is the same as explicitly declaring the type of the parameter in the function signature.

Polymorphic functions can also be recursive and in those cases it also makes sense to include a measure function. For example:

\begin{lstlisting}
dlen[@A]: seq of seq of @A -> nat
dlen(l) ==
  if l = []
  then 0
  else len hd l + dlen[@A](tl l)
measure Len;

Len[@A]: seq of seq of @A -> nat
Len(l) == len l;
\end{lstlisting}
\noindent where a proof obligation ensuring termination of this recursive function as:

\begin{lstlisting}
(forall l:seq of (seq of (@A)) & ((not (l = [])) => 
(Len[@A](l) > Len[@A](tl l))))
\end{lstlisting}

\section{Higher Order Functions}

Functions are allowed to receive other functions as arguments. A
simple example of this is the function \texttt{nat\_filter} which
takes a sequence of natural numbers, and a predicate, and returns the
subsequence that satisfies this predicate:
\begin{lstlisting}
  nat_filter : (nat -> bool) * seq of nat -> seq of nat
  nat_filter (p,ns) ==
    [n | n in seq ns & p(n)];
\end{lstlisting}
Then
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
In fact, this algorithm is not specific to natural numbers, so we may
define a polymorphic version of this function:
\begin{lstlisting}
  filter[@elem]: (@elem -> bool) * seq of @elem -> seq of @elem
  filter (p,l) ==
    [i | i in seq l & p(i)];
\end{lstlisting}
\label{filterdef}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.

\vspace{1ex}
Functions may also return functions as results. An example of this is
the function \texttt{fmap}:
\begin{lstlisting}
  fmap[@elem]: (@elem -> @elem) -> seq of @elem -> seq of @elem
  fmap (f)(l) ==
    if l = []
    then []
    else [f(hd l)] ^ (fmap[@elem] (f)(tl l));
\end{lstlisting}
So \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$
\texttt{[ 1,4,9,16,25 ]}.

\vspace{1ex}
\noindent Since the \texttt{fmap} function is recursive, it ought to have a \keyw{measure}
function defined. In the case of curried functions, the measure function's parameters
are the same as a de-curried version of the recursive function's parameters. For
the \texttt{fmap} example, this would be:
\begin{lstlisting}
  m[@elem]: (@elem -> @elem) * seq of @elem -> nat
  m(-, l) == len l;
\end{lstlisting}
Note that the measure function is also polymorphic, and must have the same type
parameters as the function it measures. The proof obligation will also be polymorphic:
\begin{lstlisting}
(forall f:(@elem -> @elem), l:seq of (@elem) &
  (not (l = []) =>
    m[@elem](f, l) > m[@elem](f, (tl l))))
\end{lstlisting}
\end{comment}

%%% 関数定義

\chapter{関数定義}
\label{functiondef}

VDM言語では、1階関数と高階関数を定義することができる。 
高階関数とは、カリー化関数(結果として関数を返す関数)、もしくは関数を引数にとる関数である。
さらには、1階のものも高階のものもいずれも多相であることが可能である。

VDM++ と VDM-RT では、関数は自動的に static として提供される（すなわち対象の
クラスのインスタンスを作る必要はない）。よって VDM++ と VDM-RT の中の
操作で利用するために {\bf\ttfamily static} キーワードを使う必要はない。
関数はアトミックに実行され、渡されたオブジェクトのインスタンス変数は
矛盾なく読み出される。そして関数には sync 句も存在しない（Chapter \ref{ch:sync}）
を参照のこと。
関数を定義するための一般的な構文は以下の通り:

%%%%
\Rule{関数定義}{
  \Lop{functions},
  \OptPt{\Ruleref{アクセス関数定義}}, \lfeed
         \SeqPt{\Lit{;}},
         \Ruleref{アクセス関数定義}%
         \Ruleref{関数定義},
         \OptPt{\Lit{;}}
  }

\Rule{アクセス関数定義}{
    \OptPt{\Ruleref{アクセス}},
      \Ruleref{関数定義}
  }

\Rule{アクセス}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }

%%%%
\Rule{関数定義}{
  \Ruleref{陽関数定義} \dsep
  \Ruleref{陰関数定義} \dsep
  \Ruleref{拡張陽関数定義}
  }

\Rule{陽関数定義}{
  \Ruleref{識別子}, 
\lfeed
  \OptPt{\Ruleref{型変数リスト}}, 
  \Lit{:}, \Ruleref{関数型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーターリスト}, \Lit{$==$}, \lfeed
  \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed

  \OptPt{\Lop{measure}, \Ruleref{名称}}
  }                                 

\Rule{陰関数定義}{
  \Ruleref{識別子}, 
  \OptPt{\Ruleref{型変数リスト}},\lfeed
  \Ruleref{パラメーター型}, \Ruleref{識別子型ペアリスト}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}
}

\Rule{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型},\lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}

\Rule{型変数リスト}{
  \Lit{[}, \Ruleref{型変数識別子}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{型変数識別子}}, \Lit{]}
  }

\Rule{識別子型ペアリスト}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{識別子}, \Lit{:}, \Ruleref{型}}
}

\Rule{パラメーター型}{
  \Lit{(}, \OptPt{\Ruleref{パターン型ペアリスト}}, \Lit{)}
  }

\Rule{パターン型ペアリスト}{
  \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{パターンリスト},\Lit{:}, \Ruleref{型}}
  }

\Rule{関数型}{
  \Ruleref{部分関数型} \dsep
  \Ruleref{全関数型}
  }

\Rule{部分関数型}{
  \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}
  }

\Rule{全関数型}{
  \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{(},\Lit{)}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン},\SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{関数本体}{
  \Ruleref{式} \dsep 
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!functions}
  }

モデルの開発途中では、\keyw{is not yet specified} （=「まだ定義されていない」という意味）を関数本体として用いることが許されている。

一方 \keyw{is subclass responsibility} （=「サブクラスの責任である」という意味）
はこの本体の実装が、このクラスのサブクラスの中で行われなければならいことを示している。
よってこの指定は VDM++ と VDM-RT のみで許されている。

陽関数定義の簡単な例は関数\texttt{map\_inter}であり、これは自然数上の2つの両立する写像をもってきて、両者に共通する写を返すものである
\begin{lstlisting}
  map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
  map_inter (m1,m2) ==
    (dom m1 inter dom m2) <: m1
  pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
\end{lstlisting}
関数結果についての主張を許すために選択事後条件をさらにまた用いることができることにも注意しよう:
\begin{lstlisting}
  map_inter: (map nat to nat) * (map nat to nat) -> map nat to nat
  map_inter (m1,m2) ==
    (dom m1 inter dom m2) <: m1
  pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
  post dom RESULT = dom m1 inter dom m2
\end{lstlisting}

同じ関数が暗黙的にまた定義されることも可能である:
\begin{lstlisting}
  map_inter2 (m1,m2: map nat to nat) m: map nat to nat
  pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
  post dom m = dom m1 inter dom m2 and
       forall d in set dom m & m(d) = m1(d);
\end{lstlisting}

拡張陽関数定義(標準ではない)の簡単な例は関数 \texttt{map\_disj} で、これは自然数上で2つの両立する写像を持ってきて、それらのどちらかの写像に対して唯一の写からなる写像を返す:

\begin{lstlisting}
  map_disj (m1:map nat to nat,m2:map nat to nat) res : map nat to nat ==
    (dom m1 inter dom m2) <-: m1 munion
    (dom m1 inter dom m2) <-: m2
  pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
  post dom res = (dom m1 union dom m2) \verb+\+ (dom m1 inter dom m2) 
       and
       forall d in set dom res & res(d) = m1(d) or res(d) = m2(d)
\end{lstlisting}
\label{mapdisj}
(ここにおいて事後条件をインタープリタに通す試みは、もしかすると実行時エラーを引き起こすかもしれない、というのは \texttt{m1(d)} と\texttt{m2(d)}は同時に両者が定義される必要はないからなのである。)

関数 {\tt map\_inter} と {\tt map\_disj} はインタプリターにより評価することが可能であるが、暗黙的関数である {\tt map\_inter2} は評価することができない。
しかしながら、これら3つの場合における事前条件と事後条件は他の関数のなかで使用することが可能である; たとえば\texttt{map\_inter2}の定義から、関数 \texttt{\keyw{pre\_}map\_inter2}と \texttt{\keyw{post\_}map\_inter2}を以下のシグネチャで得る:

\begin{lstlisting}
  pre_map_inter2 : (map nat to nat) * (map nat to nat) +> bool
  post_map_inter2 : (map nat to nat) * (map nat to nat) *
                   (map nat to nat) +> bool
\end{lstlisting}
これらの種類の関数は自動的にインタープリタで作成され、他の定義においても用いることができる(この技術は引用とよばれる)。
一般的に、次のシグネチャをもつ関数 \texttt{f} に対して
\begin{lstlisting}
  f : T1 * ... * Tn -> Tr
\end{lstlisting}
関数に対する事前条件を定義することで、次のシグネチャの関数 \texttt{\keyw{pre\_}f}が生成される。
\begin{lstlisting}
  pre_f : T1 * ... * Tn +> bool
\end{lstlisting}
そして関数に対する事後条件を定義することで、次のシグネチャの関数 \texttt{\keyw{post\_}f} が生成される。
\begin{lstlisting}
  post_f : T1 * ... * Tn * Tr +> bool
\end{lstlisting}

関数は再帰 (自分自身の呼び出し) を使って定義することもできる。
再帰呼び出しを使う場合、\Lop{measure} 関数を追加することが推奨される。
これによって、実行が終了すること保証する証明課題を生成することができるようになる。
シンプルな階乗関数の例を以下に定義する:

\begin{lstlisting}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id
\end{lstlisting}
ここで、 \texttt{id}は以下のように定義されている:
\begin{lstlisting}
id: nat +> nat
id(n) == n
\end{lstlisting}

\section{多相関数}

関数はまた多相であることが可能である。
これは、複数の異なる型の値のもとに使用可能な包括的な関数を生成することができるということを意味する。
この目的のために、型引数 (または接頭辞{\tt @}記号をおき通常の識別子と同様に記述された型変数) が用いられる。
空のバッグをつくりだすための多相関数を考える:
\footnote{多相関数の例は\cite{Dawes91}から引用する。
バッグというのは、バッグの中での要素からその要素の重複度への写像をモデル化したものである。 
ここでの重複度は少なくも1以上であり、つまり要素がないならこの写像の役目は負えないので、0に写像されるものではない。}
\begin{lstlisting}
  empty_bag[@elem] : () +> (map @elem to nat1)
  empty_bag() ==
    \{ |-> \}
\end{lstlisting}
上記の関数が使用できる以前のこととして、関数 {\tt empty\_bag}の、たとえば整数といったある型のインスタンス生成を行わなくてはならない:
\begin{lstlisting}
  emptyInt = empty_bag[int]
\end{lstlisting}
さぁこれで整数をいれるための新しいバッグをつくるために、関数 {\tt emptyInt} を使用することができる。
更なる多相関数の例としては:
\begin{lstlisting}
  num_bag[@elem] : @elem * (map @elem to nat1) +> nat
  num_bag(e, m) ==
    if e in set dom m
    then m(e)
    else 0;

  plus_bag[@elem] : @elem * (map @elem to nat1) +> (map @elem to nat1)
  plus_bag(e, m) ==
    m ++ \{ e |-> num_bag[@elem](e, m) + 1 \}
\end{lstlisting} 
もし事前条件や事後条件が多相関数に対して定義された場合は、対応する述語関数もまた多相である。
たとえばもし \texttt{num\_bag}が下記のように定義されていたとすると
\begin{lstlisting}
  num_bag[@elem] : @elem * (map @elem to nat1) +> nat
  num_bag(e, m) ==
    m(e)
  pre e in set dom m
\end{lstlisting}
事前条件は次のようになるであろう
\begin{lstlisting}
  pre_num_bag[@elem] :@elem * (map @elem to nat1) +> bool
\end{lstlisting}


また、\keyw{measure}は機能が多相的に定義された時も使用されるべきである。
ただし、現在は \keyw{measure} を高階関数では使うことができない。

\section{高階関数}

関数は他の関数を引数として受け取ることが許される。
この簡単な例は、自然数の列となる関数\texttt{nat\_filter} であり、1つの述語をもち、この述語を満足させる部分列を返すものである:
\begin{lstlisting}
  nat_filter : (nat -> bool) * seq of nat -> seq of nat
  nat_filter (p,ns) ==
    [ns(i) | i in set inds ns & p(ns(i))];
\end{lstlisting}
このとき 
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
実際、このアルゴリズムは自然数に限ったものではない、したがってこの関数の多相版を定義してもよいであろう:
\begin{lstlisting}
  filter[@elem]: (@elem -> bool) * seq of @elem -> seq of @elem
  filter (p,l) ==
    [l(i) | i in set inds l & p(l(i))];
\end{lstlisting}
\label{filterdef}
よって \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.

関数はまた結果として関数を返してもよい。
これの例は関数 \texttt{fmap}である:
\begin{lstlisting}
  fmap[@elem]: (@elem -> @elem) -> seq of @elem -> seq of @elem
  fmap (f)(l) ==
    if l = []
    then []
    else [f(hd l)]\verb+^+(fmap[@elem] (f)(tl l));
\end{lstlisting}
よって 
 \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$ 
\texttt{[ 1,4,9,16,25 ]}

%%%

\begin{comment}
\chapter{Expressions}\label{chap:expr}

In this chapter we will describe the different kinds of expressions
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\section{Let Expressions}\label{let-exp}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \Ruleref{let expression} \dsep
    \Ruleref{let be expression} \dsep
    \ldots
    }

  \Rule{let expression}{
    \Lop{let},
    \Ruleref{local definition}
    \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{expression}
    }

  \Rule{let be expression}{
    \Lop{let}, \Ruleref{multiple bind},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
    \Ruleref{expression}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep
    \Ruleref{function definition}
    }

  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  \noindent where the ``function definition'' component is described in
  section~\ref{functiondef}.

\item[Semantics:] A simple {\it let expression} has the form:
  \begin{lstlisting}
    let p1 = e1, ..., pn = en in e
  \end{lstlisting}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding pattern {\tt pi}, and
  {\tt e} is an expression, of any type, involving the pattern
  identifiers of {\tt p1, \ldots, pn}. It denotes the value of the
  expression {\tt e} in the context in which the patterns {\tt p1,
    \ldots, pn} are matched against the corresponding expressions {\tt
    e1, \ldots, en}.

  More advanced let expressions can also be made by using local
  function definitions. The semantics of doing so is simply that the
  scope of such locally defined functions is restricted to the body of
  the let expression.

  In standard VDM-SL\ the collection of definitions may be mutually
  recursive.  However, in the VDM languages this is not
  supported by the VDM interpreters.  Furthermore, the definitions must be
  ordered such that all constructs are defined before they are used.

  A {\it let-be-such-that expression} has the form:
  \begin{lstlisting}
    let mb be st e1 in e2
  \end{lstlisting}%
  where {\tt mb} is a multi-binding of one or more patterns (mostly
  just one pattern)
 to a set value (or a sequence or a type),
  {\tt e1} is a boolean expression, and {\tt e2} is an expression, of
  any type, involving the pattern identifiers of the patterns from {\tt
    mb}. The {\tt \keyw{be st} e1} part is optional. The expression
  denotes the value of the expression {\tt e2} in the context in which
  all the patterns from {\tt mb} have been matched against either an element
  in the set from {\tt mb}, or an element in the sequence from {\tt mb}, or against a value from the type in {\tt mb}%
  \footnote{Remember that only the set and sequence bindings can be executed by
    means of the VDM interpreters.}.
  If the {\tt \keyw{st} e1} expression is present, only such bindings
  where {\tt e1} evaluates to true in the matching context are used.

\item[Examples:] {\it Let expressions} are useful for improving
  readability especially by contracting complicated expressions used
  more than once. For instance, we can improve the function
  \texttt{map\_disj} from page \pageref{mapdisj}:
\begin{lstlisting}
map_disj : (map nat to nat) * (map nat to nat) ->
            map nat to nat
map_disj (m1,m2) ==
  let inter_dom = dom m1 inter dom m2
  in
    inter_dom <-: m1 munion inter_dom <-: m2
pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d);
\end{lstlisting}
  They are also convenient for decomposing complex
  structures into their components. For instance, using the previously
  defined record type \texttt{Score} (see page \pageref{scoredef}) we can
  test whether one score is greater than another:
  \begin{lstlisting}
    let mk_Score(-,w1,-,-,p1) = sc1,
        mk_Score(-,w2,-,-,p2) = sc2
    in (p1 > p2) or (p1 = p2 and w1 > w2)
  \end{lstlisting}
  In this
  particular example we extract the second and fifth components of the
  two scores. Note that don't care
  patterns (see page \pageref{patterns}) are used to indicate that the
  remaining components are irrelevant
  for the processing done in the body of this expression.

  {\it Let-be-such-that expressions} are useful for abstracting away
  the non-essential choice of an element from a set, in particular in
  formulating recursive definitions over sets. An example of this is a
  version of the sequence filter function (see page \pageref{filterdef})
  over sets:\label{setfilterdef}
  \begin{lstlisting}
set_filter[@elem] : (@elem -> bool) -> (set of @elem) ->
                    (set of @elem)
set_filter(p)(s) ==
  if s = {}
  then {}
  else let x in set s
       in (if p(x) then {x} else {}) union
         set_filter[@elem](p)(s \ {x});
   \end{lstlisting}
   We could alternatively have defined this function using a set
  comprehension (described in section \ref{setexpr}):
  \begin{lstlisting}
    set_filter[@elem] : (@elem -> bool) -> (set of @elem) ->
                        (set of @elem)
    set_filter(p)(s) ==
      { x | x in set s & p(x)};
  \end{lstlisting}

   The last example shows how the optional ``be such that'' part
   (\keyw{be st}) can be used. This part is especially useful when it
   is known that an element with some property exists but an explicit
   expression for such an element is not known or difficult to
  write. For instance we can exploit this expression to write a
  selection sort algorithm:
   \begin{lstlisting}
   remove : nat * seq of nat -> seq of nat
   remove (x,l) ==
     let i in set inds l be st l(i) = x
     in
       l(1,...,i-1) ^ l(i+1,...,len l)
   pre x in set elems l;

   selection_sort : seq of nat -> seq of nat
   selection_sort (l) ==
     if l = []
     then []
     else let m in seq l be st
              forall x in seq l & m <= x
          in
            [m] ^ (selection_sort (remove(m,l)));
   \end{lstlisting}
\label{selectionSortdef}
   Here the first function removes a given element from the given
   list; the second function repeatedly removes the least element in
   the unsorted portion of the list, and places it at the head of the
   sorted portion of the list.
\end{description}

\section{The Define Expression} \label{define-exp}

This expression can only be used inside operations which will be
described in section~\ref{op-def}. In order to deal with global variables
inside the expression part an extra expression construct is available
inside operations.

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{def expression} \dsep
    \ldots
    }

\Rule{def expression}{
  \Lop{def},
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\item[Semantics:] A {\it define expression} has the form:
  \begin{lstlisting}
    def pb1 = e1;
        ...
        pbn = en
    in
      e
  \end{lstlisting}
  The {\it define expression} corresponds to a let expression except
  that the right hand side expressions may depend on the value of the
  local and/or
  global variable and that it may not be mutually recursive.
  It denotes the value of the expression {\tt e} in the
  context in which the patterns (or binds) {\tt pb1, \ldots, pbn} are
  matched against the corresponding expressions {\tt e1, \ldots,
    en}\footnote{If binds are used, it simply means that the values
    which can match the pattern are further constrained by the type, sequence, or
    set expression as explained in Chapter~\ref{patterns}.}.

\item[Examples:] The {\it define expression} is
  used in a pragmatic way, in order to make the reader aware of the fact that
  the value of the expression depends upon the global variable.

  This can be illustrated by a small example:
  \begin{lstlisting}
    def user = lib(copy)
    in
      if user = <OUT>
      then true
      else false
  \end{lstlisting}
  where {\tt copy} is defined in the context, {\tt lib} is global
  variable (thus {\tt lib(copy)} can be considered as looking up the
  contents of a part of the variable).

  The operation \texttt{GroupRunnerUp\_expl} in section \ref{letstmt}
  also gives an example of a define expression.
\end{description}

\section{Unary and Binary Expressions}\label{unandbin}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{unary expression} \dsep \Ruleref{binary expression} \dsep \ldots
    }

\Rule{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Rule{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

  \Rule{unary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsepl \Lop{reverse} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge}
    }

\Rule{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

  \Rule{binary expression}{
    \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}}

  \Rule{binary operator}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[Semantics:] Unary and binary expressions are a combination of
  operands and operators denoting a value of a specific type. The
  signature of all these operators is already given in
  Chapter~\ref{typedef}, so no further explanation will be provided
  here. The map inverse unary operator is treated separately because
  it is written with postfix notation in the mathematical syntax.

\item[Examples:] Examples using these operators were given in
  Chapter~\ref{typedef}, so none will be provided here.
\end{description}

\section{Conditional Expressions}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{if expression} \dsep \Ruleref{cases expression} \dsep \ldots
    }

  \Rule{if expression}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
    \SeqPt{\Ruleref{elseif expression}}, \Lop{else}, \Ruleref{expression}
    }

  \Rule{elseif expression}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
    }

  \Rule{cases expression}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases expression alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
    }

  \Rule{cases expression alternatives}{
    \Ruleref{cases expression alternative},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
    }

  \Rule{cases expression alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
    }

  \Rule{others expression}{
    \Lop{others}, \Lit{->}, \Ruleref{expression}
    }

\item[Semantics:] {\it If expressions} and {\it cases expressions}
  allow the choice of one from a number of expressions on the basis of
  the value of a particular expression.

  The {\it if expression} has the form:
  \begin{lstlisting}
    if e1
    then e2
    else e3
  \end{lstlisting}
  where {\tt e1} is a boolean expression, while {\tt e2} and {\tt e3}
  are expressions of any type. The if expression denotes the value of
  {\tt e2} evaluated in the given context if {\tt e1} evaluates to
  true in the given context. Otherwise the if expression denotes the
  value of {\tt e3} evaluated in the given context. The use of an
  \keyw{elseif} expression is simply a shorthand for a nested if then
  else expression in the \keyw{else} part of the expression.

  The {\it cases expression} has the form
  \begin{lstlisting}
    cases e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      others             -> emplus1
    end
  \end{lstlisting}
  where {\tt e} is an expression of any type, all {\tt pij}'s are patterns
  which are matched one by one against the expression {\tt e}.  The {\tt
    ei}'s are expressions of any type, and the keyword \keyw{others} and
  the corresponding expression {\tt emplus1} are optional. The cases
  expression denotes the value of the {\tt ei} expression evaluated in the
  context in which one of the {\tt pij} patterns has been matched against
  {\tt e}. The chosen {\tt ei} is the first entry where it has been
  possible to match the expression {\tt e} against one of the patterns. If
  none of the patterns match {\tt e} an \keyw{others} clause must be
  present, and then the cases expression denotes the value of {\tt emplus1}
  evaluated in the given context.

\item[Examples:] The if expression in the VDM languages
  corresponds to what is used in most programming languages, while the
  cases expression in the VDM languages is more general than
  most programming languages. This is shown by the fact that real
  pattern matching is taking place, but also because the patterns do not
  have to be constants as in most programming languages.

  An example of the use of conditional expressions is provided by the
  specification of the mergesort algorithm:
  \begin{lstlisting}
  lmerge : seq of nat * seq of nat -> seq of nat
  lmerge (s1,s2) ==
    if s1 = []
    then s2
    elseif s2 = []
    then s1
    elseif (hd s1) < (hd s2)
    then [hd s1] ^ (lmerge (tl s1, s2))
    else [hd s2] ^ (lmerge (s1, tl s2));

  mergesort : seq of nat -> seq of nat
  mergesort (l) ==
    cases l:
      []      -> [],
      [x]     -> [x],
      l1 ^ l2 -> lmerge (mergesort(l1), mergesort(l2))
    end;
  \end{lstlisting}
The pattern matching provided by cases expressions is useful for
  manipulating members of type unions. For instance, using the type
  definition \texttt{Expr} from page \pageref{exprdef} we have:
  \begin{lstlisting}
print_Expr : Expr -> seq1 of char
print_Expr (e) ==
  cases e:
    mk_Const(-) -> "Const of" ^ (print_Const(e)),
    mk_Var(id,-) -> "Var of" ^ id,
    mk_Infix(mk_(e1,op,e2)) -> "Infix of" ^ print_Expr(e1)^","
                                    ^ print_Op(op) ^ ","
                                    ^ print_Expr(e2),
    mk_Cond(t,c,a) -> "Cond of" ^ print_Expr(t) ^ ","
                               ^ print_Expr(c) ^ ","
                               ^ print_Expr(a)
  end;

print_Const : Const -> seq1 of char
print_Const(mk_Const(c)) ==
  if is_nat(c)
  then "nat"
  else -- must be bool
       "bool";
  \end{lstlisting}
\label{printExprDef}
  The function \texttt{print\_Op} would be defined similarly.
\end{description}

\section{Quantified Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{quantified expression}
    \dsep \ldots
    }

  \Rule{quantified expression}{
    \Ruleref{all expression} \dsep
    \Ruleref{exists expression} \dsep
    \Ruleref{exists unique expression}
    }

  \Rule{all expression}{
    \Lop{forall}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{exists expression}{
      \Lop{exists}, \Ruleref{bind list}, \Lit{\char'046}, \Ruleref{expression}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{exists unique expression}{
    \Lop{exists1}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] There are three forms of quantified expressions:
  {\it universal} (written as \keyw{forall}), {\it existential} (written
  as \keyw{exists}), and {\it unique existential} (written as
  \keyw{exists1}). Each yields a boolean value \keyw{true} or \keyw{false}, as
  explained in the following.

  The {\it universal quantification} has the form:
  \begin{lstlisting}
    forall mbd1, mbd2, !\ldots!, mbdn & e
  \end{lstlisting}
  where each {\tt mbdi} is a multiple bind {\tt pi \keyw{in set} s}, { \tt pi \keyw{in seq} s}, or
  if it is a type bind {\tt pi : type}, and {\tt e} is a boolean
  expression involving the pattern identifiers of the {\tt mbdi}'s. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of every choice of bindings from {\tt mbd1, mbd2, \ldots,
    mbdn} and \keyw{false} otherwise.

  The {\it existential quantification} has the form:
  \begin{lstlisting}
    exists mbd1, mbd2, !\ldots!, mbdn & e
  \end{lstlisting}
  where the {\tt mbdi}'s and the {\tt e} are as for a universal
  quantification. It has the value \keyw{true} if {\tt e} is \keyw{true} when
  evaluated in the context of at least one choice of bindings from
  {\tt mbd1, mbd2, \ldots, mbdn}, and \keyw{false} otherwise.

  The {\it unique existential quantification} has the form:
  \begin{lstlisting}
    exists1 bd & e
  \end{lstlisting}
  where {\tt bd} is either a set bind, a sequence bind, or a type bind and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}. It
  has the value \keyw{true} if {\tt e} is \keyw{true} when evaluated in the
  context of exactly one choice of bindings, and \keyw{false} otherwise.

  All quantified expressions have the lowest possible precedence. This
  means that the longest possible constituent expression is taken. The
  expression is continued to the right as far as it is syntactically
  possible.


\item[Examples:]
  An example of an existential quantification is given in the function
  shown below, \texttt{QualificationOk}. This function, taken from the
  specification of a nuclear tracking system in \cite{Fitzgerald&98},
  checks whether a set of experts has a required qualification.
  \begin{lstlisting}
  types

  ExpertId = token;
  Expert :: expertid : ExpertId
            quali : set of Qualification
  inv ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: set of Expert * Qualification -> bool
  QualificationOK(exs,reqquali) ==
    exists ex in set exs & reqquali in set ex.quali;
  \end{lstlisting}
  The function \texttt{min} gives us an example of a universal
  quantification:
  \begin{lstlisting}
  min(s: set of nat) x: nat
  pre s <> {}
  post forall y in set s & x <= y;
  \end{lstlisting}
  We can use unique existential quantification to state the functional
  property satisfied by all maps \texttt{m}:
  \begin{lstlisting}
  forall d in set dom m &
    exists1 r in set rng m & m(d) = r
  \end{lstlisting}


\end{description}

\section{The Iota Expression}\label{iotaexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{iota expression} \dsep
    \ldots
    }

  \Rule{iota expression}{
    \Lop{iota}, \Ruleref{bind}, \Lit{\char'046}, \Ruleref{expression}
    }

\item[Semantics:] An {\it iota expression} has the form:
  \begin{lstlisting}
    iota bd & e
  \end{lstlisting}
  where {\tt bd} is either a set bind, a sequence bind, or a type bind, and {\tt e} is a
  boolean expression involving the pattern identifiers of {\tt bd}.
  The \keyw{iota} operator can only be used if a unique value exists
  which matches the bind and makes the body expression {\tt e} yield
  \keyw{true} (i.e.\ {\tt \keyw{exists1} bd \& e} must be \keyw{true}). The
  semantics of the iota expression is such that it returns the unique
  value which satisfies the body expression ({\tt e}).

\item[Examples:]
  Using the values \texttt{sc1,...,sc4} defined by
  \begin{lstlisting}
    sc1 = mk_Score (<France>, 3, 0, 0, 9);
    sc2 = mk_Score (<Denmark>, 1, 1, 1, 4);
    sc3 = mk_Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = mk_Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{lstlisting}
  we have

  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \&
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \&
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent Notice that the last example cannot be executed and that
  the last two expressions are undefined - in the former case because
  there is more than value satisfying the expression, and in the
  latter because no value satisfies the expression.
\end{description}

\section{Set Expressions}\label{setexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{set enumeration} \dsep \Ruleref{set comprehension} \dsep
    \Ruleref{set range expression} \dsep \ldots
    }

  \Rule{set enumeration}{
    \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
    }

  \Rule{expression list}{
    \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
    }

  \Rule{set comprehension}{
    \Lit{\{}, \Ruleref{expression}, \Lit{$|$}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

  \Rule{set range expression}{
    \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{expression}, \Lit{\}}
    }

\item[Semantics:] A {\it Set enumeration} has the form:
  \begin{lstlisting}
    {e1, e2, e3, !\ldots!, en}
  \end{lstlisting}
  where {\tt e1} up to {\tt en} are general expressions. It constructs
  a set of the values of the enumerated expressions. The empty set
  is written as \verb+{}+.

  The {\it set comprehension} expression has the form:
  \begin{lstlisting}
    {e | mbd1, mbd2, !\ldots!, mbdn & P}
  \end{lstlisting}
  It constructs a set by evaluating the expression {\tt e} on all the
  bindings for which the predicate {\tt P} evaluates to \keyw{true}. A
  multiple binding can contain set bindings, sequence bindings, and type bindings.
  Thus {\tt mbdn} will look like {\tt pat1 \keyw{in set} s1, pat2 : tp1, pat3 \keyw{in seq} q1,
    \ldots \keyw{in set} s2}, where {\tt pati} is a pattern (normally
  simply an identifier), {\tt s1} and {\tt s2} are sets
  constructed by expressions, and {\tt q1} is a sequence constructed by an expression (whereas {\tt tp1} is used to illustrate
  that type binds can also be used). Notice however that type binds
  can only be executed by the VDM interpreters in case the types can
  be statically declared as finite.

  The {\it set range expression} is a special case of a set
  comprehension. It has the form
  \begin{lstlisting}
    {e1, !\ldots!, e2}
  \end{lstlisting}
  where {\tt e1} and {\tt e2} are numeric expressions. The set range
  expression denotes the set of integers from {\tt e1} to {\tt e2}
  inclusive. If {\tt e2} is smaller than {\tt e1} the set range
  expression denotes the empty set.

\item[Examples:]
  Using  the values \texttt{Europe=\{<France>,<England>,<Denmark>,%
  <Spain>\}} and \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (where
  \texttt{sc1,...,sc4} are as defined in the preceding example) we have

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{8cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{8cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\section{Sequence Expressions} \label{seqexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{sequence enumeration} \dsep \Ruleref{sequence comprehension} \dsep
    \Ruleref{subsequence} \dsep \ldots
    }

  \Rule{sequence enumeration}{
    \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
    }

  \Rule{sequence comprehension}{
    \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{]}
    }

  \Rule{subsequence}{
    \Ruleref{expression}, \lfeed
    \Lit{(}, \Ruleref{expression},
    \Lit{,}, \Lit{\Range},
    \Lit{,},
    \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] A {\it sequence enumeration} has the form:
  \begin{lstlisting}
    [e1, e2, !\ldots!, en]
  \end{lstlisting}
  where {\tt e1} through {\tt en} are general expressions. It constructs a
  sequence of the enumerated elements. The empty sequence is written
  as {\tt []}.

  A {\it sequence comprehension} over sequences has the form:
  \begin{lstlisting}
    [e | pat in seq S & P]
  \end{lstlisting}
  where the expression \texttt{e} will use the identifiers from the
  pattern \texttt{pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one
  pattern identifier must be present in the pattern). \texttt{S} is a
  sequence of values. It constructs a sequence by evaluating the
  expression \texttt{e} on all the bindings for which the predicate
  \texttt{P} evaluates to true, preserving the order of elements in
  \texttt{S}.

  A {\it sequence comprehension} over sets has the form:
  \begin{lstlisting}
    [e | pat in set S & P]
  \end{lstlisting}
  where the expression {\tt e} will use the identifiers from the
  pattern {\tt pat} (normally this pattern will simply be an
  identifier, but the only real requirement is that exactly one pattern
  identifier must be present in the pattern). {\tt S} is
  a set of values (normally natural numbers). The bindings of the
  pattern identifier must be to some kind of numeric values which then
  are used to indicate the ordering of the elements in
  the resulting sequence. It constructs a sequence by evaluating the
  expression {\tt e} on all the bindings for which the predicate {\tt P}
  evaluates to \keyw{true}.

  A {\it subsequence} of a sequence {\tt l} is a sequence formed from
  consecutive elements of {\tt l}; from index {\tt n1} up to and including
  index {\tt n2}. It has the form:
  \begin{lstlisting}
    l(n1, ..., n2)
  \end{lstlisting}
  where {\tt n1} and {\tt n2} are positive integer expressions.
  If the lower bound {\tt n1} is smaller than
  1 (the first index in a non-empty sequence) the subsequence
  expression will start from the first element of the sequence.
  If the upper bound {\tt n2} is larger
  than the length of the sequence (the largest index which can be used
  for a non-empty sequence) the subsequence expression will end at the
  last element of the sequence.

%  A {\it sequence modifier} has the form:
%  \begin{lstlisting}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{lstlisting}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[Examples:] Given that \texttt{GroupA} is equal to the sequence
  \begin{lstlisting}
    [ mk_Score(<Brazil>,2,0,1,6),
      mk_Score(<Norway>,1,2,0,5),
      mk_Score(<Morocco>,1,1,1,4),
      mk_Score(<Scotland>,0,1,2,1) ]
  \end{lstlisting}
\label{GroupAdef}
then:

  \begin{tabular}{lcl}
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a.team \\
            | a \keyw{in seq} GroupA \\
            \& a.won <> 0]}
    &$\equiv$ &
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a \\
            | a \keyw{in seq} GroupA\\
            \& a.won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)}
    &$\equiv$ &
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{6cm}{\ttfamily\selectfont
            [a \\
            | a \keyw{in seq} GroupA \\
            \& a.points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\section{Map Expressions} \label{mapexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{map enumeration} \dsep \Ruleref{map comprehension} \dsep \ldots
    }

  \Rule{map enumeration}{
    \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    }

  \Rule{maplet}{
    \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
    }

  \Rule{map comprehension}{
    \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{expression}}, \Lit{\}}
    }

\item[Semantics:] A {\it map enumeration} has the form:
  \begin{lstlisting}
    {d1 |-> r1, d2 |-> r2, !\ldots!, dn |-> rn}
  \end{lstlisting}
  where all the domain expressions {\tt di} and range expressions {\tt ri}
  are general expressions and all {\tt di}'s must be different unless they point to the same value. The empty map
  is written as {\tt \{|->\}}.

  A {\it map comprehension} has the form:
  \begin{lstlisting}
    {ed |-> er | mbd1, !\ldots!, mbdn & P}
  \end{lstlisting}
  where constructs {\tt mbd1, \ldots, mbdn} are multiple bindings of
  variables from the expressions {\tt ed} and {\tt er} to sets (or types).
  The {\it map comprehension} constructs a mapping by evaluating the
  expressions {\tt ed} and {\tt er} on all the possible bindings for which
  the predicate {\tt P} evaluates to \keyw{true}.

\item[Examples:] Given that \texttt{GroupG} is equal to the map
  \begin{lstlisting}
    { <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) }
  \end{lstlisting}
\label{GroupGdef}
  then:

  \begin{tabular}{lcl}
  \parbox[t]{9cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{8em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{9cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\section{Tuple Constructor Expressions} \label{tupexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{tuple constructor} \dsep \ldots
    }

  \Rule{tuple constructor}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
    }

\item[Semantics:] The {\it tuple constructor expression}  has the form:
  \begin{lstlisting}
    mk_(e1, e2, !\ldots!, en)
  \end{lstlisting}
  where {\tt ei} is a general expression. It can only be used by the
  equality and inequality operators.

\item[Examples:] Using the map \texttt{GroupG} defined in the preceding
example, we have:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG}
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\section{Record Expressions} \label{recexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{record constructor} \dsep
    \Ruleref{record modifier} \dsep \ldots
    }

  \Rule{record constructor}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(},
    \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{record modifier}{
    \Lop{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,},
    \Ruleref{record modification}, \lfeed \SeqPt{\Lit{,}, \Ruleref{record modification}}
    \Lit{)}
    }

  \Rule{record modification}{
    \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
    }

\item[Semantics:] The {\it record constructor} has the form:
  \begin{lstlisting}
    mk_T(e1, e2, !\ldots!, en)
  \end{lstlisting}
  where the type of the expressions {\tt (e1, e2, \ldots, en)} matches the
  type of the corresponding entrances in the composite type {\tt T}. Note that the reason why a \emph{name} (and not an \emph{identifier}) is used here is to take into account that one would like to be able to refer also to a class or a module where the record type is defined (see Chapter~\ref{top-level}) this would look like {\tt mk\_MC`T(e1, e2,} \ldots{\tt , en)} where {\tt MC} will be the name of a \emph{module} or a \emph{class}.

  The {\it record modification} has the form:
  \begin{lstlisting}
    mu (e, id1 |-> e1, id2 |-> e2, !\ldots!, idn |-> en)
  \end{lstlisting}
  where the evaluation of the expression {\tt e} returns the record value
  to be modified. All the identifiers {\tt idi} must be distinct named
  entrances in the record type of {\tt e}.

\item[Examples:] If \texttt{sc} is the value \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} then
  \begin{lstlisting}
    mu (sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    !\MYEQUIV! mk_Score(<France>,3,1,0,10)
  \end{lstlisting}
  Further examples are demonstrated in the function \texttt{win}. This
  function takes two teams and a set of scores. From the set of scores
  it locates the scores corresponding to the given teams (\texttt{wsc}
  and \texttt{lsc} for the winning and losing team respectively), then
  updates these using the \keyw{mu} operator. The set of teams is then
  updated with the new scores replacing the original ones.
  \begin{lstlisting}
  win : Team * Team * set of Score -> set of Score
  win (wt,lt,gp) ==
    let wsc = iota sc in set gp & sc.team = wt,
        lsc = iota sc in set gp & sc.team = lt
    in
      let new_wsc = mu (wsc, won |-> wsc.won + 1,
                             points |-> wsc.points + 3),
          new_lsc = mu (lsc, lost |-> lsc.lost + 1)
      in
        (gp \ {wsc,lsc}) union {new_wsc, new_lsc}
  pre forall sc1, sc2 in set gp &
          ((sc1 <> sc2) <=> (sc1.team <> sc2.team))
          and {wt,lt} subset {sc.team | sc in set gp};
  \end{lstlisting}

\end{description}

\section{Apply Expressions}\label{app-expr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{apply} \dsep
    \Ruleref{field select} \dsep
    \Ruleref{tuple select} \dsep
    \Ruleref{function type instantiation} \dsep
    \ldots
    }

  \Rule{apply}{
    \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }

  \Rule{field select}{
    \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
    }

  \Rule{tuple select}{
    \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
    }

  \Rule{function type instantiation}{
    \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
    }

\item[Semantics:] The {\it field select expression} can be used for records
  and it has already been explained in section~\ref{records} so no further
  explanation will be given here.

  The {\it apply} is used for looking up in a map, indexing in a
  sequence, and finally for calling a function. In section~\ref{maps} it
  has already been shown what it means to look up in a map. Similarly in
  section~\ref{sequences} it is illustrated how indexing in a sequence is
  performed. Function calls are using a call by value semantics meaning that the values are passed as arguments. The only exception to this is in the VDM++ and VDM-RT dialects where object references are passed as call by reference but since the functions cannot adjust any instance variable this make no semantic difference.

  In the VDM languages an operation can also be called
  here. This is not allowed in standard VDM-SL and because this kind of
  operation call can modify the state such usage should be done with
  care in complex expressions. Note however that such operation calls
  are not allowed to throw exceptions.

  With such operation calls the order of evaluation can become
  important. Therefore the type checker will allow the user to enable
  or disable operation calls inside expressions.

  The tuple select expression is used to extract a particular
  component from a tuple. The meaning of the expression is if
  \texttt{e} evaluates to some tuple
  \keyw{mk\_}\texttt{(v1,...,vN)} and \texttt{M} is an integer in the
  range \verb+{1,...,N}+ then \texttt{e.\#M} yields \texttt{vM}. If
  \texttt{M} lies outside \verb+{1,...,N}+ the expression is undefined.

  The {\it function type instantiation\/} is used for instantiating
  polymorphic functions with the proper types. It has the form:
  \begin{lstlisting}
    pf [ t1, ..., tn ]
  \end{lstlisting}
  where {\tt pf} is the name of a polymorphic function, and {\tt t1,
    \ldots, tn} are types. The resulting function uses the types {\tt
    t1, \ldots, tn} instead of the variable type names given in the
  function definition.

\item[Examples:] Recall that \texttt{GroupA} is a sequence (see page
  \pageref{GroupAdef}), \texttt{GroupG} is a map (see page \pageref{GroupGdef})
  and \texttt{selection\_sort} is a function (see page \pageref{selectionSortdef}):

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ &
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

  As an example of the use of polymorphic functions and function type
  instantiation, we use the example functions from
  section~\ref{functiondef}:
  \begin{lstlisting}
    let emptyInt = empty_bag[int]
    in
      plus_bag[int](-1, emptyInt())

  !\MYEQUIV!

    { -1 |-> 1 }
  \end{lstlisting}

\end{description}

\section{The New Expression (VDM++ and VDM-RT)}
\label{sec:creation}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{new expression}
    }
  \Rule{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\item[Semantics:] The {\it new expression} has the form:

  \begin{lstlisting}
    new classname(e1, e2, ..., en)
  \end{lstlisting}
  An object can be created (also called {\em instantiated}) from its
  class description using a {\it new expression}. The effect of a
  {\it new expression} is that a `new', unique object as described in
  class {\tt classname} is created. The value of the {\it new
  expression} is a reference to the new object.

  If the {\it new expression} is invoked with no parameters, an
  object is created in which all instance variables take their
  ``default'' values (i.e.\ the values defined by their initialisation
  conditions). With parameters, the {\it new expression} represents a
  \emph{constructor}~(see Section~\ref{constructors}) and creates
  customised instances (i.e.\ where the instance variables may take
  values which are different from their default values).


\item[Examples:] Suppose we have a class called \texttt{Queue} and
  that default instances of \texttt{Queue} are empty. Suppose also
  that this class contains a constructor (which will also be called
  \texttt{Queue}) which takes a single parameter which is a list of
  values representing an arbitrary starting queue. Then we can
  create default  instances of \texttt{Queue} in which the actual
  queue is empty using the expression
\begin{lstlisting}
  new Queue()
\end{lstlisting}
and an instance of \texttt{Queue} in which the actual
  queue is, say, \texttt{e1, e2, e3} using the expression
\begin{lstlisting}
  new Queue([e1, e2, e3])
\end{lstlisting}

Using the class \texttt{Tree} defined on page \pageref{TreeDef} we create
new \texttt{Tree} instances to construct \texttt{node}s:
\begin{lstlisting}
mk_node(new Tree(), x, new Tree())
\end{lstlisting}


\end{description}

\section{The Self Expression (VDM++ and VDM-RT)}
\label{sec:self}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{self expression}
    }
  \Rule{self expression}{
    \Lop{self}
  }

\item[Semantics:] The {\it self expression} has the form:

  \begin{lstlisting}
    self
  \end{lstlisting}
  The self expression returns a reference to the object currently
    being executed. It can be used to simplify the name space in
    chains of inheritance.

\item[Examples:] Using the class \texttt{Tree} defined on page
\pageref{TreeDef} we can specify a subclass called \texttt{BST} which
stores data using the binary search tree approach.
We can then specify an operation which performs a binary search tree
insertion:
\begin{lstlisting}
    Insert : int ==> ()
    Insert (x) ==
      (dcl curr_node : Tree := self;

       while not curr_node.isEmpty() do
         if curr_node.rootval() < x
         then curr_node := curr_node.rightBranch()
         else curr_node := curr_node.leftBranch();
       curr_node.addRoot(x);
       );
\end{lstlisting}
This operation uses a self expression to find the root at which to
being traversal prior to insertion. Further examples are given in
section \ref{call-stmt}.
\end{description}

\section{The Threadid Expression  (VDM++ and VDM-RT)}
\label{sec:threadid}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{threadid expression}
    }
  \Rule{threadid expression}{
    \Lop{threadid}
  }

\item[Semantics:] The {\it threadid expression} has the form:

  \begin{lstlisting}
    threadid
  \end{lstlisting}
  The threadid expression returns a natural number which uniquely
  identifies the thread in which the expression is executed. Note that
  periodic threads gets a new threadid at the start of each new period.

\item[Examples:]
Using {\bf\ttfamily threadid}'s it is possible to provide a VDM++ base class that
implements a Java-style wait-notify in VDM++ using permission
predicates. Any object that should be available for the wait-notify
mechanism must derive from this base class.
\begin{lstlisting}
class WaitNotify

  instance variables
    waitset : set of nat := {};

  operations
    protected wait: () ==> ()
    wait() ==
      let p = threadid
      in (
        AddToWaitSet( p );
        Awake();
       );

    AddToWaitSet : nat ==> ()
    AddToWaitSet( p ) ==
      waitset := waitset union { p };

    Awake: () ==> ()
    Awake() ==
      skip;

    protected notify: () ==> ()
    notify() ==
      if waitset <> {}
      then let arbitrary_process in set waitset
           in waitset := waitset \ {arbitrary_process};

    protected notifyAll: () ==> ()
    notifyAll() ==
         waitset := {};

  sync
    mutex(notifyAll, AddToWaitSet, notify);
    per Awake => threadid not in set waitset;

end WaitNotify
\end{lstlisting}
In this example the {\bf\ttfamily threadid} expression is used in two places:
\begin{itemize}
\item In the \texttt{Wait} operation for threads to register interest
  in this object.
\item In the permission predicate for \texttt{Awake}. An interested
  thread should call \texttt{Awake} following registration using
  \texttt{Wait}. It will then be blocked until its threadid is removed
  from the waitset following another thread's call to \texttt{notify}.
\end{itemize}

%Note also that one needs to be careful about the use of the wait-notify
%mechanism when having periodic threads (because they change their
%{\bf\ttfamily threadid}
%for each new period).
\end{description}

\section{The Lambda Expression}\label{lambda}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep \Ruleref{lambda expression} \dsep \ldots
    }

  \Rule{lambda expression}{
    \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
    }

\Rule{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it lambda expression} is of the form:
  \begin{lstlisting}
    lambda pat1 : T1, !\ldots!, patn : Tn & e
  \end{lstlisting}
  where the {\tt pati} are patterns, the {\tt Ti} are type expressions, and
  {\tt e} is the body expression. The scope of the pattern identifiers in
  the patterns {\tt pati} is the body expression. A lambda expression
  cannot be polymorphic, but apart from that, it corresponds semantically
  to an explicit function definition as explained in
  chapter~\ref{functiondef}. A function defined by a lambda expression can
  be Curried by using a new nested lambda expression in the body. 
  When lambda expressions are bound to an identifier they can also
  define a recursive function.

\item[Examples:] An increment function can be defined by means of a lambda
  expression like:
  \begin{lstlisting}
    Inc = lambda n : nat & n + 1
  \end{lstlisting}
  and an addition function can be Curried by:
  \begin{lstlisting}
    Add = lambda a : nat & lambda b : nat & a + b
  \end{lstlisting}
  which will return a new lambda expression if it is applied to only one
  argument:
  \begin{lstlisting}
    Add(5) !\(\equiv\)! lambda b : nat & 5 + b
  \end{lstlisting}
  Lambda expression can be useful when used in conjunction with higher-order
  functions. For instance using the function \texttt{set\_filter}
  defined on page \pageref{setfilterdef}:
  \begin{lstlisting}
  set_filter[nat](lambda n:nat & n mod 2 = 0)({1,...,10})
  !\MYEQUIV! {2,4,6,8,10}
  \end{lstlisting}
\end{description}


\section{Narrow Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{narrow expression} \dsep
    \ldots
    }

  \Rule{narrow expression}{
    \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)}
    }

    \item[Semantics:] The {\it narrow expression} converts the given {\tt expression} value into the given {\tt type},
returning a value of that type.
It is legal to downcast a class to one of its subclasses, and it is legal to narrow an expression of a union type
to one of its subtypes. However, a conversions between two completely unrelated types is a type error. Note that a
narrow expression does not guarantee that its argument will be of the correct type at runtime, but using narrow gives
extra type information to the specification.

    \item[Examples:] In following examples, the Test() and Test'() operations should give the same results,
    but there is a type error in Test() which is resolved in Test' using a narrow expression.

      \begin{lstlisting}
class S
end S

class C1 is subclass of S

instance variables
public a : nat := 1;

end C1

class C2 is subclass of S

instance variables
public b : nat := 2;

end C2

class A

operations
public
Test: () ==>  seq of nat
Test() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> e.a,
                (isofclass(C2, e)) -> e.b
               end | i in set inds list ];

public
Test': () ==>  seq of nat
Test'() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> narrow_(e, C1).a,
                (isofclass(C2, e)) -> narrow_(e, C2).b
               end | i in set inds list ];
end A
      \end{lstlisting}

      \begin{lstlisting}
class A

types
public C1 :: a : nat;
public C2 :: b : nat;
public S = C1 | C2;

operations
public
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

public
Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
end A
      \end{lstlisting}

\end{description}


\section{Is Expressions}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{general is expression} \dsep
    \ldots
    }

  \Rule{general is expression}{
    \Ruleref{is expression} \dsep
    \Ruleref{type judgement}
    }


  \Rule{is expression}{
    \Lop{is\_}, \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
    \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{is basic type}{
    \Lop{is\_},
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl
      \Lop{nat1} \dsepl
      \Lop{int} \dsep
      \Lop{rat} \dsepl
      \Lop{real} \dsepl
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{type judgement}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\item[Semantics:] The {\it is expression} can be used with values
     that are either basic or record values (tagged values belonging
     to some composite type). The is expression yields true if the
     given value belongs to the basic type indicated or if the value
     has the indicated  tag. Otherwise it yields false.

     A type judgement is a more general form which can be used for
     expressions whose types cannot be statically determined. The
     expression \texttt{\keyw{is}\_(e,t)} is equal to true if and only
     if \texttt{e} is of type \texttt{t}.

\item[Examples:] Using the record type \texttt{Score} defined on page
  \pageref{scoredef} we have:

  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
% Ueki mod start (Kagemai#54)
%    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,8))}
%      & $\equiv$ & \keyw{false}\\
% Ueki mod end
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

  An example of a type judgement:
  \begin{lstlisting}
    Domain : map nat to nat | seq of (nat*nat) -> set of nat
    Domain(m) ==
      if is_(m, map nat to nat)
      then dom m
      else {d | mk_(d,-) in set elems m};
  \end{lstlisting}
     In addition there are examples on page \pageref{exprIsExs}.
\end{description}

\section{Base Class Membership (VDM++ and VDM-RT)}\index{base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofbaseclass expression} \dsep
    \ldots
    }

  \Rule{isofbaseclass expression}{
    \Lop{isofbaseclass},
    \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\item[Semantic:] The function {\keyw{isofbaseclass}} when applied to an
  object reference \texttt{expression} and a class name \texttt{name}
  yields the boolean value {\bf\ttfamily true} if and only if \texttt{name} is a
  root superclass in the inheritance chain of the object referenced to
  by {\texttt expression}, and {\bf\ttfamily false} otherwise.

\item[Examples:] \label{treeExDef}
  Suppose that \texttt{BinarySearchTree} is a subclass of
  \texttt{Tree}, \texttt{Tree} is not a subclass of any other class and
  \texttt{Queue} is not related by inheritance to either \texttt{Tree}
  or \texttt{BinarySearchTree}. Let \texttt{t} be an instance of
  \texttt{Tree}, \texttt{b} is an instance of \texttt{BinarySearchTree}
  and \texttt{q} is an instance of \texttt{Queue}. Then:

  \begin{tabular}{lcl}
    \keyw{isofbaseclass}\texttt{(Tree, t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(BinarySearchTree, b)} & $\equiv$ & \keyw{false}\\
    \keyw{isofbaseclass}\texttt{(Queue, q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, q)} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\section{Class Membership}\index{class membership expression}
\begin{description}
\item[Syntax]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{isofclass expression} \dsep
    \ldots
    }
  \Rule{isofclass expression}{
    \Lop{isofclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The function \keyw{isofclass} when applied to an
  object reference {expression} and a class name \texttt{name}
  yields the boolean value {\bf\ttfamily true} if and only if \texttt{expression}
  refers to an object of class \texttt{name} or to an object of any of
  the subclasses of \texttt{name}, and {\bf\ttfamily false} otherwise.

\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, we have:

  \begin{tabular}{lcl}
    \keyw{isofclass}\texttt{(Tree,t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,q)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(Queue,q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,t)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,b)} & $\equiv$ & \keyw{true}
  \end{tabular}

\end{description}

\section{Same Base Class Membership (VDM++ and VDM-RT)}%
\index{same base class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{samebaseclass expression} \dsep
    \ldots
    }
  \Rule{samebaseclass expression}{\Lop{samebaseclass}, \lfeed
  \Lit{(},
        \Ruleref{expression}, \Lit{,}, \Ruleref{expression}, \Lit{)}
    }

\item[Semantics:] The function \keyw{samebaseclass} when applied to
  object references \texttt{expression1} and \texttt{expression2} yields
  the boolean value {\bf\ttfamily true} if and only if the objects denoted by
  \texttt{expression1} and \texttt{expression2} are instances of classes
  that can be derived from the same root superclass, and {\bf\ttfamily false}
  otherwise.

\item[Examples:] Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} as in the previous example, suppose that
\texttt{AVLTree} is another subclass of \texttt{Tree},
\texttt{BalancedBST} is a subclass of \texttt{BinarySearchTree}, \texttt{a}
is an instance of \texttt{AVLTree} and \texttt{bb} is an instance of
\texttt{BalancedBST} :

  \begin{tabular}{lcl}
  \keyw{samebaseclass}\texttt{(a,b)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(a,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(b,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(t,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(q,a)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{Same Class Membership (VDM++ and VDM-RT)}%
\index{same class membership expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
     \Ruleref{sameclass expression} \dsep
    \ldots
    }

  \Rule{sameclass expression}{\Lop{sameclass}, \lfeed
  \Lit{(}, \Ruleref{expression}, \Lit{,},
        \Ruleref{expression}, \Lit{)}
   }

\item[Semantics:] The function \keyw{sameclass} when applied to object
  references \texttt{expression1} and \texttt{expression2} yields the
  boolean value {\bf\ttfamily true} if and only if the objects denoted by
  \texttt{expression1} and \texttt{expression2} are instances of the same
  class, and {\bf\ttfamily false} otherwise.

\item[Examples:]
Assuming the classes \texttt{Tree},
\texttt{BinarySearchTree}, \texttt{Queue}, and identifiers \texttt{t},
\texttt{b}, \texttt{q} from section \ref{treeExDef}, and assuming
\texttt{b'} is another instance of \texttt{BinarySearchTree} we have:

  \begin{tabular}{lcl}
  \keyw{sameclass}\texttt{(b,t)} & $\equiv$ & \keyw{false}\\
  \keyw{sameclass}\texttt{(b,b')} & $\equiv$ & \keyw{true}\\
  \keyw{sameclass}\texttt{(q,t)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{History Expressions (VDM++ and VDM-RT)}\index{history expressions}
\label{sec:historyexpr}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{act expression} \dsep
    \Ruleref{fin expression} \dsep
    \Ruleref{active expression} \dsep
    \Ruleref{req expression} \dsep
    \Ruleref{waiting expression} \dsep
    \ldots
  }
  \Rule{act expression}{
    \Lop{\#act}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{fin expression}{
    \Lop{\#fin}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{active expression}{
    \Lop{\#active}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{req expression}{
    \Lop{\#req}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Rule{waiting expression}{
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }

\item[Semantics:] History expressions can only be used in
permission predicates (see section \ref{sec:permissionpred}). History
expressions may contain one or more of the following expressions:

\begin{itemize}
\item {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}. The number of times
  that {\em operation name} operation has been activated.
\item {\bf\ttfamily \#fin}{\tt (}{\em operation name}{\tt )}. The number of times that
  the {\em operation name} operation has been completed.
\item {\bf\ttfamily \#active}{\tt (}{\em operation name}{\tt )}. The number of {\em operation
  name} operations that are currently active. \\
 Thus: {\bf\ttfamily
  \#active}{\tt (}{\em
    operation name}{\tt )} $=$ {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}
  $-$ {\bf\ttfamily \#fin}{\tt (}{\em operation name}{\tt )}.
\item {\bf\ttfamily \#req}{\tt (}{\em operation name}{\tt )}. The number of requests
  that has been issued for the {\em operation name} operation.
\item {\bf\ttfamily \#waiting}{\tt (}{\em operation name}{\tt )}. The number of
  outstanding requests for the {\em operation name} operation. \\
Thus:
  {\bf\ttfamily
    \#waiting}{\tt (}{\em operation name}{\tt )} $=$ {\bf\ttfamily
    \#req}{\tt (}{\em operation
    name}{\tt )} $-$ {\bf\ttfamily \#act}{\tt (}{\em operation name}{\tt )}.
\end{itemize}
For all of these operators, the name list version
\texttt{\#}\textit{history op(op1,$\ldots$,opN)} is simply shorthand
for \texttt{\#}\textit{history op(op1)} \texttt{+} $\mathtt{\cdots}$
\texttt{+\#}\textit{history op(opN)}.

\item[Examples:]Suppose at a point in the execution of a particular
thread, three operations, \texttt{A}, \texttt{B} and \texttt{C} may be
executed. A sequence of requests, activations and completions occur
during this thread. This is shown graphically in figure \ref{historyfig}.

\insertfig{history}{14cm}{History Expressions}{\label{historyfig}}

Here we use the notation \textit{rA} to indicate a request for an
execution of operation \texttt{A}, \textit{aA} indicates an activation
of \texttt{A}, \textit{fA} indicates completion of an execution of
operation \texttt{A}, and likewise for operations \texttt{B} and
\texttt{C}. The respective history expressions have the following
values after the interval [\textbf{S},\textbf{T}]:
\end{description}

\begin{center}\small
\begin{tabular}{llll}
\texttt{{\bf\ttfamily \#act}(A) = 1} & \texttt{{\bf\ttfamily \#act}(B) = 1} & \texttt{{\bf\ttfamily \#act}(C) = 1}
& \texttt{{\bf\ttfamily \#act}(A,B,C) = 3}\\
\texttt{{\bf\ttfamily \#fin}(A) = 1} & \texttt{{\bf\ttfamily \#fin}(B) = 1} & \texttt{{\bf\ttfamily \#fin}(C) = 0}
& \texttt{{\bf\ttfamily \#fin}(A,B,C) = 2}\\
\texttt{{\bf\ttfamily \#active}(A) = 0} & \texttt{{\bf\ttfamily \#active}(B) = 0} &
\texttt{{\bf\ttfamily \#active}(C) = 1} & \texttt{{\bf\ttfamily \#active}(A,B,C) = 1}\\
\texttt{{\bf\ttfamily \#req}(A) = 2} & \texttt{{\bf\ttfamily \#req}(B) = 1} & \texttt{{\bf\ttfamily \#req}(C) = 3}
& \texttt{{\bf\ttfamily \#req}(A,B,C) = 6}\\
\texttt{{\bf\ttfamily \#waiting}(A) = 1} & \texttt{{\bf\ttfamily \#waiting}(B) = 0} &
\texttt{{\bf\ttfamily \#waiting}(C) = 2} & \texttt{{\bf\ttfamily \#waiting}(A,B,C) = 3}\\
\end{tabular}
\end{center}


\section{The Time Expression (VDM-RT)}\index{time expression}\label{sec:time}

\begin{description}
\item[Syntax:]
 \Rule{time expression}{\Lop{time}}

\item[Semantics:] This is simply an easy way to refer to the current time on
     a given CPU. The time is provided as a natural number, with a resolution of 1~nsec.
\item[Examples:] If for example one would like to log when a certain operation takes place one can create an operation such as \texttt{logEnvToSys} below.
\begin{lstlisting}
  public logEnvToSys: nat ==> ()
  logEnvToSys (pev) == e2s := e2s munion {pev |-> time};
\end{lstlisting}
\end{description}


\section{Literals and Names}

\begin{description}
\item[Syntax:]
  \Rule{expression}{    \ldots \dsep
    \Ruleref{name} \dsep
    \Ruleref{old name} \dsep
    \Ruleref{symbolic literal} \dsep
    \ldots
    }

  \Rule{name}{
    \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
    }

  \Rule{name list}{
    \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
    }

  \Rule{old name}{
    \Ruleref{identifier}, \Lit{\char'176}
    }

\item[Semantics:] {\it Names\/} and {\it old names\/} are used to access
  definitions of functions, operations, values and state components. A {\it
    name\/} has the form:
  \begin{lstlisting}
    id1`id2
  \end{lstlisting}
  where {\tt id1} and {\tt id2} are simple identifiers. If a name consists
  of only one identifier, the identifier is defined within scope, i.e.\ it
  is defined either locally as a pattern identifier or variable,
  or globally within the current module as a function, operation,
  value or global variable.
  Otherwise, the identifier {\tt id1} indicates the
module/class name
where the
  construct is defined (see also
  section~\ref{modules} and
  section~\ref{sec:classdep}
and appendix \ref{ap:lexis}.)

  An {\it old name\/} is used to access the old value of global
  variables in the post condition of an operation definition (see
  chapter~\ref{op-def}) and in the post condition of specification
  statements (see section~\ref{se:specification}).  It has the form:

  \begin{lstlisting}
    id~
  \end{lstlisting}
  where {\tt id} is a state component.

  {\it Symbolic literals\/} are constant values of some basic type.

\item[Examples:] {\it Names} and {\it symbolic literals\/} are used
  throughout all examples in this document (see appendix~\ref{Symbols}).

  For an example of the use of {\it old names}, consider the VDM-SL
  state defined as:
  \begin{lstlisting}
state sigma of
  numbers : seq of nat
  index   : nat
inv mk_sigma(numbers, index) ==
   index not in set elems numbers
init s == s = mk_sigma([], 1)
end
  \end{lstlisting}
  For an example of the use of {\it old names}, consider the
  VDM++/VDM-RT instance variables defined as:
  \begin{lstlisting}
    instance variables
      numbers: seq of nat := [];
      index  : nat := 1;
    inv index not in set elems numbers;
  \end{lstlisting}

  We can define an operation that increases the variable {\tt index} in
  an implicit manner:
  \begin{lstlisting}
    IncIndex()
    ext wr index : nat
    post index = index~ + 1
  \end{lstlisting}
  The operation {\tt IncIndex} manipulates the variable {\tt index},
  indicated with the \keyw{ext wr} clause. In the post condition, the new
  value of {\tt index} is equal to the old value of {\tt index} plus
  \texttt{1}. (See more about operations in chapter~\ref{op-def}).

  For a simple example of
module/class
  names, suppose that a function called
  \texttt{build\_rel} is defined (and exported) in a
module/class
  called
  \texttt{CGRel} as follows:
\begin{lstlisting}
  types

    Cg = <A> | <B> | <C> | <D> | <E> | <F> |
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = map Cg to set of Cg

  functions

    build_rel : set of (Cg * Cg) -> CompatRel
    build_rel (s) == {|->};
\end{lstlisting}
In another
module/class
  we can access this function by in VDM-SL
first importing the module \texttt{CGRel} then by
  using the following call
  \begin{lstlisting}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{lstlisting}
Note that in VDM++ and VDM-RT the \texttt{build\_rel} function can
additionally have
an access modifier allowing access to it outside the defining class.
\end{description}

\section{The Undefined Expression}

\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{undefined expression}
    }

  \Rule{undefined expression}{
    \Lop{undefined}
    }

\item[Semantics:] The {\it undefined expression} is used to state
  explicitly that the result of an expression is undefined. This could
  for instance be used if it has not been decided what the result of
  evaluating the else-branch of an if-then-else expression should be.
  When an {\it undefined expression} is evaluated the
  VDM interpreters will terminate the execution
  and report that an undefined expression was evaluated.

  Pragmatically use of undefined expressions differs from
  pre-conditions: use of a pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the function is called; if an undefined expression is used it is the
  called function's responsibility to deal with error handling.

\item[Examples:] We can check that the type invariant holds before building 
  \texttt{Score} values:
  \begin{lstlisting}
  build_score : Team * nat * nat * nat * nat -> Score
  build_score (t,w,d,l,p) ==
    if 3 * w + d = p
    then mk_Score(t,w,d,l,p)
    else undefined;
  \end{lstlisting}
\end{description}

\section{The Precondition Expression}
\begin{description}
\item[Syntax:]
  \Rule{expression}{
    \ldots \dsep
    \Ruleref{precondition expression}
    }
  \Rule{precondition expression}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
                 \Lit{)}
    }

\item[Semantics:]
  Assuming \texttt{e} is of function type the expression
  \keyw{pre\_}\texttt{(e,e1,...,en)} is true if and only if the
  pre-condition of \texttt{e} is true for arguments \texttt{e1,...,em}
  where \texttt{m} is the arity of the pre-condition of \texttt{e}. If
  \texttt{e} is not a function or \texttt{m} $>$ \texttt{n} then the
  result is {\bf\ttfamily true}. If \texttt{e} has no pre-condition then the
  expression equals true.
\item[Examples:]
  Consider the functions \texttt{f} and \texttt{g} defined below
  \begin{lstlisting}
  f : nat * nat -> nat
  f(m,n) == m div n
  pre n <> 0;

  g (n: nat) sqrt: nat
  pre n >= 0
  post sqrt * sqrt <= n and
       (sqrt+1) * (sqrt+1) > n;
  \end{lstlisting}
  Then the expression
  \begin{lstlisting}
  pre_(let h in set {f,g,lambda mk_(x,y): nat * nat & x div y}
       in h, 1,0,-1)
  \end{lstlisting}
  is equal to
  \begin{itemize}
  \item false if \texttt{h} is bound to \texttt{f} since this equates
        to \texttt{\keyw{pre}\_f(1,0)};
  \item true if \texttt{h} is bound to \texttt{g} since this equates
        to \texttt{\keyw{pre}\_g(1)};
  \item true if \texttt{h} is bound to
        \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} since there is no
        pre-condition defined for this function.
  \end{itemize}
  Note that however \texttt{h} is bound, the last argument
  (\texttt{-1}) is never used.
\end{description}


\chapter{Patterns}\label{patterns}

\begin{description}
\item[Syntax:]
  \Rule{pattern bind}{
    \Ruleref{pattern} \dsepl
    \Ruleref{bind}
    }

  \Rule{pattern}{
    \Ruleref{pattern identifier} \dsep
    \Ruleref{match value} \dsep
    \Ruleref{set enum pattern} \dsep
    \Ruleref{set union pattern} \dsep
    \Ruleref{seq enum pattern} \dsep
    \Ruleref{seq conc pattern} \dsep
    \Ruleref{map enumeration pattern} \dsep
    \Ruleref{map muinon pattern} \dsep
    \Ruleref{tuple pattern} \dsep
    \Ruleref{record pattern} \dsep
    \Ruleref{object pattern}
    }

  \Rule{pattern identifier}{
    \Ruleref{identifier} \dsepl \Lit{-}
    }

  \Rule{match value}{
    \Ruleref{symbolic literal} \dsep \Lit{(}, \Ruleref{expression}, \Lit{)}
    }

  \Rule{set enum pattern}{
    \Lit{\{}, [\Ruleref{pattern list}], \Lit{\}}
    }

  \Rule{set union pattern}{
    \Ruleref{pattern}, \Lit{\keyw{union}}, \Ruleref{pattern}
    }

  \Rule{seq enum pattern}{
    \Lit{[}, [\Ruleref{pattern list}], \Lit{]}
    }

  \Rule{seq conc pattern}{
    \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
    }

  \Rule{map enumeration pattern}{
    \Lit{\{}, [\Ruleref{maplet pattern list}], \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    }

  \Rule{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

  \Rule{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

   \Rule{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

  \Rule{tuple pattern}{
    \Lop{mk\_(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
    }

  \Rule{record pattern}{
    \Lop{mk\_}, \Ruleref{name}, \Lit{(}, [\Ruleref{pattern list}], \Lit{)}
    }


  \Rule{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}\nmk
    }
 \ntext{\Ruleref{object pattern} is only be used in VDM++ and VDM-RT. The
 	\Ruleref{object pattern} is explained in \ref{sec:object_pattern}}

  \Rule{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Rule{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

  \Rule{pattern list}{
    \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
    }

\item[Semantics:] A pattern is always used in a context where it is matched
  to a value of a particular type. Matching consists of checking that the
  pattern can be matched to the value, and binding any pattern identifiers
  in the pattern to the corresponding values, i.e.\ making the identifiers
  denote those values throughout their scope. In some cases where a pattern
  can be used, a bind can be used as well (see next chapter). If a bind is
  used it simply means that additional information (a type or a set
  expression) is used to constrain the possible values which can match the
  given pattern.

  Matching is defined as follows
  \begin{enumerate}
  \item A {\it pattern identifier} fits any type and can be matched to any
    value. If it is an identifier, that identifier is bound to the value;
    if it is the don't-care symbol \Lit{-}, no binding occurs.

  \item A {\it match value} can only be matched against the value of
    itself; no binding occurs. If a match value is not a literal like e.g.
    {\tt 7} or {\tt <RED>} it must be an expression enclosed in parentheses in order to
    discriminate it to a pattern identifier.

  \item A {\it set enumeration pattern} fits only set values. The patterns
    are matched to distinct elements of a set; all elements must be
    matched.

  \item A {\it set union pattern} fits only set values. The two patterns
    are matched to a partition of two subsets of a set. In the VDM interpreters
    the two subsets will always be chosen such that they are non-empty
    and disjoint.

  \item A {\it sequence enumeration pattern} fits only sequence values.
    Each pattern is matched against its corresponding element in the
    sequence value; the length of the sequence value and the number of
    patterns must be equal.

  \item A {\it sequence concatenation pattern} fits only sequence values.
    The two patterns are matched against two subsequences which together
    can be concatenated to form the original sequence value. In the
    VDM interpreters the two subsequences will always be chosen so that they
    are non-empty.

  \item A {\it map enumeration pattern} fits only map values.

  \item A {\it maplet pattern list} are matched to distinct elements of a map;
   all elements must be matched.

  \item A {\it map munion pattern} fits only map values.
   The two patterns are matched to a partition of two sub maps of a map.
   In the VDM interpreters the two sub maps will always be chosen such that they are non-empty and disjoint.

  \item A {\it tuple pattern} fits only tuples with the same number of
    elements. Each of the patterns are matched against the corresponding
    element in the tuple value.

  \item A {\it record pattern} fits only record values with the same tag.
    Each of the patterns are matched against the field of the record value.
    All the fields of the record must be matched.

  \item An {\it object pattern} is explained in section~\ref{sec:object_pattern}
  \end{enumerate}

\item[Examples:] The simplest kind of pattern is the pattern
identifier. An example of this is given in the following let
expression:
\begin{lstlisting}
  let top = GroupA(1)
  in top.sc
\end{lstlisting}
Here the identifier \texttt{top} is bound to the head of the sequence
\texttt{GroupA} and the identifier may then be used in the body of the
let expression.

In the following examples we use match values:
\begin{lstlisting}
  let a = <France>
  in cases GroupA(1).team:
       <Brazil> -> "Brazil are winners",
       (a)      -> "France are winners",
       others   -> "Neither France nor Brazil are winners"
     end;
\end{lstlisting}
Match values can only match against their own values, so here if the
team at the head of \texttt{GroupA} is \texttt{<Brazil>} then the
first clause is matched; if the team at the head of \texttt{GroupA} is
\texttt{<France>} then the second clause is matched. Otherwise the
\keyw{others} clause is matched. Note here that the use of brackets
around \texttt{a} forces \texttt{a} to be considered as a match value.

Set enumerations match patterns to elements of a set. For instance in:
\begin{lstlisting}
  let {sc1, sc2, sc3, sc4} = elems GroupA
  in
    sc1.points + sc2.points + sc3.points + sc4.points;
\end{lstlisting}
the identifiers \texttt{sc1}, \texttt{sc2}, \texttt{sc3} and
\texttt{sc4} are bound to the four elements of \texttt{GroupA}. Note
that the choice of binding is loose -- for instance
\texttt{sc1} may be bound to any element of \texttt{\keyw{elems}
GroupA}. In this case if \texttt{\keyw{elems} GroupA} does not contain
precisely four elements, then the expression is not well-formed.

A set union pattern can be used to decompose a set for recursive
function calls. An example of this is the function \texttt{set2seq}
which converts a set into a sequence (with arbitrary order):
\begin{lstlisting}
set2seq[@elem] : set of @elem -> seq of @elem
set2seq(s) ==
  cases s:
    {}          -> [],
    {x}         -> [x],
    s1 union s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
  end;
\end{lstlisting}
In the third cases alternative we see the use of a set union pattern. This
binds \texttt{s1} and \texttt{s2} to arbitrary subsets of \texttt{s}
such that they partition \texttt{s}. The VDM interpreters always
ensure a disjoint partition.

Sequence enumeration patterns can be used to extract specific elements
from a sequence. An example of this is the function \texttt{promoted}
which extracts the first two elements of a sequence of scores and
returns the corresponding pair of teams:
\begin{lstlisting}
promoted : seq of Score -> Team * Team
promoted([sc1,sc2]^-) == mk_(sc1.team,sc2.team);
\end{lstlisting}
Here \texttt{sc1} is bound to the head of the argument sequence, and
\texttt{sc2} is bound to the second element of the sequence. If
\texttt{promoted} is called with a sequence with fewer than two
elements then a runtime error occurs. Note that as we are not
interested in the remaining elements of the list we use a don't care
pattern for the remainder.

The preceding example also demonstrated the use of sequence
concatenation patterns. Another example of this is the function
\texttt{quicksort} which implements a standard quicksort algorithm:
\begin{lstlisting}
quicksort : seq of nat -> seq of nat
quicksort (l) ==
  cases l:
    [] -> [],
    [x] -> [x],
    [x,y] -> if x < y then [x,y] else [y,x],
    -^[x]^- ->
          quicksort([l(i) | i in set inds l & l(i) < x])
                  ^ [l(i) | i in set inds l & l(i) = x] ^
          quicksort([l(i) | i in set inds l & l(i) > x])
  end;
\end{lstlisting}
Here, in the second cases clause a sequence concatenation pattern is
used to decompose \texttt{l} into an arbitrary pivot element and two
subsequences. The pivot is used to partition the list into those
values less than the pivot and those values greater, and these two
partitions are recursively sorted.


Maplet pattern match patterns to elements of a maplet.
\begin{lstlisting}
let {a |-> b} = {1 |-> 2} in mk_(a,b) = mk_(1,2)
\end{lstlisting}

Maplet pattern list match patterns to elements of each maplet in a map.
\begin{lstlisting}
let {1 |-> a,a |-> b,b |-> c} = {1 |-> 4,2 |-> 3,4 |-> 2} in
c = 3
\end{lstlisting}

Map munion pattern can be used to decompose a map for recursive function calls. The following \texttt{map2seq} function converts a map to a seq of maplet:
\begin{lstlisting}
public map2seq[@T1, @T2] :
    map @T1 to @T2 -> seq of (map @T1 to @T2)
map2seq(m) ==
  cases m:
    ({|->})	-> [],
    {- |-> -}	-> [m],
    m1 munion m2 ->
        map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
 end;
\end{lstlisting}
Here, in the third cases clause a map munion pattern is used to decompose \texttt{m}
into two maps.

Tuple patterns can be used to bind tuple components to
identifiers. For instance since the function \texttt{promoted} defined
above returns a pair, the following value definition binds the winning
team of \texttt{GroupA} to the identifier \texttt{Awinner}:
\begin{lstlisting}
  values

    mk_(Awinner,-) = promoted(GroupA);
\end{lstlisting}

Record patterns are useful when several fields of a record are used in
the same expression. For instance the following expression constructs
a map from team names to points score:
\begin{lstlisting}
  { t |-> w * 3 + l | mk_Score(t,w,l,-,-) in set elems GroupA}
\end{lstlisting}
The function \texttt{print\_Expr} on page \pageref{printExprDef} also gives
several examples of record patterns.
\end{description}


\section{Object Pattern (VDM++ and VDM-RT)}\label{sec:object_pattern}

\begin{description}

\item[Syntax:]
  \Rule{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}
    }

  \Rule{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Rule{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

\item[Semantics:] An object pattern matches object references. An object is matched to the class identified by the class name led by the prefix \textbf{\texttt{obj\_}}. If the class of the object is class \texttt{identifier} or any of its subclasses, separate instance variables named in an object pattern are matched against the object from left to right.  It is not necessary to enumerate all the instance variables of a referenced class in an object pattern.

Object patterns may appear only where access to the instance variables named in the pattern would be permitted. So private instance variables can only be matched within operations of the same class. This also implies an object pattern may not appear in function definitions, preconditions, postconditions or invariants. The type checker will validate accessibility of each instance variable in the pattern. The value of referenced instance variables is not guaranteed to remain unchanged during matching.

\item[Examples:] Using an object pattern, an object can be matched by the values of its instance variables. The following simple example evaluates to \texttt{<STUDENT>} if and only if the object reference person points at an instance of the class Student or any of its subclasses, otherwise \texttt{<NOT\_STUDENT>}:
\begin{lstlisting}
cases person:
   obj_Student() -> <STUDENT>,
   others -> <NOT_STUDENT>
end
\end{lstlisting}

The above object pattern would match any instance of the Student class, or any subclass, for example an Undergraduate if such a subclass existed. The following example matches the instance variable name against \texttt{"John"}:

\begin{lstlisting}
cases person:
   obj_Student(name |-> "John") -> <JOHN>,
   others -> <NOT_A_STUDENT_OR_NOT_JOHN>
end
\end{lstlisting}
An object pattern can also bind the value of instance variable. For example, the following expression binds \texttt{n} to the \texttt{name} instance variable of  \texttt{person} if person is an instance of the class Student.

\begin{lstlisting}
cases person:
   obj_Student(name |-> n) -> n,
   others -> ""
end
\end{lstlisting}
An object pattern may contain another object pattern. The following expression gives the name and department concatenated by \texttt{"@"} for Students, and add the title for Professors.
\begin{lstlisting}
cases person:
   obj_Student
      (name |-> n, dept |-> obj_Department(name->dname))
                 -> n^"@"^dname,
   obj_Professor(name |-> n) -> "Prof. "^n,
   others -> ""
end
\end{lstlisting}
An object pattern may appear in conjunction with other kinds of patterns. The following operation takes a sequence of \texttt{Professor} objects and returns titled names sorted into initials. The first pattern of the cases expression consists of a list concatenation pattern. The first element of the list is matched against an object pattern whose instance variable {\tt name} is also matched against another sequence concatenation pattern of the initial character {\tt initial} and the  {\tt remaining}:

\begin{lstlisting}
professorDict: seq of Professor
                        ==> map char to set of seq of char
professorDict(ps) == return cases ps:
  [obj_Professor(name |-> [initial]^remaining)]^rest ->
    let
      dict = professorDict(rest),
      name = "Prof. "^[initial]^remaining,
      names = if initial in set dom dict
                     then dict(initial)
                     else {}
    in
  dict ++ {initial |-> names union {name}},
  [-]^rest -> professorDict(rest),[] -> {|->}
  end;
\end{lstlisting}  

For example, the call \texttt{professorDict([new Professor("Smith"), \\new Professor("Scott"), new Professor("Adams")])} evaluates to:
\begin{lstlisting}
{'A' |-> {"Prof. Adams"},
 'S' |-> {"Prof. Scott", "Prof. Smith"}}.
\end{lstlisting}


\end{description}

\chapter{Bindings}\label{bind}

\begin{description}
\item[Syntax:]
  \Rule{bind}{
    \Ruleref{set bind} \dsepl \Ruleref{seq bind} \dsepl \Ruleref{type bind}
    }

  \Rule{set bind}{
    \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{seq bind}{
    \Ruleref{pattern}, \Lop{in seq}, \Ruleref{expression}
    }

  \Rule{type bind}{
    \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
    }

  \Rule{bind list}{
    \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
    }

  \Rule{multiple bind}{
    \Ruleref{multiple set bind} \dsep
    \Ruleref{multiple seq bind} \dsep
    \Ruleref{multiple type bind}
    }

  \Rule{multiple set bind}{
    \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
    }

  \Rule{multiple seq bind}{
    \Ruleref{pattern list}, \Lop{in seq}, \Ruleref{expression}
    }

  \Rule{multiple type bind}{
    \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
    }

\item[Semantics:] A {\it bind} matches a pattern to a value. In a {\it
    set bind} the value is chosen from the set defined by the set
    expression of the bind. In a {\it seq bind} the value is chosen from the sequence defined by the sequence expression of the bind. In a {\it type bind} the value is chosen
    from the type defined by the type expression.  {\it Multiple bind}
    is the same as {\it bind} except that several patterns are bound
    to the same set, sequence or type.  Notice that type binds {\bf can} only be
    executed by the VDM interpreters in case the type can be deduced
    to be finite statically.  This would require the VDM interpreters
    to search through infinite domains like the natural numbers.

\item[Examples:] Bindings are mainly used in quantified expressions and
  comprehensions which can be seen from these examples:
  \begin{lstlisting}
forall i, j in set inds list & i < j => list(i) <= list(j)

{ y | y in set S & y > 2 }

{ y | y: nat & y > 3 }

occurs : seq1 of char * seq1 of char -> bool
occurs (substr,str) ==
  exists i,j in set inds str & substr = str(i,...,j);
  \end{lstlisting}
\end{description}

\chapter{Value (Constant) Definitions} \label{valuedef}

The VDM languages supports the definition of constant
values. A value definition corresponds to a constant definition in
traditional programming languages.

\begin{description}
\item[Syntax:]
  \Rule{value definitions}{
    \Lop{values},
    \OptPt{\Ruleref{access value definition}}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{access value definition}},
           \OptPt{\Lit{;}}
    }

%  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       \OptPt{\Ruleref{access}},
         \Ruleref{value definition}
    }%}{}


  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

\item[Semantics:] The value definition has the form:
  \begin{lstlisting}
    values
      access pat1 = e1;
      !\ldots!
      access patn = en
  \end{lstlisting}
where the {\tt access} part only can be used in VDM++ and VDM-RT.

  The global values (defined in a value definition) can be referenced
  at all levels in a VDM specification.  However,
  in order to be able to execute a specification these
  values must be defined before they are used in the sequence of value
  definitions. This ``declaration before use'' principle is only used
  by the VDM interpreters for value definitions.
  Thus for instance functions can be used before they are declared. In
  standard VDM-SL there are not any restrictions on the order of the
  definitions at all. It is possible to provide a type restriction as
  well, and this can be useful in order to obtain more exact type
  information.

Details of the VDM++ and VDM-RT access specifiers
can be found in section \ref{ch:interface}.

\item[Examples:] The example below, taken from \cite{Fitzgerald&98}
  assigns token values to identifiers
  \texttt{p1} and \texttt{eid2}, an \texttt{Expert} record value to
  \texttt{e3} and an \texttt{Alarm} record value to \texttt{a1}.
\begin{lstlisting}
types

Period = token;
ExpertId = token;
Expert :: expertid : ExpertId
          quali : set of Qualification
inv ex == ex.quali <> {};
Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
Alarm :: alarmtext : seq of char
         quali : Qualification

values

public p1: Period = mk_token("Monday day");
private eid2 : ExpertId = mk_token(145);
protected e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
a1 : Alarm = mk_Alarm("CO2 detected", <Chem>);
\end{lstlisting}
  As this example shows, a value can depend on other values which are
  defined previous to itself. The access modifiers \keyw{private},
  \keyw{protected} and \keyw{public} can only be used in VDM++ and VDM-RT.
  A top-level VDM-SL specification can consist of
  specifications from a number of files or modules (see
  section~\ref{modules}).  It is good practice not to let a value depend
  on values defined in other modules as the ordering is important.
\end{description}

\chapter{Declaration of Modifiable State Components}\label{chap:state}

Syntactically the definition of state components that can be modified
using VDM operations differ in VDM-SL compared with VDM++ and
VDM-RT. Since VDM-SL is module based the state definition is similar
to a monolitic record like construct. On the other hand VDM++ and
VDM-RT are object-oriented and thus state components needs to be more
flexible in order to enable inheritence of such definitions and thus
they are defined in terms of instance variables. In the two sections
in this chapter the two different ways of defining states is presented.

\section{Instance Variables (VDM++ and VDM-RT)}
\label{sec:ivars}

Both an object instantiated from a class description and the class
itself can have an internal state, also called the \emph{instance
  variables} of the object or class. In the case of objects, we also
refer to this state as the global state of the object.

\begin{description}
\item[Syntax:]
  \Rule{instance variable definitions}{
    \Lop{instance}, \Lop{variables}, \lfeed
    \OptPt{\Ruleref{instance variable definition}, \lfeed
           \SeqPt{\Lit{;},
               \Ruleref{instance variable definition}
                 }
          }
  }


  \Rule{instance variable definition}{
    \Ruleref{access assignment definition} \dsep
    \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Rule{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
  \Ruleref{expression}}
  }
\Rule{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Rule{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

\item[Semantics:] The section describing the internal state is
preceded by the keyword {\bf\ttfamily instance variables}.  A list of instance
variable definitions and/or invariant definitions follows.  Each
instance variable definition consists of an instance variable name
with its corresponding type indication and may also include an
initial value and access and \keyw{static} specifiers. Details of the
access and \keyw{static} specifiers can be found in section
\ref{ch:interface}.

It is possible to restrict the values of the instance variables by
means of invariant definitions. Each invariant definition, involving
one or more instance variables, may be defined over the values of the
instance variables of objects of a class. All instance variables in
the class including those inherited from superclasses are visible in
the invariant expression. Each invariant definition must be a
boolean expression that limits the values of the instance variables to
those where the expression is true. All invariant expressions must be
true during the entire lifetime of each object of the class.

The overall invariant expression of a class is all the invariant
definitions of the class and its superclasses combined by logical
\keyw{and} in the order that they are defined in 1) the superclasses
and 2) the class itself.

%If a class contains one or more invariant definitions, an operation named
%{\tt inv\_classname} is implicitly constructed in the class.%
%\footnote{Not yet supported by the interpreter.}
% *****Check this for next version
%This operation is private, has no parameters and returns a boolean
%corresponding to the execution of the invariant expression.

\item[Example:]

The following examples show instance variable definitions. The first
class specifies one instance variable:
  \begin{lstlisting}
class GroupPhase

types

GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>;
Team = ... -- as on page !\pageref{scoredef}!
Score::team : Team
       won    : nat
       drawn  : nat
       lost   : nat
       points : nat;

instance variables
gps : map GroupName to set of Score;
inv forall gp in set rng gps &
      (card gp = 4 and
       forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)

end GroupPhase
  \end{lstlisting}
\end{description}

\section{The State Definition (VDM-SL)}\label{statedef}

If global variables are desired in a VDM-SL specification, it is possible to make
a state definition. The components of the state definition can be
considered the collection of global variables which can be referenced
inside operations. A state in a module is initialised before any of the
operation definitions (using that state) in a module can be used by
the VDM interpreters.

\begin{description}
\item[Syntax:]
  \Rule{state definition}{
    \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
    \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{invariant}{
    \Lop{inv}, \Ruleref{invariant initial function}
    }

  \Rule{initialisation}{
    \Lop{init}, \Ruleref{invariant initial function}
    }

  \Rule{invariant initial function}{
    \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}}

\item[Semantics:] The state definition has the form:
  \begin{lstlisting}
    state ident of
      id1 : type1
      !\ldots!
      idn : typen
    inv  pat1 == invpred
    init pat2 == initpred
    end
  \end{lstlisting}
  A state identifier {\tt idn} is declared of a specific type {\tt typen}.
  The invariant {\tt invpred} is a boolean expression denoting a
  property which must hold for the state {\tt ident} at all
  times. {\tt initpred} denotes a condition which must hold initially.
  It should be noticed that in order to use the
  VDM interpreters, it is
  necessary to have an initialisation predicate (if any of the
  operations using the state are to be executed). In addition the body of
  this initialisation predicate must be a binary equality expression with
  the name (which also must be used as the pattern) of the entire state on
  the left-hand side of the equality and the right-hand side must evaluate
  to a record value of the correct type. This enables the VDM interpreters
  to evaluate the {\tt initpred} condition. A simple example of an
  initialisation predicate is shown below:

  \begin{lstlisting}
  state St of
    x: nat
    y: nat
    l: seq1 of nat
  init s == s = mk_St(0,0,[1])
  end
  \end{lstlisting}

  In the specification of both the invariant and the initial value the
  state must be manipulated as a whole, and this is done by referring to it
  as a record tagged with the state name (see the example). When a field in
  the state is manipulated in some operation, the field must however be
  referenced directly by the field name without pre-fixing it with the
  state name.

\item[Examples:] In the following example we create one state variable:
  \begin{lstlisting}
types

GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

state GroupPhase of
  gps : map GroupName to set of Score
inv mk_GroupPhase(gps) ==
  forall gp in set rng gps &
    (card gp = 4 and
    forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)
init gp ==
  gp = mk_GroupPhase({<A> |-> init_sc({<Brazil>, <Norway>,
                                      <Morocco>, <Scotland>}),
                      ...})
end

functions

init_sc : set of Team -> set of Score
init_sc (ts) ==
  { mk_Score (t,0,0,0,0) | t in set ts };
  \end{lstlisting}
  In the invariant we state that each group has four teams, and no team
  plays more than three games. Initially no team has played any games.

\end{description}

\chapter{Operation Definitions} \label{op-def}

Operations have already been mentioned in chapter~\ref{algorithm}. The
general form is described here and for VDM++ and VDM-RT special
  operations called \emph{constructors} which are used for
  constructing instances of a class are described in
  section~\ref{constructors}. Note that the \keyw{async} keyword can
only be used in the VDM-RT dialect.

\begin{description}
\item[Syntax:]
  \Rule{operation definitions}{
    \Lop{operations},
    \OptPt{\Ruleref{access operation definition}}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{access operation definition}} ,  \OptPt{\Lit{;}
    }}

    \Rule{access operation definition}{(
      \OptPt{\Lop{pure}},
      \OptPt{\Lop{async}}
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\
     (
      \OptPt{\Lop{pure}}, \OptPt{\Lop{async}}
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }

\Rule{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }

\Rule{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
  }

\Rule{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Rule{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Rule{extended explicit operation definition}{
  \Ruleref{identifier}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}

\Rule{operation type}{
  \Ruleref{discretionary type}, \Lit{{\tt ==>}}, \Ruleref{discretionary type}
  }

\Rule{discretionary type}{
  \Ruleref{type} \dsepl \Lit{()}
  }

\Rule{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Rule{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\Rule{operation body}{
  \Ruleref{statement} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!operations}
  }

\Rule{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Rule{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Rule{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{name list}{
  \Ruleref{identifier}, \SeqPt{\Lit{,}, \Ruleref{identifier}}
  }

\Rule{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Rule{error list}{
  \Ruleref{error}, \SeqPt{\Ruleref{error}}
  }

\Rule{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\item[Semantics:] Operations in VDM are by default synchronous but if
  the keyword ``\keyw{async}'' is used in VDM-RT in front of an
  operation definition it means that that operation will be treated as
  an asynchronous operation. This means that the operation cannot have
  a return type and the thread calling an asynchronous operation will
  continue its own execution after having requested the invocation of
  the asynchronous operation. Note that constructors cannot be
  declared asynchronous.

  % Pure operations
  If an operation is declared ``\keyw{pure}'' it means that it is
  executed atomically when it is called from a functional context
  (from functions, invariants, pre or post-conditions). Otherwise
  calling a pure operation is no different to calling a normal
  operation, except that a pure operation has various constraints. The
  constraints are as follows:

  \begin{itemize}
  \item A pure operation cannot update state
  \item A pure operation cannot call an impure operation
  \item A pure operation cannot have permission predicates
  \item An operation overriding a pure operation must also be pure
  \item History counters cannot be used for pure operations
  \item A mutex cannot refer to a pure operation
  \item A pure operation must return a value
  \item A pure operation cannot be declared \keyw{async} since an
    asynchronous operation is required to have \keyw{void} as return
    type.
  \item The body of a thread cannot be a pure operation
  \item It is not allowed to call \keyw{exit} in a pure operation
  \end{itemize}
  
  In both VDM++ and VDM-RT the details of the
  access and \keyw{static} specifiers can be found in section
  \ref{ch:interface}. Note that a static operation may not call
  non-static operations, and self expressions cannot be
  used in the definition of a static operation.

The following example of an explicit operation updates the VDM-SL
state \texttt{GroupPhase} and the VDM++ instance variables of class
\texttt{GroupPhase} when one team beats another.
\begin{lstlisting}
Win : Team * Team ==> ()
Win (wt,lt) ==
  let gp in set dom gps be st
       {wt,lt} subset {sc.team | sc in set gps(gp)}
  in gps := gps ++ { gp |->
                      {if sc.team = wt
                       then mu(sc, won |-> sc.won + 1,
                                   points |-> sc.points + 3)
                       elseif sc.team = lt
                       then mu(sc, lost |-> sc.lost + 1)
                       else sc
                  | sc in set gps(gp)}}
pre exists gp in set dom gps &
       {wt,lt} subset {sc.team | sc in set gps(gp)};
\end{lstlisting}
\label{winDef}
An explicit operation consists of a statement (or several composed
using a block statement), as described in chapter~\ref{sec:stmt}. The
statement may access any state/instance
variables it wishes, reading and writing to them as it sees fit.

An implicit operation is specified using an optional pre-condition,
and a mandatory post-condition. For example we could specify the
\texttt{Win} operation implicitly:
\begin{lstlisting}
Win (wt,lt: Team)
ext wr gps : map GroupName to set of Score
pre exists gp in set dom gps &
        {wt,lt} subset {sc.team | sc in set gps(gp)}
post exists gp in set dom gps &
       {wt,lt} subset {sc.team | sc in set gps(gp)}
       and gps = gps~ ++
                     { gp |->
                       {if sc.team = wt
                        then mu(sc, won |-> sc.won + 1,
                                   points |-> sc.points + 3)
                        elseif sc.team = lt
                        then mu(sc, lost |-> sc.lost + 1)
                        else sc
                   | sc in set gps(gp)}};
\end{lstlisting}

The externals field lists the state/instance
variables that the
operation will manipulate. The
state/instance
variables listed after the reserved
word \keyw{rd} can only be read whereas the operation can both read and
write the variables listed after \keyw{wr}.

In VDM-SL the presence of such pre- and post-conditions the VDM interpreters will also
create new functions as with the pre- and post-conditions of operation
definitions.  However, if a specification contains a global state, the
state is also part of the newly created functions. Thus, functions
with the following signatures are created for operations with pre-
and/or post-conditions\footnote{However, you should remember that
these pre and post condition predicates for an operation are simply
boolean functions and the state components are thus not changed by
calling such a predicate.}:
\begin{lstlisting}
  pre_Op : InType * State +> bool

  post_Op : InType * OutType * State * State +> bool
\end{lstlisting}
with the following exceptions:
\begin{itemize}
\item If the operation does not take any arguments, the {\tt InType} part
  of the signature is left out in both the {\tt \keyw{pre\_}Op} and {\tt
    \keyw{post\_}Op} signatures.

\item If the operation does not return a value, the {\tt OutType} part is
  left out in the {\tt \keyw{post\_}Op} signature.

\item If the specification does not define a state, the {\tt State} part(s)
  of both signatures are left out.
\end{itemize}

In the {\tt \keyw{post\_}Op} signature, the first {\tt State} part is for
the old state, whereas the second {\tt State} part is for the
state after the operation call.

For instance, consider the following specifications:

\begin{lstlisting}
module A

definitions

state St of
  n : nat
end

operations

Op1 (a : nat) b :nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end A
\end{lstlisting}

\begin{lstlisting}
module B

definitions

operations

Op1 (a : nat) b : nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end B
\end{lstlisting}

For \textbf{module A} we could then quote the pre and post conditions
defined in this specification as illustrated below

\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))
  & \texttt{a} bound to 1 in state \texttt{St} with \texttt{n}  bound to 2 \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & \texttt{a} bound to 1, \texttt{b} bound to 2, state before with
    \texttt{n} bound to 1, state after with \texttt{n} bound to 2 \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & \texttt{b} bound to 2, state before with \texttt{n} bound to 1, state
    after with \texttt{n} bound to 2 \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))
  & state before with \texttt{n} bound to 1, state after with
    \texttt{n} bound to 2 \\
\hline
\end{tabular}

For \textbf{module B} we can quote the pre and post conditions defined
in this specification as illustrated below

\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline
\textrm{Quote expression} & Explanation \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} bound to 1 \\
\keyw{post}\_Op1(1,2)  & \texttt{a} bound to 1, \texttt{b} bound to 2\\
\keyw{post}\_Op2(2)    & \texttt{b} bound to 2\\
\keyw{post}\_Op3()     & No binding at all\\
\hline
\end{tabular}

\vspace{2ex}


The exceptions clause can be used to describe how an operation should
deal with error situations. The rationale for having the exception
clause is to give the user the ability to separate the exceptional
cases from the normal cases. The specification using exceptions does
not give any commitment as to how exceptions are to be signalled, but
it gives the means to show under which circumstances an error
situation can occur and what the consequences are for the result of
calling the operation.

The exception clause has the form:
\begin{lstlisting}
errs COND1: c1 -> r1
     !\ldots!
     CONDn: cn -> rn
\end{lstlisting}
The condition names {\tt COND1}, \ldots, {\tt CONDn} are identifiers
that describe the kind of error which can be raised\footnote{Notice
that these names are purely of mnemonic value, i.e.\ semantically they
are not important.}. The condition expressions {\tt c1}, \ldots, {\tt
cn} can be considered as pre-conditions for the different kinds of
errors. Thus, in these expressions the identifiers from the arguments
list and the variables from the externals list can be used (they have
the same scope as the pre-condition). The result expressions {\tt r1},
\ldots, {\tt rn} can correspondingly be considered as post-conditions
for the different kinds of errors. In these expressions the result
identifier and old values of global variables (which can be written
to) can also be used. Thus, the scope corresponds to the scope of the
post-condition.

An operation definition making use of an \keyw{errs} clause
essentially gets an effective pre-condition which is a disjunction of
the original pre-condition and all the condition expressions {\tt c1},
\ldots, {\tt cn}. The effective post-condition in these cases becomes
a disjunction of the conjuncts ({\tt orig\_pre \keyw{and} orig\_post)} and
the {\tt c1 \keyw{and} r1}, \ldots, {\tt cn \keyw{and} rn}.

Superficially there appears to be some redundancy between exceptions
and pre-conditions here. However there is a conceptual distinction
between them that dictates which should be used and when. The
pre-condition specifies what callers  to the operation must ensure for
correct behaviour; the exception clauses indicate that the operation
being specified takes responsibility for error handling when an
exception condition is satisfied. Hence normally exception clauses and
pre-conditions do not overlap.

The next VDM-SL example of an operation uses the following state definition:
\begin{lstlisting}
  state qsys of
    q : Queue
  end
\end{lstlisting}

The next VDM++/VDM-RT example of an operation uses the following
instance variable definition:
\begin{lstlisting}
  instance variables
    q : Queue
\end{lstlisting}

This example shows how exceptions with an implicit definition can be used:
\begin{lstlisting}
  DEQUEUE() e: [Elem]
  ext wr q : Queue
  post q~ = [e] ^ q
  errs QUEUE_EMPTY: q = [] -> q = q~ and e = nil
\end{lstlisting}

This is a dequeue operation which uses a global variable {\tt q} of
type {\tt Queue} to get an element {\tt e} of type {\tt Elem} out of
the queue. The exceptional case here is that the queue in
which the exception clause specifies how the operation should
behave is empty.

Note that the VDM interpreters for VDM-SL models create a function here:
\begin{lstlisting}
  post_DEQUEUE: [Elem] * qsys * qsys +> bool
\end{lstlisting}

\end{description}


\section{Constructors (VDM++ and VDM-RT)}\label{constructors}

Constructors are operations that have the same name as the class in
which they are defined and which create new instances of that
class. Their return type must therefore be the same class
name, and if a return value is specified this should be \keyw{self}
though this can optionally be omitted. Finally, since a constructor is used for initialising a new instance of a class, it is not permitted to declare a constructor \keyw{static}.

Multiple constructors can be defined in a single class using
operation overloading as described in section~\ref{sec:classdep}.


\chapter{Statements}\label{sec:stmt}

In this chapter the different kind of statements will be described
one by one. Each of them will be described by means of:
\begin{itemize}
\item A syntax description in BNF.
\item An informal semantics description.
\item An example illustrating its usage.
\end{itemize}

\section{Let Statements}\label{letstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \Ruleref{let statement} \dsep
    \Ruleref{let be statement} \dsep
    \ldots
    }

  \Rule{let statement}{
    \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
    \Lop{in}, \Ruleref{statement}
    }

  \Rule{let be statement}{
    \Lop{let}, \Ruleref{multiple bind}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{local definition}{
    \Ruleref{value definition} \dsep \Ruleref{function definition}
    }

  \Rule{value definition}{
    \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
    }

  where the ``function definition'' component is described in
  chapter~\ref{functiondef}.

\item[Semantics:] The {\it let statement} and the {\it let-be-such-that
    statement} are similar to the corresponding {\it let} and {\it
    let-be-such-that expressions} except that the {\it in} part is a
  statement instead of an expression. Thus it can be explained as follows:

  A simple {\it let statement} has the form:
  \begin{lstlisting}
    let p1 = e1, !\ldots!, pn = en in s
  \end{lstlisting}
  where {\tt p1, \ldots, pn} are patterns, {\tt e1, \ldots, en} are
  expressions which match the corresponding patterns {\tt pi}, and {\tt s}
  is a statement, of any type, involving the pattern identifiers of {\tt
    p1, \ldots, pn}. It denotes the evaluation of the statement {\tt s} in
  the context in which the patterns {\tt p1, \ldots, pn} are matched
  against the corresponding expressions {\tt e1, \ldots, en}.

  More advanced let statements can also be made by using local function
  definitions. The semantics of doing that is simply that the scope of such
  locally defined functions is restricted to the body of the let statement.

  A {\it let-be-such-that statement} has the form
  \begin{lstlisting}
    let mb be st e in s
  \end{lstlisting}
  where {\tt mb} is a multi-binding of one or more patterns (mostly
  just one pattern) to a set value (or a type), {\tt
    e} is a boolean expression, and {\tt s} is a statement, involving the
  pattern identifiers of the patterns from {\tt mb}. The {\tt \keyw{be st} e}
  part is optional. The expression denotes the evaluation of the statement
  {\tt s} in the context where all the patterns from {\tt mb} has been matched
  against an element in the set (or type) from {\tt mb}\footnote{Remember
    that only the set and sequence bindings can be executed by means of the
    VDM interpreters.}.
  If the \keyw{be st}
  expression {\tt e} is present, only such bindings where {\tt e} evaluates
  to true in the matching context are used.

\item[Examples:] An example of a \keyw{let be st} statement is provided in the
  operation \texttt{GroupWinner}
from the class \texttt{GroupPhase}
  which returns the winning team in a given group:
  \begin{lstlisting}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    let sc in set gps(gp) be st
        forall sc' in set} gps(gp) \ {sc} &
          (sc.points > sc'.points) or
          (sc.points = sc'.points and sc.won > sc'.won)
    in
      return sc.team;
  \end{lstlisting}
  The companion operation \texttt{GroupRunnerUp} gives an example of a simple
  let statement as well:
  \begin{lstlisting}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    def t = GroupWinner(gp)
    in let sct = iota sc in set gps(gp) & sc.team = t
       in
         let sc in set gps(gp) \ {sct} be st
             forall sc' in set gps(gp) \ {sc,sct} &
             (sc.points > sc'.points) or
             (sc.points = sc'.points and sc.won > sc'.won)
         in
           return sc.team;
  \end{lstlisting}
  Note the use of the {\bf\ttfamily def} statement (section~\ref{defstmt})
  here; this is used rather than a {\bf\ttfamily let} statement since the
  right-hand side is an operation call, and therefore is not an
  expression.

\end{description}

\section{The Define Statement}\label{defstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{def statement} \dsep \ldots
    }

  \Rule{def statement}{
    \Lop{def},
    \Ruleref{equals definition}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{equals definition}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{equals definition}{
    \Ruleref{pattern bind}, \Lit{=},
    \Ruleref{expression}}

\item[Semantics:] A {\it define statement} has the form:
  \begin{lstlisting}
    def pb1 = e1;
        !\ldots!
        pbn = en
    in
      s
  \end{lstlisting}
  The {\it define statement} corresponds to a {\it define expression}
  except that it is also allowed to use operation calls on the right-hand
  sides. Thus, operations that change the state can also be used here, and
  if there are more than one definition they are evaluated in the order in
  which they are presented.  It denotes the evaluation of the statement
  {\tt s} in the context in which the patterns (or binds) {\tt pb1, \ldots,
    pbn} are matched against the values returned by the corresponding
  expressions or operation calls {\tt e1, \ldots, en}\footnote{If binds are
    used it simply means that the values which can match the pattern are
    further constrained by the type or set expression as it is explained in
    section~\ref{patterns}.}.

\item[Examples:] Given the following sequences:
  \begin{lstlisting}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{lstlisting}
  The operation \texttt{SecondRound}, in VDM++ from class \texttt{GroupPhase}
  returns the sequence of pairs
  representing the second round games gives an example of a \keyw{def}
  statement:
  \begin{lstlisting}
SecondRound : () ==> seq of (Team * Team)
SecondRound () ==
  def winners = { gp |-> GroupWinner(gp)
                | gp in set dom gps };
      runners_up = { gp |-> GroupRunnerUp(gp)
                   | gp in set dom gps}
  in
    return ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i)))
            | i in set {1,...,8}]);
  \end{lstlisting}

\end{description}

\section{The Block Statement} \label{dcl-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{block statement} \dsep \ldots
    }

  \Rule{block statement}{
    \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
    \Ruleref{statement}, \SeqPt{\Lit{;}, \Ruleref{statement}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl statement}{
    \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
    }

  \Rule{assignment definition}{
    \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression}}}

\item[Semantics:] The {\it block statement} corresponds to block statements
  from traditional high-level imperative
programming languages.  It enables the use of
  locally defined variables (by means of the declare statement) which can
  be modified inside the body of the block statement. It simply denotes the
  ordered execution of what the individual statements prescribe. The first
  statement in the sequence that returns a value causes the evaluation of
  the sequence statement to terminate. This value is returned as the
  value of the block statement. If none of the statements in the block
  returns a value, the evaluation of the block statement is terminated when
  the last statement in the block has been evaluated. When the block
  statement is left the values of the local variables are discharged. Thus,
  the scope of these variables is simply inside the block statement.

\item[Examples:] In the context of a VDM-SL
state definition
  \begin{lstlisting}
  state St of
    x: nat
    y: nat
    l: seq1 of nat
  end
  \end{lstlisting}
or in the context of a VDM++ instance variables
  \begin{lstlisting}
  instance variables
    x: nat;
    y: nat;
    l: seq1 of nat;
  \end{lstlisting}
\label{stdef}
  the operation \texttt{Swap} uses a block statement to swap the values of 
  variables \texttt{x} and \texttt{y}:
  \begin{lstlisting}
  Swap : () ==> ()
  Swap () ==
    (dcl temp: nat := x;
     x := y;
     y := temp
    );
  \end{lstlisting}
\end{description}

\section{The Assignment Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{general assign statement} \dsep
    \ldots
    }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
%}%
%{}

\Rule{assign statement}{
  \Ruleref{state designator}, \Lit{:=},
    \Ruleref{expression}
  }

  \Rule{state designator}{
    \Ruleref{name} \dsep
    \Ruleref{field reference} \dsep
    \Ruleref{map or sequence reference}
    }

  \Rule{field reference}{
    \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
    }


   \Rule{map or sequence reference}{
     \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
     }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{multiple assign statement}{
    \Lop{atomic},
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \OptPt{\SeqPt{\Lit{;},\Ruleref{assign statement}}}
    \Lit{)}
    }
%  }%
%{}

\item[Semantics:] The {\it assignment statement} corresponds to a
  generalisation of assignment statements from traditional high level
  programming languages. It is used to change the value of the global or
  local state. Thus, the assignment statement has side-effects on the
  state. However, in order to be able to simply change a part of the state,
  the left-hand side of the assignment can be a state designator. A state
  designator is either simply the name of a variable, a reference to
  a field of a variable, a map reference of a variable, or a sequence
  reference of a variable. In this way it is possible to change the value
  of a small component of the state. For example, if a state component is a
  map, it is possible to change a single entry in the map.

  An assignment statement has the form:
  \begin{lstlisting}
    sd := ec
  \end{lstlisting}
  where {\tt sd} is a state designator, and {\tt ec} is either an
  expression or a call of an operation. The assignment statement denotes the
  change to the given state component described at the right-hand side
  (expression or operation call). If the right-hand side is a state
  changing operation then that operation is executed (with the
  corresponding side effect) before the assignment is made.


  Multiple assignment is also possible. This has the form:
  \begin{lstlisting}
    atomic (sd1 := ec1;
            ...;
            sdN := ecN
           )
  \end{lstlisting}
  All of the expressions or operation calls on the right hand sides
  are executed or evaluated, and then the results are bound to the
  corresponding state designators. The right-hand sides are executed
  in the order given in the statement, and normal invariant processing
  and thread switching and statement durations can occur. But once all
  of the right-hand values have been obtained, they are assigned to the
  left-hand variables in one atomic step, which occurs without invariant
  checking, thread switching or extra duration. Given the types \texttt{T1,...,TN} of the respective state designators \texttt{sd1,...,sdN} it is as if the
  \keyw{atomic} statement is evaluated as follows:
  \begin{lstlisting}
    let t1 : T1 = ec1,
        ...
        tN : TN = ecN in
    (
        -- turn off invariants, threading and durations
        sd1 := t1;
        ...
        sdN := tN;
        -- turn on invariants, threading and durations
        -- and check that invariants hold.
    );
  \end{lstlisting}


\item[Examples:] The operation in the previous example (\texttt{Swap})
  illustrated normal assignment. The operation \texttt{Win\_sd}, a
  refinement of \texttt{Win} on page~\pageref{winDef} illustrates the use of
  state designators to assign to a specific map key:
  \begin{lstlisting}
Win_sd : Team * Team ==> ()
Win_sd (wt,lt) ==
  let gp in set dom gps be st
      {wt,lt} subset {sc.team | sc in set gps(gp)}
  in
    gps(gp) := { if sc.team = wt
                 then mu(sc, won |-> sc.won + 1,
                             points |-> sc.points + 3)
                 elseif sc.team = lt
                 then mu(sc, lost |-> sc.lost + 1)
                 else} sc
               | sc in set gps(gp)}
pre exists gp in set dom gps &
               {wt,lt} subset {sc.team | sc in set gps(gp)};
  \end{lstlisting}
  The operation \texttt{SelectionSort} is a state based version of the
  function \texttt{selection\_sort} on page \pageref{selectionSortdef}. It 
  demonstrates the use of state designators to modify the contents of a
  specific sequence index, using the VDM-SL
state \texttt{St} or the VDM++
instance variables
 defined on page~\pageref{stdef}.
  \begin{lstlisting}
functions

min_index : seq1 of nat -> nat
min_index(l) ==
  if len l = 1
  then 1
  else let mi = min_index(tl l)
       in if l(mi+1) < hd l
          then mi+1
          else 1

operations

SelectionSort : nat ==> ()
SelectionSort (i) ==
  if i < len l
  then (dcl temp: nat;
        dcl mi : nat := min_index(l(i,...,len l)) + i - 1;
        temp := l(mi);
        l(mi) := l(i);
        l(i) := temp;
        SelectionSort(i+1)
       );
  \end{lstlisting}

  The following VDM++ example illustrates multiple assignment.
  \begin{lstlisting}
class C

instance variables
size : nat;
l : seq of nat;
inv size = len l

operations
add1 : nat ==> ()
add1 (x) ==
( l := [x] ^ l;
  size := size + 1);

add2 : nat ==> ()
add2 (x) ==
  atomic (l := [x] ^ l;
          size := size + 1)

end C
  \end{lstlisting}
Here, in \texttt{add1} the invariant on the class's instance variables
is broken, whereas in \texttt{add2} using the multiple assignment, the
invariant is preserved.

\end{description}

\section{Conditional Statements}\label{condstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{if statement} \dsep
    \Ruleref{cases statement} \dsep \ldots
    }

  \Rule{if statement}{
    \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
    \SeqPt{\Ruleref{elseif statement}}, \OptPt{\Lop{else}, \Ruleref{statement}}
    }

  \Rule{elseif statement}{
    \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
    }

  \Rule{cases statement}{
    \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
    \Ruleref{cases statement alternatives}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
    }

  \Rule{cases statement alternatives}{
    \Ruleref{cases statement alternative}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
    }

  \Rule{cases statement alternative}{
    \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
    }

  \Rule{others statement}{
    \Lop{others}, \Lit{->}, \Ruleref{statement}
    }

\item[Semantics:] The semantics of the {\it if statement} corresponds to
  the {\it if expression} described in section~\ref{if-exp} except for the
  alternatives which are statements (and that the \keyw{else} part is
  optional)\footnote{If the \keyw{else} part is omitted
  semantically it is like using \keyw{else skip}.}.

  The semantics for the {\it cases statement} corresponds
  to the {\it cases expression} described in section~\ref{cases-exp} except
  for the alternatives which are statements.

\item[Examples:] Assuming functions \texttt{clear\_winner} and
  \texttt{winner\_by\_more\_wins} and operation \texttt{RandomElement}
  with the following signatures:
  \begin{lstlisting}
    clear_winner : set of Score -> bool
    winner_by_more_wins : set of Score -> bool
    RandomElement : set of Team ==> Team
  \end{lstlisting}
  then the operation \texttt{GroupWinner\_if} demonstrates the use of a
  nested if statement (the iota expression is presented on page
  \pageref{iotaexpr}):
  \begin{lstlisting}
GroupWinner_if : GroupName ==> Team
GroupWinner_if (gp) ==
  if clear_winner(gps(gp))
  -- return unique score in gps(gp) which has more points
  -- than any other score
  then return ((iota sc in set gps(gp) &
                 forall sc' in set gps(gp) \ {sc} &
                   sc.points > sc'.points).team)
  elseif winner_by_more_wins(gps(gp))
  -- return unique score in gps(gp) with maximal points
  -- & has won more than other scores with maximal points
  then return ((iota sc in set gps(gp) &
            forall sc' in set gps(gp) \ {sc} &
              (sc.points > sc'.points) or
              (sc.points = sc'.points and
               sc.won > sc'.won)).team)
  -- no outright winner, so choose random score
  -- from joint top scores
  else RandomElement ( {sc.team | sc in set gps(gp) &
                          forall sc' in set gps(gp) &
                          sc'.points <= sc.points} );
  \end{lstlisting}
  Alternatively, we could use a cases statement with match value patterns for
  this operation:
  \begin{lstlisting}
GroupWinner_cases : GroupName ==> Team
GroupWinner_cases (gp) ==
  cases true:
    (clear_winner(gps(gp))) ->
         return ((iota sc in set gps(gp) &
                   forall sc' in set gps(gp) \ {sc} &
                    sc.points > sc'.points).team),
    (winner_by_more_wins(gps(gp))) ->
         return ((iota sc in set gps(gp) &
                   forall sc' in set gps(gp) \ {sc} &
                     (sc.points > sc'.points) or
                     (sc.points = sc'.points and
                        sc.won > sc'.won)).team),
    others -> RandomElement ( {sc.team | sc in set gps(gp) &
                                forall sc' in set gps(gp) &
                                 sc'.points <= sc.points} )
  end;
  \end{lstlisting}

\end{description}

\section{For-Loop Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{sequence for loop} \dsep
    \Ruleref{set for loop} \dsep
    \Ruleref{index for loop} \dsep \ldots
    }

  \Rule{sequence for loop}{
    \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
    \Ruleref{expression}, \lfeed
    \Lop{do}, \Ruleref{statement}
    }\index{for loop}

  \Rule{set for loop}{
    \Lop{for}, \Lop{all}, \Ruleref{pattern},
    \Lit{\keyw{in set}}, \Ruleref{expression},\lfeed
    \Lop{do}, \Ruleref{statement}
    }

  \Rule{index for loop}{
    \Lop{for}, \Ruleref{identifier}, \Lit{$=$}, \Ruleref{expression},
    \Lop{to}, \Ruleref{expression}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{expression}}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] There are three kinds of {\it for-loop statements}. The
  for-loop using an index is known from most high-level programming
  languages. In addition, there are two for-loops for traversing sets and
  sequences. These are especially useful if access to all
  elements from a set (or sequence) is needed one by one.

  An {\it index for-loop statement} has the form:
  \begin{lstlisting}
    for id = e1 to e2 by e3 do
    s
  \end{lstlisting}
  where {\tt id} is an identifier, {\tt e1} and {\tt e2} are integer
  expressions indicating the lower and upper bounds for the loop, {\tt e3}
  is an integer expression indicating the step size, and {\tt s} is a
  statement where the identifier {\tt id} can be used. It denotes the
  evaluation of the statement {\tt s} as a sequence statement where the
  current context is extended with a binding of {\tt id}. Thus, the first
  time {\tt s} is evaluated {\tt id} is bound to the value returned from
  the evaluation of the lower bound {\tt e1} and so forth until the upper
  bound is reached i.e.\ until \texttt{s} $>$ \texttt{e2}. Note that
  {\tt e1, e2} and {\tt e3} are evaluated before entering the loop.

  A {\it set for-loop statement\/} has the form:
  \begin{lstlisting}
    for all e in set S do
    s
  \end{lstlisting}
  where {\tt S} is a set expression. The statement {\tt s} is evaluated in
  the current environment extended with a binding of e to subsequent values
  from the set {\tt S}.

  A {\it sequence for-loop statement\/} has the form:
  \begin{lstlisting}
    for e in l do
    s
  \end{lstlisting}
  where {\tt l} is a sequence expression. The statement {\tt s} is
  evaluated in the current environment extended with a binding of e to
  subsequent values from the sequence {\tt l}.

\item[Examples:] The operation \texttt{Remove} demonstrates the use of a
  \textit{sequence-for} loop to remove all occurences of a given number from a
  sequence of numbers:
  \begin{lstlisting}
  Remove : (seq of nat) * nat ==> seq of nat
  Remove (k,z) ==
  (dcl nk : seq of nat := [];
   for elem in k do
     if elem <> z
     then nk := nk^[elem];
   return nk
  );
  \end{lstlisting}
\label{removeDef}
  A \textit{set-for} loop can be exploited to return the set of winners of 
  all groups:
  \begin{lstlisting}
  GroupWinners: () ==> set of Team
  GroupWinners () ==
  (dcl winners : set of Team := {};
   for all gp in set dom gps do
     (dcl winner: Team := GroupWinner(gp);
      winners := winners union {winner}
     );
   return winners
   );
  \end{lstlisting}
  An example of a \textit{index-for} loop is the classic bubblesort
  algorithm:
  \begin{lstlisting}
  BubbleSort : seq of nat ==> seq of nat
  BubbleSort (k) ==
    (dcl sorted_list : seq of nat := k;
     for i = len k to 1 by -1 do
       for j = 1 to i-1 do
         if sorted_list(j) > sorted_list(j+1)
         then (dcl temp:nat := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     return sorted_list
     );
\end{lstlisting}
\end{description}

\section{The While-Loop Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{while loop} \dsep \ldots
    }

  \Rule{while loop}{
    \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
    }

\item[Semantics:] The semantics for the {\it while statement} corresponds
  to the while statement from traditional programming languages. The form
  of a {\it while loop\/} is:
  \begin{lstlisting}
    while e do
      s
  \end{lstlisting}
  where {\tt e} is a boolean expression and {\tt s} a statement. As long as
  the expression {\tt e} evaluates to \keyw{true} the body statement {\tt
    s} is evaluated.

\item[Examples:] The {\it while loop} can be illustrated by the following
  example which uses Newton's method to approximate the square root of
  a real number \texttt{r} within relative error \texttt{e}.
  \begin{lstlisting}
  SquareRoot : real * real ==> real
  SquareRoot (r,e) ==
    (dcl x:real := 1,
         nextx: real := r;
     while abs (x - nextx) >= e * x do
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     return nextx
    );
  \end{lstlisting}
\label{squarerootDef}
\end{description}

\section{The Nondeterministic Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{nondeterministic statement} \dsep \ldots
    }

  \Rule{nondeterministic statement}{
    \Lit{||}, \Lit{(}, \Ruleref{statement},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
    }

\item[Semantics:] The {\it nondeterministic statement} has the form:
  \begin{lstlisting}
    || (stmt1, stmt2, !\ldots!, stmtn)
  \end{lstlisting}
  and it represents the execution of the component statements {\tt
    stmti} in an arbitrary (non-deterministic)
  order. However, it
  should be noted that the component statements are not executed
  simultaneously. Notice that the VDM interpreters will use an
  underdetermined\footnote{Even though the
    user of the VDM interpreters does not know
    the order in which these statements are executed they are always
    executed in the same order unless the seed option is used.} semantics even though this construct
  is called a non-deterministic statement.

\item[Examples:] Using the VDM-SL
state definition
  \begin{lstlisting}
  state St of
    x:nat
    y:nat
    l:seq1 of nat
  end
  \end{lstlisting}
or the VDM++ instance variables
  \begin{lstlisting}
  instance variables
    x:nat;
    y:nat;
    l:seq1 of nat;
  \end{lstlisting}
  we can use the non-deterministic statement to effect a bubble sort:
  \begin{lstlisting}
  Sort: () ==> ()
  Sort () ==
    while x < y do
      ||(BubbleMin(), BubbleMax());
  \end{lstlisting}
\label{sortDef}
  Here \texttt{BubbleMin} ``bubbles'' the minimum value in the
  subsequence \texttt{l(x,...,y)} to the head of the subsequence and
  \texttt{BubbleMax} ``bubbles'' the maximum value in the subsequence
  \texttt{l(x,...,y)} to the last index in the
  subsequence. \texttt{BubbleMin} works by first iterating through the
  subsequence to find the index of the minimum value. The contents of
  this index are then swapped with the contents of the head of the
  list, \texttt{l(x)}.
  \begin{lstlisting}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (dcl z:nat := x;
     dcl m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     for i = x to y do
       if l(i) < m
       then ( m := l(i);
              z := i);
     -- move min val to index x
     (dcl temp:nat;
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{lstlisting}
\texttt{BubbleMax} operates in a similar fashion. It iterates through the
  subsequence to find the index of the maximum value, then swaps the
  contents of this index with the contents of the last element of the
  subsequence.
\begin{lstlisting}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (dcl z:nat := x;
     dcl m:nat := l(z);
     -- find max val in l(x..y)
     for i = x to y do
       if l(i) > m
       then ( m := l(i);
              z := i);
     -- move max val to index y
     (dcl temp:nat;
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{lstlisting}
\end{description}

\section{The Call Statement}
\label{call-stmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{call statement} \dsep \ldots
    }
For VDM-SL call statements are defined as:

  \Rule{call statement}{
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
    }
For VDM++ and VDM-RT call statements are defined as:

  \Rule{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},
    name, \lfeed
    \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)},
    }
  \Rule{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
   \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Rule{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Rule{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\item[Semantics:] In VDM-SL the {\it call statement} has the form:
  \begin{lstlisting}
opname(param1, param2, !\ldots!, paramn)
  \end{lstlisting}

In VDM++ and VDM-RT the {\it call statement} can additionally have the form:
  \begin{lstlisting}
object.opname(param1, param2, !\ldots!, paramn)
  \end{lstlisting}

  The {\it call statement} calls an operation, {\tt opname}, %
(in a VDM++ and VDM-RT context it can also be on a specific object, {\tt object}),
and returns the result of
  evaluating the operation. Because operations can manipulate global
  variables a {\it call statement} does not necessarily have to return
  a value as function call do.

  In VDM++ and VDM-RT if an {\emph{object designator}} is specified
  it must yield an object reference to an object of a class in which
  the operation {\tt opname} is defined, and then the operation must
  be specified as public. If no \emph{object designator} is specified
  the operation will be called in the current object. If the operation
  is defined in a superclass, it must have been defined as public or
  protected.

\item[Examples:] \mbox{}
  In VDM-SL the operation {\tt ResetStack} given below does not
  have any parameter and does not return a value whereas the operation {\tt
    PopStack} returns the top element of the stack.
  \begin{lstlisting}
    ResetStack();
    ...
    top := PopStack();
  \end{lstlisting}
  where {\tt PopStack} could be defined as:
  \begin{lstlisting}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack;
  \end{lstlisting}
  where {\tt stack} is a global variable.

  In VDM++ and VDM-RT this {\tt Stack} example can be made like:

  \begin{lstlisting}
  class Stack

  instance variables
    stack: seq of Elem := [];

  operations

    public Reset: () ==> ()
    Reset() ==
      stack := [];

    public Pop: () ==> Elem
    Pop() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack

  end Stack
  \end{lstlisting}

  In the example the operation {\tt Reset} does not have any parameters
  and does not return a value whereas the operation {\tt Pop} returns
  the top element of the stack. The stack could be used as follows:
  \begin{lstlisting}
    ( dcl stack := new Stack();
      stack.Reset();
      ....
      top := stack.Pop();
    )
  \end{lstlisting}

  Inside class {\tt Stack} the operations can be called as shown below:
  \begin{lstlisting}
    Reset();
    ....
    top := Pop();
  \end{lstlisting}

  Or using the \keyw{self}\index{self expressions} reference:
  \begin{lstlisting}
    self.Reset();
    top := self.Pop();
  \end{lstlisting}
\end{description}

\section{The Return Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{return statement} \dsep \ldots
    }

  \Rule{return statement}{
    \Lop{return}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The {\it return statement} returns the value of an
  expression inside an operation. The value is evaluated in the given
  context. If an operation does not return a value, the expression must be
  omitted. A {\it return statement\/} has the form:
  \begin{lstlisting}
    return e
  \end{lstlisting}
  or
  \begin{lstlisting}
    return
  \end{lstlisting}
  where expression {\tt e} is the return value of the operation.

\item[Examples:] In the following example {\tt OpCall} is an operation call
  whereas {\tt FunCall} is a function call. As the {\it if statement\/}
  only accepts statements in the two branches {\tt FunCall} is
  ``converted'' to a statement by using the {\it return statement}.
  \begin{lstlisting}
    if test
    then OpCall()
    else return FunCall()
  \end{lstlisting}
  For instance in VDM++, we can extend the \texttt{stack} class from the
  previous section with an operation which examines the top of the
  stack:
\begin{lstlisting}
public Top : () ==> Elem
Top() ==
  return (hd stack)
pre stack <> [];
\end{lstlisting}
\end{description}

\section{Exception Handling Statements}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{always statement} \dsep
    \Ruleref{trap statement} \dsep
    \Ruleref{recursive trap statement} \dsep
    \Ruleref{exit statement} \dsep \ldots
    }

  \Rule{always statement}{
    \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{trap statement}{
    \Lop{trap}, \Ruleref{pattern bind}, \Lop{with},
    \Ruleref{statement}, \Lop{in}, \lfeed
    \Ruleref{statement}
    }

  \Rule{recursive trap statement}{
    \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
    }

  \Rule{traps}{
    \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement} },
    \Lit{\}}
    }

  \Rule{exit statement}{
    \Lop{exit}, \OptPt{\Ruleref{expression}}
    }

\item[Semantics:] The exception handling statements are used to control
  exception errors in a specification. This means that we have to be
  able to signal an exception within a specification. This can be done with
  the {\it exit statement}, and has the form:
  \begin{lstlisting}
    exit e
  \end{lstlisting}
  or
  \begin{lstlisting}
    exit
  \end{lstlisting}
  where {\tt e} is an expression which is optional. The expression {\tt e}
  can be used to signal what kind of exception is raised.

  The {\it always statement\/} has the form:
  \begin{lstlisting}
    always s1 in
    s2
  \end{lstlisting}
  where {\tt s1} and {\tt s2} are statements. First statement {\tt s2} is
  evaluated, and regardless of any exceptions raised, statement {\tt s1} is
  also evaluated. The result value of the complete {\it always statement\/}
  is determined by the evaluation of statement {\tt s1}: if this raises an
  exception, this value is returned, otherwise the result of the evaluation
  of statement {\tt s2} is returned.

  The {\it trap statement\/} only evaluates the handler statement,
{\tt s1}, when certain conditions are fulfilled. It has the form:
\begin{lstlisting}
    trap pat with s1 in s2
\end{lstlisting}
where {\tt pat} is a pattern or bind used to select certain
exceptions, {\tt s1} and {\tt s2} are statements. First, we evaluate
statement {\tt s2}, and if no exception is raised, the result value of
the complete {\it trap statement\/} is the result of the evaluation of
{\tt s2}. If an exception is raised, the value of {\tt s2} is matched
against the pattern {\tt pat}. If there is no matching, the exception
is returned as result of the complete {\it trap statement}, otherwise,
statement {\tt s1} is evaluated and the result of this evaluation is
also the result of the complete {\it trap statement}.

  The {\it recursive trap statement\/} has the form:
  \begin{lstlisting}
    tixe {
      pat1 |-> s1,
      ...
      patn |-> sn
    } in s
  \end{lstlisting}
  where {\tt pat1, \ldots, patn} are patterns or binds, {\tt s, s1, \ldots,
    sn} are statements. First, statement {\tt s} is evaluated, and if no
  exception is raised, the result is returned as the result of the complete
  {\it recursive trap statement}. Otherwise, the value is matched in order
  against each of the patterns {\tt pati}. When a match cannot be found,
  the exception is returned as the result of the {\it recursive trap
    statement}. If a match is found, the corresponding statement {\tt
    si} is evaluated. If this does not raise an exception, the result value
  of the evaluation of {\tt si} is returned as the result of the {\it
    recursive trap statement}. Otherwise, the matching starts again, now
  with the new exception value (the result of the evaluation of {\tt si}).

\item[Examples:] In many programs, we need to allocate memory for a
  single operation. After the operation is completed, the memory is not
  needed anymore. This can be done with the {\it always statement}:
  \begin{lstlisting}
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    )
  \end{lstlisting}
  In the above example, we cannot act upon a possible exception raised
  within the body statement of the {\it always statement}. By using the
  {\it trap statement\/} we can catch these exceptions:
  \begin{lstlisting}
    trap pat with ErrorAction(pat) in
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    )
  \end{lstlisting}
  Now all exceptions raised within the {\it always statement\/} are
  captured by the {\it trap statement}. If we want to distinguish between
  several exception values, we can use either nested {\it trap
    statements\/} or the {\it recursive trap statement}:
  \begin{lstlisting}
    DoCommand : () ==> int
    DoCommand () ==
    ( dcl mem : Memory;
      always Free(mem) in
      ( mem := Allocate();
        Command(mem, !\ldots!)
      )
    );

    Example : () ==> int
    Example () ==
    tixe
    { <NOMEM> |-> return -1,
      <BUSY>  |-> DoCommand(),
      err     |-> return -2 }
    in
      DoCommand();
  \end{lstlisting}
  In operation {\tt DoCommand} we use the {\it always statement\/} in the
  allocation of memory, and all exceptions raised are captured by the {\it
    recursive trap statement\/} in operation {\tt Example}. An exception
  with value {\tt <NOMEM>} results in a return value of {\tt -1} and no
  exception raised. If the value of the exception is {\tt <BUSY>} we try to
  perform the operation {\tt DoCommand} again. If this raises an exception,
  this is also handled by the {\it recursive trap statement}. All other
  exceptions result in the return of the value {\tt -2}.
\end{description}

\section{The Error Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{error statement} \dsep
    \ldots
    }

  \Rule{error statement}{
    \Lop{error}
    }

\item[Semantics:] The {\it error statement} corresponds to the
undefined expression. It is used to state explicitly that the result
of a statement is undefined and because of this an error has occurred.
When an {\it error statement} is evaluated the
VDM interpreters will
terminate the execution of the specification and report that an {\it
error statement} was evaluated.

  Pragmatically use of error statements differs from
  pre-conditions as was the case with undefined expressions: use of a
  pre-condition means it is the caller's
  responsibility to ensure that the pre-condition is satisfied when
  the operation is called; if an error statement is used it is the
  called operation's responsibility to deal with error handling.


\item[Examples:] The operation \texttt{SquareRoot} on page
  \pageref{squarerootDef} does not exclude
  the possibility that the number to be square rooted might be
  negative. If we do not wish this to be a pre-condition we can
remedy this in the operation \texttt{SquareRootErr}:
  \begin{lstlisting}
  SquareRootErr : real * real ==> real
  SquareRootErr (r,e) ==
    if r < 0
    then error
    else
      (dcl x:real := 1;
       dcl nextx:real := r;
       while abs (x - nextx) >= e * x do
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       return nextx
      );
  \end{lstlisting}
\end{description}

\section{The Identity Statement}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{identity statement}
    }

  \Rule{identity statement}{
    \Lop{skip}
    }

\item[Semantics:] The {\it identity statement\/} is used to signal that no
  evaluation takes place.

\item[Examples:] In the operation \texttt{Remove} in section
  \ref{removeDef} the behaviour of the operation within the
  \keyw{for} loop if \texttt{elem=z} is not explicitly
  stated. \texttt{Remove2} below does this.
  \begin{lstlisting}
  Remove2 : (seq of nat) * nat ==> seq of nat
  Remove2 (k,z) ==
    (dcl nk : seq of nat := [];
     for elem in k do
       if elem <> z
       then nk := nk^[elem]
       else skip;
     return nk
    );
  \end{lstlisting}
  Here, we explicitly included the \keyw{else}-branch to illustrate the
  {\it identity statement}, however, in most cases the \keyw{else}-branch
  will not be included and the {\it identity statement\/} is implicitly
  assumed.

\end{description}

\section{Start and Start List Statements (VDM++ and VDM-RT)}\label{sec:start}
\label{sc:startstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{start statement} \dsep
    \Ruleref{start list statement}
    }

  \Rule{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

  \Rule{start list statement}{
    \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The {\it start} and {\it start list} statements have
the form:
  \begin{lstlisting}
    start(aRef)
    startlist(aRef_s)
  \end{lstlisting}

If a class description includes a thread (see
chapter~\ref{ch:thread}), each object created from this class will
have the ability to operate as a stand-alone virtual machine, or in
other terms: the object has its own processing capability.  In this
situation, a {\it new expression} creates the `process' leaving it in
a waiting state.  For such objects VDM++ and VDM-RT has a mechanism to change
the waiting state into an active state\footnote{When an object is in
an active state, its behaviour can be described using a thread (see
chapter~\ref{ch:thread}).}  in terms of a predefined operation, which
can be invoked through a {\it start statement}.

The explicit separation of object creation and start provides the
possibility to complete the initialisation of a (concurrent) system
{\it before} the objects start exhibiting their described behaviour,
in this way avoiding problems that may arise when objects are referred
to that are not yet created and/or connected.

A syntactic variant of the start statement is available to start up a
number of active objects in arbitrary order: the {\it start list
statement}. The parameter {\tt aRef\_s} to \keyw{startlist} must be a
set of object references to objects instantiated from classes
containing a thread.

\item[Examples:]
Consider the specification of an operating system. A component of this
would be the daemons and other processes started up during the boot
sequence. From this perspective, the following definitions are
relevant:
\begin{lstlisting}
  types

    runLevel = nat;

    Process = Kerneld | Ftpd | Syslogd | Lpd | Httpd

  instance variables
    pInit : map runLevel to set of Process
\end{lstlisting}
where \texttt{Kerneld} is an object reference type specified
elsewhere, and similarly for the other processes listed.

We can then model the boot sequence as an operation:
\begin{lstlisting}
bootSequence : runLevel ==> ()
bootSequence(rl) ==
  for all p in set pInit(rl) do
    start(p);
\end{lstlisting}
Alternatively we could use the \keyw{startlist} statement here:
\begin{lstlisting}
bootSequenceList : runLevel ==> ()
bootSequenceList(rl) ==
  startlist(pInit(rl));
\end{lstlisting}
\end{description}

\section{Stop and Stop List Statements (VDM++ and VDM-RT)}\label{sec:stop}
\label{sc:stopstmt}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{stop statement} \dsep
    \Ruleref{stop list statement}
    }

  \Rule{stop statement}{
    \Lop{stop}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

  \Rule{stop list statement}{
    \Lop{stoplist}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\item[Semantics:] The {\it stop} and {\it stop list} statements have the following form:
  \begin{lstlisting}
    stop(aRef)
    stoplist(aRef_s)
  \end{lstlisting}
\end{description}

The stop statement can be used to terminate a thread or to prevent a periodic thread from being invoked again, whereby a thread is identified by the object reference \emph{aRef}. The stop list statement is available to stop a number of active objects, in arbitrary order. The parameter {\tt aRef\_s} to \keyw{stoplist} must be a set of object references. A few additional remarks can be made:

\begin{enumerate}
\item \Lop{self} can be passed as an argument to \texttt{stop} or \texttt{stoplist}, effectively killing the current thread
\item Note that \emph{thread identifiers} can \emph{not} be passed as an argument
\item in contrast to \texttt{start} and \texttt{startlist}, \texttt{stop} and \texttt{stoplist} will block until the thread(s), identified by their object identifiers that are passed as an argument, are dead; if \Lop{self} is part of the set, it will be stopped last
\item passing the object identifier of a task that has never been started or is already dead, will yield a run-time error
\item  objects can be restarted by calling \texttt{start} and \texttt{startlist} again, which will create a fresh and unique \emph{thread identifier} for each thread.
\item it is only possible to stop threads that are running on the same CPU
\end{enumerate}

\section{The Specification Statement} \label{se:specification}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{specification statement}
    }
  \Rule{specification statement}{
    \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }

\item[Semantics:]

The specification statement can be used to describe a desired effect a
statement in terms of a pre- and a post-condition. Thus, it captures
the abstraction of a statement, permitting it to have an abstract
(implicit) specification without being forced to an operation
definition. The specification statement is equivalent with the body of
an implicitly defined operation (see chapter~\ref{op-def}). Thus
specification statements can not be executed.

\item[Examples:] We can use a specification statement to specify a
  bubble maximum part of a bubble sort:
\begin{lstlisting}
Sort2 : () ==> ()
Sort2 () ==
  while x < y do
    || (BubbleMin(),
        [ext wr l : seq1 of nat
             wr y : nat
             rd x : nat
         pre x < y
         post y < y~ and
              permutation(l~(x,...,y~),l(x,...,y~)) and
              forall i in set {x,...,y} & l(i) < l(y~)]
       );
\end{lstlisting}
  (\texttt{permutation} is an auxiliary function taking two sequences
  which returns true iff one sequence is a permutation of the other.)


\end{description}

\section{The Duration Statement (VDM-RT)}
\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{duration statement}
  }
  \Rule{duration statement}{
    \Lop{duration}, \Lit{(}, \Ruleref{expression}, \Lit{)},
    \Ruleref{statement}
  }

\item[Semantics:]
The duration statement is a runtime directive to the VDM
interpreters telling it that when incrementing the internal clock for the
enclosed statement, the value (an expression that must yield a natural number as its return type, otherwise causing a run-time error)
given in the duration statement should
be used instead of the increment which would normally be computed for that
statement. Thus the duration statement provides a mechanism to
override the VDM interpreter's default execution time computation. Note that the execution
of the expression is done in zero time and cannot cause thread switches.


\item[Example:] First a simple example:
\begin{lstlisting}
  while n < 10 do
    duration(10) n := n + 1;
\end{lstlisting}
In this example, assuming that this loop is not executed in the
context of an enclosing duration statement, on each iteration of the
loop the VDM interpreters will increment its internal clock by 10 time
units (nanoseconds),
rather than computing the amount of time required to execute the
statement \texttt{n := n + 1}.

If duration statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{lstlisting}
  duration(30)
  ( n := 1;
    while n < 10 do
      duration(10) n := n + 1;
  )
\end{lstlisting}
The outer duration statement takes precedence, so assuming this is not
executed in the context of an enclosing duration statement, the
VDM interpreters would increment its internal clock by 30 time units when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{lstlisting}
op1 : nat ==> nat
op1(m) ==
  duration (20) return m + 1;

op2 : () ==> nat
op2() ==
( dcl n : nat := 3;
  duration(10)  n := op1(1);
  return n);
\end{lstlisting}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the duration statement in \texttt{op1} will be overridden by
the duration statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement
\texttt{n := op1(1);} the internal clock is incremented by 10 time units
only.

\begin{lstlisting}
  ( n := 1; while n < 10 do duration(n) n := n + 1 )
\end{lstlisting}

The final example demonstrates the use of a general expression as the argument to the duration statement, whereby the consecutive executions of the body of the while loop take more time as $n$ increases.

\end{description}

\section{The Cycles Statement (VDM-RT)}

\begin{description}
\item[Syntax:]
  \Rule{statement}{
    \ldots \dsep
    \Ruleref{cycles statement}
  }
  \Rule{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{expression}, \Lit{)},
    \Ruleref{statement}
  }

\item[Semantics:]
The cycles statement is a runtime directive to the VDM interpreters
telling it that when incrementing the internal clock for the enclosed
statement, the value (an expression that must yield a natural number as its return type, otherwise causing a run-time error)
given in the cycles statement should be used as
an indication of how many clock cycles that the enclosed statement
should be incremented by instead of the increment which would normally
be computed for that statement. Thus the cycles statement provides a
mechanism to override the VDM interpreter's default execution time
computation similar to the duration statement but in a way that is
relative to the speed of the \texttt{CPU} that the computation is carried
out on. Note that the execution
of the expression is done in zero time and cannot cause thread switches.

\item[Example:] First a simple example:
\begin{lstlisting}
  while n < 10 do
    cycles(1000) n := n + 1;
\end{lstlisting}
In this example, assuming that this loop is not executed in the
context of an enclosing cycles statement, on each iteration of the
loop the VDM interpreters will increment its internal clock by the time it will
take to process 1000 instructions on the given \texttt{CPU} (relative
to its capacity), rather than computing the amount of time required to
execute the statement \texttt{n := n + 1}.

If cycles statements are nested, the outermost one takes precedence
and the remainder are ignored. For instance
\begin{lstlisting}
  cycles(3000)(
        n := 1;
        while n < 10 do
           cycles(1000) n := n + 1;
        )
\end{lstlisting}
The outer cycles statement takes precedence, so assuming this is not
executed in the context of an enclosing cycles statement, the
interpreter would increment its internal clock by the time it takes to
process 3000 instructions on the given \texttt{CPU} when
executing this statement.

Note that nesting can occur due to operation calls. Consider the
following example:
\begin{lstlisting}
      op1 : nat ==> nat
      op1(m) ==
        cycles (2000) return m + 1;

      op2 : () ==> nat
      op2() ==
      (dcl n : nat := 3;
       cycles(1000)  n := op1(1);
       return n)
\end{lstlisting}
When executing \texttt{op2}, if the call to \texttt{op1} is
executed, the cycles statement in \texttt{op1} will be overridden by
the cycles statement in the environment of the call. Thus in
\texttt{op2} following execution of the statement
\texttt{n := op1(1);} the internal clock is incremented by the time
it takes to process 1000 instructions on the given \texttt{CPU}
only.

\begin{lstlisting}
  ( n := 1; while n < 10 do cycles(n) n := n + 1 )
\end{lstlisting}

The final example demonstrates the use of a general expression as the argument to the cycles statement, whereby the consecutive executions of the body of the while loop take more time as $n$ increases.

\end{description}


\chapter{Top-level Specification in VDM}
\label{top-level}

The top-level specification structure differs significantly between
the VDM-SL approach and the VDM++ and VDM-RT approach. In VDM-SL the
ISO standard prescribes a flat-language but here a modular extension
is also enabled using imports and exports primitives. In VDM++ and
VDM-RT structuring is done using object-oriented classes that can
inherit constructs between them controlled by access modifiers. These
two different approaches are explained in the two sections in this
chapter.

\section{Top-level Specification in VDM-SL}\label{modules}

In the previous chapters all the  VDM-SL constructs such as types,
expressions, statements, functions and operations have been described. A
number of these constructs can constitute a top-level  VDM-SL
specification. A top-level specification can be created in two ways:
\begin{enumerate}
\item The specification is split into a number of modules which are
  specified separately, but can depend on each other.
\item The specification is specified in a flat manner, i.e.\ no modules are
  used (note that in VDM-10 it is possible to have access to standard
  modules also from a flat VDM-SL specification).
\end{enumerate}
Thus, a complete specification, or document, has the following syntax.

\begin{description}
\item[Syntax:]
\Rule{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{any module}{
  \Ruleref{module}
%\dsep
%  \Ruleref{dynamic link module}
  }
\end{description}

\subsection{A Flat Specification}\label{flat}

As said, a flat specification does not use modules. This means that all
constructs can be used throughout the specification. In the flat case, a
document has a syntax of:

\Rule{document}{\ldots \dsep
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{traces definitions}
  }

Thus, a flat specification is made up of several {\it definition\/} blocks.
However, only one state definition is allowed. The following is an example
of a flat top-level specification:

\begin{lstlisting}
values

  st1 = mk_St([3,2,-9,11,5,3])

state St of
  list:seq1 of nat
end

functions

  min_index : seq1 of nat -> nat
  min_index(plist) ==
    if len plist = 1
    then 1
    else let mi = min_index(tl plist)
         in
           if plist(mi+1) < hd plist
           then mi+1
           else 1

operations

  SelectionSort : nat ==> ()
  SelectionSort (i) ==
    if i < len list
    then (dcl temp: nat;
          dcl mi : nat := min_index(l(i,...,len list)) + i - 1;

          temp := list(mi);
          list(mi) := list(i);
          list(i) := temp;
          SelectionSort(i+1)
         );
\end{lstlisting}

\subsection{A Structured Specification}

As an extension to the standard VDM-SL language, it is possible to
structure an  VDM-SL specification using modules. In this section,
the use of modules to create the top-level specification will be described.
With the structuring facilities offered by  VDM-SL it is possible to:
\begin{itemize}
\item Export constructs from a module.
\item Import constructs from a module.
\item Rename constructs upon import.
\item Define a state in a module.
\end{itemize}

%In addition to these kinds of ordinary modules it is possible to use
%so-called ``Dynamic Link Modules'' (see section~\ref{sec:DLmodules}).

\subsubsection{The Layout of a Module}

Before the actual facilities are described, the general layout of a
module is described. A module consists of three parts: a {\it module
declaration}, an {\it interface section}, and a {\it definitions
section}. It is possible to leave out the definitions part in the
early development of a module specification.

In the module declaration, the module is named. The name must be a
unique module name within the complete specification. The second
part, the interface section, defines the relation of a module with other
modules and consists of two sections. These sections are:
\begin{itemize}

\item An {\it imports section}. In the imports section, all the
  constructs that are going to be used from other modules are
  described. If constructs are going to be renamed it has to be done
  in the imports section.

\item An {\it exports section}. Here all the constructs that are going
  to be used in other modules are defined.
  If no exports section is present the
  module cannot be used from any other modules.
\end{itemize}
The third part of a module declaration, the
definitions section, contains all the definitions of the module.
Thus, in general, the syntax of a module is:


\begin{description}
\item[Syntax:]
\Rule{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

  \Rule{module body}{
    \Lop{definitions}, \Ruleref{definition block}, \SeqPt{definition block}
  }
\end{description}

%To illustrate the use of modules, the example flat top-level
%specification are rewritten with some minor modifications.  Some
%unimportant parts of the flat specification are left out for clarity.
Note that the identifier after \keyw{module} and \keyw{end} should be identical.

\subsubsection{The Exports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{export definition}{
    \Lop{exports}, \Ruleref{export module signature}
    }

  \Rule{export module signature}{
    \Lop{all} \dsep
    \Ruleref{export signature}, \lfeed
    \SeqPt{\Ruleref{export signature}}
    }

  \Rule{export signature}{
    \Ruleref{export types signature} \dsep
    \Ruleref{export values signature} \dsep
    \Ruleref{export functions signature} \dsep
    \Ruleref{export operations signature}
%    \dsep
%    state signature
    }

  \Rule{export types signature}{
    \Lop{types}, \Ruleref{type export}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
    }

  \Rule{type export}{
    \OptPt{\Lop{struct}}, \Ruleref{name}
    }

  \Rule{export values signature}{
    \Lop{values}, \Ruleref{value signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
    }

  \Rule{value signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{type}
    }

  \Rule{export functions signature}{
    \Lop{functions} \Ruleref{function signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
    }

  \Rule{function signature}{
    \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:}, \lfeed
    \Ruleref{function type}
    }

  \Rule{export operations signature}{
    \Lop{operations} \Ruleref{operation signature}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
    }

  \Rule{operation signature}{
    \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
    }

%  \Rule{state signature}{
%    \Lop{state}, name, \SeqPt{\Lit{,}, name}
%    }

\item[Semantics:] The exports section must be used to make constructs
  visible to other modules. Some or all of the defined
  constructs from a module can be exported. In the latter case, the keyword
  \keyw{all} is used. However, imported constructs are not exported
  from the module. If only part
  of the constructs are exported, the visible constructs with
  the appropriate signatures are stated.

  Normally, if a construct is visible to another module,
  that construct can be considered
   to be defined inside the module. However, with types and
  operations there are some exceptions:
  \begin{description}
  \item[Types:] If a type {\tt T} is defined in module {\tt A} and
    this type is also going to be used in module {\tt B}, the type
    from module {\tt A} has to be exported. This can be done in two ways:
    \begin{enumerate}
    \item The name of the type is exported.
    \item The structure of the type is exported.
    \end{enumerate}
    If only the name of the type is exported, the other module cannot create
    values of type {\tt T}. This means that the exporting module ({\tt A})
    must provide functions and/or operations to directly create and manipulate
    values of type {\tt T} by means of the constructors related to the
    representation of {\tt T}.

    If we export the structure of the type by using the keyword
    \keyw{struct}, the other module can create and manipulate values of
    type {\tt T} (it can also use the \keyw{mk\_} keyword and the
    \keyw{is\_} keyword for this type if it is a record type).

    If the type also defines an invariant, the invariant predicate function
    is only exported if the structure of the type is exported.

  \item[Operations:] In a module, a state that is global for
    the module can be defined. All operations within the module can
    manipulate that state. If operations are exported from a module, they
     manipulate the state in the exporting module,
      i.e.\ the state in the module where they are defined.
  \end{description}

  If an exported function or an operation defines a pre- and/or
  post-condition, the corresponding predicate functions (see
  chapter~\ref{functiondef}) are also exported.

\item[Examples:] Consider a model of a bank account. An account is
characterised by the name of the holder, the account number, the
bank branch at which the account is maintained, the balance, and an
encrypted PIN code for the ATM card. We might model this as follows:
\begin{lstlisting}
module BankAccount

exports types digit; account
        functions digval: digit -> nat;
                  deposit: account * real -> account;
                  withdrawal: account * real -> account;
                  isPin: account * nat -> bool;
                  requestWithdrawal: account * nat -> bool
definitions

types

  digit = nat
  inv d == d < 10;

  account::  holder : seq1 of char
             number : seq1 of digit
             branchcode : seq1 of digit
             balance: real
             epin: nat
  inv mk_account(holder, number, branchcode,-,-) ==
    len number = 8 and len branchcode = 6

functions

    digval : digit -> nat
    digval(d) == d;

    deposit: account * real -> account
    deposit(acc,r) ==
      mu(acc,balance |-> acc.balance + r);

    withdrawal : account * real -> account
    withdrawal (acc,r) ==
      mu(acc,balance |-> acc.balance - r);

    isPin : account * nat -> bool
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * nat -> bool
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

end BankAccount
\end{lstlisting}
In this module we export two types and five functions. Note that since
we have enumerated the entities we are exporting, but have not
exported \texttt{digit} or \texttt{account} using the \keyw{struct}
keyword, the internals of \texttt{account} values may not be accessed
by other modules, neither may the invariant for \texttt{digit}. If
such access is necessary, the types should be exported with the
\keyw{struct} keyword, or all constructs in the module should be
exported using the \keyw{exports all} clause.

The module \texttt{Keypad} given below models the keypad interface of
an ATM machine. The state variable maintains a buffer of data typed at
the keypad by the user.

\begin{lstlisting}
module Keypad

imports
from BankAccount types digit

exports all

definitions

state buffer of
  data : seq of BankAccount`digit
end

operations

    DataAvailable : () ==> bool
    DataAvailable () ==
      return(data <> []);

    ReadData : () ==> seq of BankAccount`digit
    ReadData () ==
      return (data);

    WriteData : seq of BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

end Keypad
\end{lstlisting}
In this module all constructs are exported. Since the only entities
defined are the state and operations on it, this means that all of the
operations may be accessed by an importing module. The state is not
accessible to importing modules, but remains private to this
module. However the state constructor
\texttt{\keyw{mk\_}Keypad`buffer} is accessible.


\end{description}

\subsubsection{The Imports Section}

\begin{description}
\item[Syntax:]
  \Rule{interface}{
    \OptPt{\Ruleref{import definition list}}, \lfeed
    \Ruleref{export definition}
    }

  \Rule{import definition list}{
    \Lop{imports}, \Ruleref{import definition}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{import definition}}
    }

  \Rule{import definition}{
    \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
    }

  \Rule{import module signature}{
    \Lop{all} \dsep
    \Ruleref{import signature}, \lfeed
    \SeqPt{\Ruleref{import signature}}
    }

  \Rule{import signature}{
    \Ruleref{import types signature} \dsep
    \Ruleref{import values signature} \dsep
    \Ruleref{import functions signature} \dsep
    \Ruleref{import operations signature}
%    \dsep
%    state signature
    }

  \Rule{import types signature}{
    \Lop{types}, \Ruleref{type import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
    }

  \Rule{type import}{
    \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
    \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import values signature}{
    \Lop{values}, \Ruleref{value import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
    }

  \Rule{value import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import functions signature}{
    \Lop{functions}, \Ruleref{function import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
    }

  \Rule{function import}{
    \Ruleref{name}, \OptPt{\OptPt{\Ruleref{type variable list}},
    \Lit{:}, \Ruleref{function type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

  \Rule{import operations signature}{
    \Lop{operations}, \Ruleref{operation import}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
    }

  \Rule{operation import}{
    \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{name}}
    }

\item[Semantics:] The imports section is used to state what constructs are
  used from other modules with the restriction that only visible constructs
  can be imported. If all the visible constructs from a
  module are going to be used, the keyword \keyw{all} is used, unless one or
  more constructs are going to be renamed. With renaming, an imported
  construct is given a new name
  which can be used instead of the original name preceded by the
  exporting module name. In general this has the form:
  \begin{lstlisting}
    name renamed new_name
  \end{lstlisting}
  where {\tt name} is the name of the imported construct, and {\tt
    new\_name} is the new name for the construct. This way,
  more meaningful names can be given to constructs. Note that in the importing
  module it is not possible to refer to {\tt DefModule`name} (where
  {\tt DefModule} is the name of the defining module) any longer but only to
  {\tt newname}.

  It is possible to include type information in the imports section,
such that
  this information will only be used by the static semantics check of the
  complete module. If no type information is given, the static semantics
  can also find this information in the exporting module.

 A module that imports a type may only access the internal structure of that type if it was exported with the \keyw{struct} keyword; this includes invoking the type constructor and using the selector functions. If the type was exported without the \keyw{struct} keyword then the importing module may refer to the type, and call functions from the imported module that create elements of the type, but it cannot invoke the type constructor, or use the selector functions.

When a composite type is exported with struct then its constructor is referred to, in the importing module, by \keyw{mk\_}{\tt ExportingMod`RecordName}. If the composite type is renamed on import, to {\tt ImportedRecName} say, then the constructor is referred to by \keyw{mk\_}{\tt ImportedRecName}.

\item[Examples:] We can model an ATM card as consisting of a
card number and an expiry date. This requires the \texttt{digit} type
defined in the module \texttt{BankAccount}. It also uses the function
\texttt{digval} from the same module.
\begin{lstlisting}
module ATMCard

imports
from BankAccount types digit
                 functions digval renamed atmc_digval

exports all

definitions

types

    digit = BankAccount`digit

    atmc:: cardnumber : seq1 of digit
           expiry : digit * digit * digit * digit
    inv mk_atmc(cardnumber, mk_(m1,m2,-,-)) ==
        let m = atmc_digval(m1) * 10 + atmc_digval(m2) 
        in m > 0 and m <= 12 and len cardnumber >= 8

functions

    getCardnumber : atmc -> seq1 of digit
    getCardnumber (atmc) ==
      atmc.cardnumber

end ATMCard
\end{lstlisting}
Here the invariant on the type \texttt{atmc} states that expiry dates
must represent valid dates, and card numbers must be at least 8 digits
long. Note that since \texttt{digit} is not exported with the
\keyw{struct} keyword from the module \texttt{BankAccount}, we cannot
access the invariant for \texttt{digit} in module
\texttt{ATMCard}. This notwithstanding, all values of type
\texttt{digit} manipulated in \texttt{ATMCard} must satisfy the
invariant.

\end{description}

\section{Top-level Specification in VDM++ and VDM-RT}

In the previous chapters VDM constructs such as types,
expressions, statements, functions and operations have been
described. A number of these constructs can constitute the definitions
inside a class definition. A top-level specification, or document, is
composed of one or more class definitions. Note that only in VDM-RT it
is possible to have a \keyw{system} class.

\begin{description}
\item[Syntax:]
\Rule{document}{
   \Ruleref{class}
   \dsepl\ \Ruleref{system}
   ,\SeqPt{\Ruleref{class}
   \dsepl\ \Ruleref{system}
         }
  }
\end{description}

\section{System (VDM-RT) }\label{sec:system}

In order to be able to describe distributed systems VDM-RT includes
a notion of a system that describes how different parts of the system
modelled are deployed to different Core Processing Units (CPUs) and
communication busses connecting the CPUs together. Syntactically the
system is described exactly like ordinary classes described below in
Section~\ref{sec:classdep}, except that the keyword ``\keyw{system}''
instead of the keyword ``\keyw{class}'' is used.

\begin{description}
\item[Syntax:]
\Rule{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions}
}

\item[Semantics:] Each system description has the following parts:
\begin{itemize}
\item A system header with the system name.
\item An optional {\em system body}.
\item A system tail.
\end{itemize}

The system name as given in the system header is the defining occurrence
of the name of the class. A system name is globally visible, i.e.\ visible
in all other classes/systems in the specification.

The system name in the class header must be the same as the system
name in the system tail.  Furthermore, defining system names must be unique
throughout the specification.

The special thing about the system is that it can make use of special
implicitly defined classes called \texttt{CPU} and \texttt{BUS}. It is
not possible to create instances of the system, but instances made of
\texttt{CPU} and \texttt{BUS} will be created at initialisation time.
Note that \texttt{CPU} and \texttt{BUS} cannot be used outside the
system definition.

The instances of \texttt{CPU} and \texttt{BUS} must be made as instance
variables and the definition must use constructors. The constructor for the
\texttt{CPU} class takes two parameters: the first one indicates the
primary scheduling policy used for the \texttt{CPU} whereas the second
parameter provides the capacity of the \texttt{CPU} (indicated as number of 
instructions Per Second or Hz -- NB. the (time unit) step size of time is 1 nanosecond).
The constructor for the \texttt{BUS}
class takes three parameters. The first one indicates the kind of bus, the
second one the capacity of the bus (its band width in bytes per second) and finally the third
parameter gives a set of \texttt{CPU} instances connected together by the
given \texttt{BUS} instance.

The currently supported primary scheduling policies for the \texttt{CPU}
are:
\begin{description}
\item[\texttt{<FP>}:] Fixed Priority
\item[\texttt{<FCFS>}:] First Come First Served
\end{description}

The currently supported primary scheduling policy for the \texttt{BUS}
is:
\begin{description}
%\item[\texttt{<TDMA>}:] Time Division Multiple Access
\item[\texttt{<FCFS>}:] First Come First Served
%\item[\texttt{<CSMACD>}:] Carrier Sense Multiple Access with Collision
%                          Detection
\end{description}

The \texttt{CPU} class has member operations called \texttt{deploy} and
\texttt{setPriority}. The \texttt{deploy} operation takes one
significant parameter
which must be an object that is declared as a static instance variable
inside the system\footnote{It is also allowed to take a string as a
second parameter for future extensions but that is ignored at the
moment.}. The semantics of the deploy operation is that execution
of all functionality inside this object will take place on the CPU that it
has been deployed to. The \texttt{setPriority} operation takes two
parameters where the first must be the name of a public operation that
has been deployed to the CPU and the second parameter is a natural number.
The semantics of the \texttt{setPriority} operation is that the given
operation is assigned the given priority (the second parameter). This will
be used when fixed priority scheduling is used on the given CPU. Per
default operations that are not explicitly assigned a priority using
the \texttt{setPriority} operation are assigned a default priority of 1.

The system ``class'' is limited in the way that it can only contain:
\begin{description}
\item[Instance variables:] The only instances that can be declared in the 
system ``class'' is of the special classes \texttt{CPU} and \texttt{BUS} 
as well as static instances of the different system components that one
wishes to allocate to different CPU's.
\item[Constructor:] The actual deployment of instances to CPU's and setting
of priorities for the different operations is set inside the
constructor which is the only operation that can be placed in the
system ``class''. The only kind of statement that can be used inside
this constructor is a block statement with a sequence of invocations
of the special \texttt{deploy} and \texttt{setPriority} operations.
\end{description}

In addition there are limitations with respect to the use of static
declarations for instances that are deployed to different
CPU's. Basically the user should ensure that only one instance is
deployed to a CPU if the class the instance comes from contains any
static operations or functions. In case a static instance variable is
used it is accessed directly (without any communication over the
busses), so this in essence not proper from a distribution
standpoint. Thus, all instance variables of instances to be deployed
should only be accessed through the use of operations.

\item[Example:] The system class could for example be defined as:
\begin{lstlisting}
system Simple

instance variables
  static public a : A := new A();
  static public b : B := new B();
  -- define the first CPU with fixed priority scheduling
  -- and 22E6 Hz
  CPU1 : CPU := new CPU (<FP>, 22E6);

  static public c : C := new C();
  -- define the second CPU with fixed priority scheduling
  -- and 11E6 Hz
  CPU2 : CPU := new CPU (<FP>, 11E6);

  -- create a communication bus that links the three
  -- CPU's together
  BUS1 : BUS := new BUS (<CSMACD>, 72E3, {CPU1, CPU2})

operations
  public Simple: () ==> Simple
  Simple () ==
    ( -- deploy a on CPU1
      CPU1.deploy(a);
      -- deploy b on CPU1
      CPU1.deploy(b);
      -- deploy c on CPU2
      CPU2.deploy(c,"CT");
      -- "CT" is a label here which is ignored
    );

end Simple
\end{lstlisting}
\noindent where \texttt{A}, \texttt{B} and \texttt{C} all are defined
as classes.
\end{description}

\subsection{Classes}
\label{sec:classdep}

Compared to the standard VDM-SL\ language, VDM++ and VDM-RT have been
extended with classes. In this section, the use of classes to create
and structure a top-level specification will be described. With the
object oriented facilities offered by VDM++ and VDM-RT it is possible to:

\begin{itemize}
\item Define classes and create objects.
\item Define associations and create links between objects.
\item Make generalisation and specialisation through inheritance.
\item Describe the functional behaviour of the objects using functions
  and operations.
\item Describe the dynamic behaviour of the system through threads and
  synchronisation constraints.
\end{itemize}

Before the actual facilities are described, the general layout of a
class is described.

\begin{description}
\item[Syntax:]
\Rule{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}
\Rule{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \Lit{,}, \SeqPt{\Ruleref{identifier}}
}
\Rule{class body}{\Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
}
\Rule{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions} \dsep
  \Ruleref{instance variable definitions} \dsep
%  time variable definitions \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions} \dsep
  \Ruleref{traces definitions}
}

\item[Semantics:] Each class description has the following parts:
\begin{itemize}
\item A class header with the class name and an optional
  {\em inheritance clause}.
\item An optional {\em class body}.
\item A class tail.
\end{itemize}

The class name as given in the class header is the defining occurrence
of the name of the class. A class name is globally visible, i.e. visible
in all other classes in the specification.

The class name in the class header must be the same as the class
name in the class tail.  Furthermore, defining class names must be unique
throughout the specification.

The (optional) class body may consist of:
\begin{itemize}
\item A set of {\it value definitions} (constants).
\item A set of {\it type definitions}.
\item A set of {\it function definitions}.
\item A set of {\it instance variable definitions} describing
  the internal state of an object instantiated from the
  class. State invariant expressions are encouraged but are not mandatory.
%\item A set of {\em time variable definitions} describing
%  the internal state of an object as a function of time.
\item A set of {\it operation definitions} that can act on the internal state.
\item A set of the {\it synchronization definitions}, specified either
  in terms of permission predicates or using mutex constraints.
% or in terms of traces.
%  Each trace represents an allowed sequence of invocations of the
%  functions and operations by other objects.
\item A set of {\it thread definitions} that describe the thread of control
  for active objects.
\item A set of {\it traces} that are used to indicate the sequences of
operation calls for which test cases are desired to be produced automatically.
\end{itemize}

In general, all constructs defined within a class must have a unique
name, e.g.\ it is not allowed to define an operation and a type with
the same name. However, it is possible to {\it overload} function and
operation names (i.e.\ it is possible to have two or more functions
with the same name and two or more operations with the same name)
subject to the restriction that the types of their input parameters
should not overlap. That is,  it should be possible using static type
checking alone to determine uniquely and unambiguously which
function/operation definition corresponds to each function/operation
call. Note that this applies not only to functions and operations
defined in the local interface of a class but also to those inherited
from superclasses. Thus, for example, in a design involving multiple
inheritance a class C may inherit a function from a class A and a
function with the same name from a class B and all calls involving
this function name must be resolvable in class C.
\end{description}

\subsection{Inheritance}\label{ch:inherit}

The concept of inheritance is essential to object orientation.  When
one defines a class as a subclass of an already existing class, the
definition of the subclass introduces an extended class, which is
composed of the definitions of the superclass together with the
definitions of the newly defined subclass.

Through inheritance, a subclass inherits from the superclass:
\begin{itemize}
\item Its instance variables. %and time variables.
  This also includes
  all invariants and their restrictions on the allowed modifications of
  the state.
\item Its operation and function definitions.
\item Its value and type definitions.
\item Its synchronization definitions as described in
  section \ref{ch:sync-inh}.
\item Its thread definitions as described in
  chapter~\ref{ch:thread}.
\end{itemize}

A name conflict occurs when two constructs of the same kind and with the
same name are inherited from different superclasses.
Name conflicts must be explicitly resolved through {\it name qualification},
i.e. prefixing the construct with the name of the superclass and a
\texttt{`}-sign (back-quote).

\begin{description}
\item[Example:] In the first example, we see that inheritance can be
exploited to allow a class definition to be used as an abstract
interface which subclasses must implement:
  \begin{lstlisting}
class Sort

  instance variables
    protected data : seq of int

  operations

    initial_data : seq of int ==> ()
    initial_data (list) ==
      data := list;

    sort_ascending : () ==> ()
    sort_ascending () == is subclass responsibility;
end Sort

class SelectionSort is subclass of Sort

  functions

    min_index : seq1 of nat -> nat
    min_index(list) ==
      if len list = 1
      then 1
      else let mi = min_index(tl list)
           in
             if list(mi+1) < hd list
             then mi+1
             else 1

  operations

    sort_ascending : () ==> ()
    sort_ascending () == selectSort(1);

    selectSort : nat ==> ()
    selectSort (i) ==
      if i < len data
      then (dcl temp: nat;
            dcl mi: nat := min_index(data(i,...,len data)) +
                          i - 1;

           temp := data(mi);
           data(mi) := data(i);
           data(i) := temp;
           selectSort(i+1)
           );

end SelectionSort
\end{lstlisting}
Here the class \texttt{Sort} defines an abstract interface to be
implemented by different sorting algorithms. One implementation is
provided by the \texttt{SelectionSort} class.

The next example clarifies how name space clashes are resolved.
  \begin{lstlisting}
    class A
    instance variables}
      i: int := 1;
      j: int := 2;
    end A

    class B is subclass of A
    end B

    class C is subclass of A
    instance variables
      i: int := 3;
    end C

    class D is subclass of B,C
    operations
      GetValues: () ==> seq of int
      GetValues() ==
        return [
            A`i, -- equal to 1
            B`i, -- equal to 1 (A`i)
            C`i, -- equal to 3
            j   -- equal to 2 (A`j)
          ]
     end D
  \end{lstlisting}
\end{description}

In the example objects of class {\tt D} have 3 instance variables:
{\tt A`i}, {\tt A`j} and {\tt C`j}. Note that objects of class {\tt D}
will have only one copy of the instance variables defined in class {\tt
A} even though this class is a common super class of both class {\tt
B} and {\tt C}. Thus, in class {\tt D} the names {\tt B`j}, {\tt C`j},
{\tt D`j} and {\tt j} are all referring to the same variable, {\tt
A`j}. It should also be noticed that the variable name {\tt i} is
ambiguous in class {\tt D} as it refers to different variables in
class {\tt B} and class {\tt C}.

\subsection{Interface and Availability of Class Members}\label{ch:interface}

In VDM++ and VDM-RT definitions inside a class are distinguished between:

\begin{description}
\item[Class attribute:] an attribute of a class for which there
  exists exactly one incarnation no matter how many instances
  (possibly zero) of the class may eventually be created. Class
  attributes in VDM++ and VDM-RT correspond to \keyw{static} class members in
  languages like C++ and Java. Class (static) attributes can be
  referenced by prefixing the name of the attribute with the name of
  the class followed by a \texttt{`}-sign (back-quote), so that, for
  example, {\tt ClassName`val} refers to the value {\tt val} defined in
  class {\tt ClassName}.

\item[Instance attribute:] an attribute for which there exists one
  incarnation for each instance of the class. Thus, an instance
  attribute is only available in an object and each object has its own
  copy of its instance attributes. Instance (non-static) attributes
  can be referenced by prefixing the name of the attribute with the name of
  the object followed by a dot, so that, for example, {\tt
    object.op()} invokes the operation {\tt op} in the object denoted
  by {\tt object} (provided that \texttt{op} is visible to
  \texttt{object}).
\end{description}

Functions, operations, instance variables and constants\footnote{In
  practice, constants will generally be static -- a non-static
  constant would represent a constant whose value may vary from one
  instance of the class to another which would be more naturally
  represented by an instance variable.} in a class may
be either class attributes or instance attributes. This is indicated
by the keyword \keyw{static}: if the declaration is preceded by the
keyword \keyw{static} then it represents a class attribute, otherwise
it denotes an instance attribute.

Other class components are by default always either class attributes
or instance attributes as follows:

\begin{itemize}
\item Type definitions are always class attributes.
%  Thus, they can be quoted directly in a class. E.g.\ {\tt
%    ClassName`val} refers to the value {\tt val} defined in
%  class {\tt ClassName}.
% \item Function and operation definitions are instance
%   attributes.  Thus, they are quoted in objects. E.g.\ {\tt
%   object.op()} invokes the operation {\tt op} in the object denoted by
%   {\tt object} (provided that \texttt{op} is visible to \texttt{object}).
% \item Instance variables %and time variables
%   are instance
%   attributes. Thus, each object has its own copy
%   of the instance %and time
%   variables.
\item Thread definitions are always instance attributes. Thus, each active
  object has its own thread(s).
\item Synchronization definitions are always instance attributes. Thus, each
  object has its own ``history'' when it has been created.
\end{itemize}

In addition, the interface or accessibility of a class member may be
explicitly defined using an access specifier: one of \keyw{public},
\keyw{private} or \keyw{protected}. The meaning of these specifiers
is:
\begin{description}
\item[\keyw{public}:] Any class may use such members
\item[\keyw{protected}:] Only subclasses of the current class may use
  such members
\item[\keyw{private}:] No other class may use such members - they may
  only be used in the class in which they are specified.
\end{description}

The default access to any class member is \keyw{private}. That is,
if no access specifier is given for a member it is private.

This is summarized in table \ref{table:access}. A few provisos apply
here:
\begin{itemize}
\item Granting access to instance variables (i.e.\ through
a \keyw{public} or \keyw{protected} access specifier) gives
both read and write access to these instance variables.
% ***** Change this in the future if o.v := expr is possible
\item Public instance variables may be read (but not written) using
  the dot (for object instance variables) or back-quote (for class
  instance variables) notation e.g.\ a public instance variable
  \texttt{v} of an object \texttt{o} may be accessed as \texttt{o.v}.
\item Access specifiers may only be used with type, value, function,
  operation and instance variable definitions; they cannot be used
  with thread or synchronization definitions.
\item It is not possible to convert a class attribute into an instance
  attribute, or vice-versa.
\item For inherited classes, the interface to the subclass is the same
  as the interface to its superclasses extended with the new
  definitions within the subclass.
\item Access to an inherited member cannot be made more restrictive
  e.g.\ a public instance variable in a superclass cannot be
  redeclared as a private instance variable in a subclass.
\end{itemize}

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|c|}\hline
                 & \keyw{public} & \keyw{protected} & \keyw{private}\\ \hline
Within the class & $\surd$       & $\surd$          & $\surd$ \\
In a subclass    & $\surd$       & $\surd$          & $\times$\\
In an arbitrary
external class   & $\surd$       & $\times$         & $\times$ \\
\hline
\end{tabular}
\end{center}
\caption{Summary of Access Specifier Semantics}\label{table:access}
\end{table}
\begin{description}
\item[Example] In the example below use of the different access
  specifiers is demonstrated, as well as the default access to class
  members. Explanation is given in the comments within the definitions.
\begin{lstlisting}
class A

types
public Atype = <A> | <B> | <C>

values
public Avalue = 10;

functions
public compare : nat -> Atype
compare(x) ==
  if x < Avalue
  then <A>
  elseif x = Avalue
  then <B>
  else <C>

instance variables
public v1: nat;
private v2: bool := false;
protected v3: real := 3.14;

operations
protected AInit : nat * bool * real ==> ()
AInit(n,b,r) ==
  (v1 := n;
   v2 := b;
   v3 := r)
end A

class B is subclass of A

instance variables
v4 : Atype --inherited from A

operations

BInit: () ==> ()
BInit() ==
  (AInit(1,true,2.718); --OK: can access protected members
                        --in superclass
   v4 := compare(v1);   --OK since v1 is public
   v3 := 3.5;           --OK since v3 protected and this
                        --is a subclass of A
   v2 := false          --illegal since v2 is private to A
  )

end B

class C

instance variables
a: A := new A();
b: B := new B();

operations

CInit: () ==> A`Atype--types are class attributes
CInit() ==
  (a.AInit(3,false,1.1);
                     --illegal since AInit is protected
   b.BInit();        --illegal since BInit is (by default)
                     --private
   let - = a.compare(b.v3) in skip;
                     --illegal since C is not subclass
                     --of A so b.v3 is not available
   return b.compare(B`Avalue)
                     --OK since compare is a public instance
                     --attribute and Avalue is public class
                     --attribute in B
  )

end C
\end{lstlisting}
%       b.v1 := 4;           --OK since v1 public in A so is
%                            --public by inheritance



\end{description}
\end{comment}

%%% Expression 翻訳

\chapter{式}

この章では異なる種類の式の1つ1つについて解説する。
各々は次の形式で記述する:
\begin{itemize}
\item BNF構文記法
\item 非公式な意味定義記述
\item 使用の記述例
\end{itemize}

\section{let式}\label{let-exp}

\begin{description}
\item[構文:]
  \Rule{式}{
    \Ruleref{let式} \dsep
    \Ruleref{let be式} \dsep
    \ldots
    }

  \Rule{let式}{
    \Lop{let}, 
    \Ruleref{ローカル定義}
    \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
    \Lop{in}, \Ruleref{式}
    }

  \Rule{let be式}{ 
    \Lop{let}, \Ruleref{束縛},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}}, \Lop{in}, \lfeed
    \Ruleref{式}
    } 

  \Rule{ローカル定義}{
    \Ruleref{値定義} \dsep
    \Ruleref{関数定義}
    }

  \Rule{値定義}{ 
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

  \noindent ここでの構成要素である ``関数定義'' は第~\ref{functiondef}節で述べられている。

\item[意味定義:] 単純な {\it let式} は次の形式をもつ:
  \begin{lstlisting}
    let p1 = e1, \ldots, pn = en in e
  \end{lstlisting}
ここで、 {\tt p1, \ldots, pn} はパターン、 {\tt e1, \ldots, en} はそれぞれの対応パターン {\tt pi}にマッチさせる式であって、{\tt e} は任意の型でよいが {\tt p1, \ldots, pn}の中のパターン識別子を含む式である。 
これは、パターン{\tt p1,\ldots, pn}が対応する式{\tt e1, \ldots, en}とマッチさせられる文脈中での、式 {\tt e}の値を示している。 

 ローカル関数定義を用いることで、より発展した形のlet式をつくることもできる。
そのようなことを行う意味は単に、このようなローカル定義関数のスコープはlet式の本体に制限されているということにある。

標準のISO/VDM-SLにおいては、定義の収集が相互に再帰するものとなる可能性がある。
しかしながらVDM言語においては、このようなものがインタープリタでサポートされることはない。 
さらに、すべての構成子が使用される前に定義されているように、定義に順番付けがされていなければならない。
     
   {\it let-be-such-that 式}は次の形式をもつ:
  \begin{lstlisting}
    let b be st e1 in e2
  \end{lstlisting}%
ここでは、 {\tt b} は集合値(または型)に対する束縛で、 {\tt e1}は ブール式、 {\tt e2} は式だが何の型であってもよく、{\tt b}におけるパターンのパターン識別子を含むものである。
 {\tt \keyw{be st} e1} 部分はオプション。
この式は、{\tt b}のパターンが{\tt b}の集合要素かまたは{\tt b}の中の型の値とマッチさせる文脈中での式 {\tt e2}の値を示す
  \footnote{集合束縛のみはインタープリタによって実行できることを思い出そう。}。 {\tt \keyw{st} e1}式がある場合は、マッチングの文脈中で{\tt e1}がtrueとなる束縛のみが用いられる。

\item[例題:] {\it let式} は読みやすさの改善に役立つ、特に何回も使われる複雑な式は縮めることで改善される。
  たとえば \pageref{mapdisj}ページの関数 \texttt{map\_disj}を改善することができる:
  \begin{lstlisting}
  map_disj : (map nat to nat) * (map nat to nat) -> map nat to nat
  map_disj (m1,m2) ==
    let inter_dom = dom m1 inter dom m2
    in
      inter_dom <-: m1 munion
      inter_dom <-: m2
  pre forall d in set dom m1 inter dom m2 & m1(d) = m2(d)
\end{lstlisting}
また複雑な構造体を構成要素に分解する上でも便利である。
たとえば、前に定義したレコード型 \texttt{Score} (\pageref{scoredef}ページ) を使用することで、あるスコアがもうひとつより大きいかどうかをテストすることができる:
  \begin{lstlisting}
    let mk_Score(-,w1,-,-,p1) = sc1,
       mk_Score(-,w2,-,-,p2) = sc2
    in (p1 > p2) or (p1 = p2 and w1 > w2)
  \end{lstlisting}
この特別な例では、2つのスコアから2番目と5番目の構成要素を抽出している。
 don't careパターン(\pageref{patterns}ページ)が、この式本体で行われた処理と残りの構成要素が無関係であることを示するために用いられていることに注目しよう。
  {\it let-be-such-that式} は、1つの集合から1つの要素を選ぶ意味のない選択を減らすために、特に集合上での再帰定義の形式化において用いられる。
これについての例は、列のfilter関数 (\pageref{filterdef}ページ)を集合上で考えたものである:
\label{setfilterdef}
  \begin{lstlisting}
    set_filter[@elem] : (@elem -> bool) -> (set of @elem) -> 
                        (set of @elem)
    set_filter(p)(s) ==
      if s = \{\}
      then \{\}
      else let x in set s
          in (if p(x) then \{x\} else \{\}) union
             set_filter[@elem](p)(s \verb+\+ \{x\});
   \end{lstlisting}
別の方法として、この関数を集合内包 (第 \ref{setexpr}節参照)を用いて定義することもできるであろう:
  \begin{lstlisting}
    set_filter[@elem] : (@elem -> bool) -> (set of @elem) -> 
                        (set of @elem)
    set_filter(p)(s) ==
      \{ x | x in set s & p(x)\};
  \end{lstlisting} 

 最後の例はオプションである ``be such that'' 部分をどのように用いることができるかを示す。
いくつかのプロパティをもつある要素が存在することはわかっているがその要素に対する明示的な式がわからないまたは記述することが難しい場合に、この部分は特に役に立つ。たとえばこの式を選択ソートアルゴリズムを書くために活用することができる:
   \begin{lstlisting}
   remove : nat * seq of nat -> seq of nat
   remove (x,l) ==
     let i in set inds l be st l(i) = x
     in l(1,...,i-1)\verb+^+l(i+1,...,len l)
   pre x in set elems l;

   selection_sort : seq of nat -> seq of nat
   selection_sort (l) ==
     if l = []
     then []
     else let m in set elems l be st
         forall x in set elems l & m <= x
         in [m]\verb+^+(selection_sort (remove(m,l)))
   \end{lstlisting}
   \label{selectionSortdef}
   ここでは、最初の関数は与えられたリストから与えられた要素を取り除く；
2番目の関数は並び替えされていないリスト部分から最も小さい要素を繰り返し取り除き、並び替えされた部分の頭に置く。
\end{description}

\section{def式} \label{define-exp}

この式は、第~\ref{op-def}節で述べられる操作の内部でのみ用いることができる。
式の部分でグローバル変数を取り扱うために、操作の内部で特別な式(すなわちdef式)が許されている。

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{def式} \dsep
    \ldots
    }

\Rule{def式}{
  \Lop{def}, 
  \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{式}
  } 

\item[意味定義:] {\it def式} は次の形式をもつ:
  \begin{lstlisting}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \Keyw{in}
      e
  \end{lstlisting}
   {\it def式} は、右辺の式がローカル変数やグローバル変数の値に従属する可能性はあるが相互に再帰するものではない、といったことを除けば、let式に相等する。
これは、パターン(または束縛){\tt pb1, \ldots, pbn}が対応する式 {\tt e1, \ldots,    en}とマッチする文脈中で、式{\tt e}の値を示す\footnote{束縛が用いられている場合は、簡単に言えばパターンと一致した値はさらに第~\ref{patterns}章で述べられる型式または集合式によって制限を受けるということを意味する。}。

\item[例題:] 式の値はグローバル変数に従属するという事実に気づいてもらえるよう、{\it def式} が合理的な方法で用いられる。

 これは小さな例で説明することができる:
  \begin{lstlisting}
    def user = lib(copy) in
      if user = <OUT>
      then true
      else false
  \end{lstlisting}      
   {\tt copy} が文脈中に定義されている場所で、{\tt lib} はグローバル変数である(このように {\tt lib(copy)} は変数の一部の内容検索と考えることができる)。

  第\ref{letstmt}節の操作 \texttt{GroupRunnerUp\_expl} でもまたdef式の例が与えられている。
\end{description}

\section{単項式または2項式}\label{unandbin}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{単項式} \dsep \Ruleref{2項式} \dsep \ldots
    }

\Rule{単項式}{
  \Ruleref{接頭辞式} \dsep
  \Ruleref{逆写像}
  }

\Rule{接頭辞式}{
  \Ruleref{単項演算子}, \Ruleref{式}
  }

  \Rule{単項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge} 
    }

\Rule{逆写像}{
  \Lop{inverse}, \Ruleref{式}
  }

  \Rule{2項式}{
    \Ruleref{式}, \Ruleref{2項演算子}, \Ruleref{式}}

  \Rule{2項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[意味定義:] 
単項式と2項式は、特定の型の値を記述する演算子と演算対象の結合である。
これらすべての演算子のシグネチャについては、すでに第~\ref{typedef}節で述べてあるのでそれ以上の説明はここでは行わない。
逆写像単項演算子は、数学的構文における接尾辞記号で記述されるため、別に取り扱う。
\item[例題:] これらの演算子を用いた例題は第~\ref{typedef}節で与えられるため、ここでは触れない。
\end{description}

\section{条件式}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{if式} \dsep \Ruleref{cases式} \dsep \ldots
    }

  \Rule{if式}{
    \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{式},\lfeed
    \SeqPt{\Ruleref{elseif式}}, \Lop{else}, \Ruleref{式}
    }

  \Rule{elseif式}{
    \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{式}
    }
                     
  \Rule{cases式}{
    \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
    \Ruleref{cases式選択肢群}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others式}}, \Lop{end}
    }

  \Rule{cases式選択肢群}{
    \Ruleref{cases式選択肢},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases式選択肢}}
    }

  \Rule{cases式選択肢}{
    \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{式}
    } 

  \Rule{others式}{
    \Lop{others}, \Lit{->}, \Ruleref{式}
    }

\item[意味定義:]  {\it if式} と {\it cases式}は、1つの特定の式の値を基に、複数の中から1つの式を選ぶことを可能にする。

  {\it if式} は次の形式をもつ:
  \begin{lstlisting}
    if e1
    then e2
    else e3
  \end{lstlisting}
ここで {\tt e1} はブール式であり、一方  {\tt e2} と {\tt e3} はどのような型であってもよい。
もし {\tt e1}が与えられた文脈中でtrueであるならば、 if式は与えられた文脈中で評価された{\tt e2}の値を表す。
そうでなければ、if式は与えられた文脈上で {\tt e3}の値を表す。
 \keyw{elseif}式の使用は、ある式の\keyw{else}部分においてネストされたif-then-else式を単に省略したものである。

  {\it cases式} は次の形式をもつ
  \begin{lstlisting}
    cases e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      others             -> emplus1
    end
  \end{lstlisting}
 ここで {\tt e} は1つの任意の型の式であり、{\tt pij} で表すすべては1つ1つが式 {\tt e}にマッチするパターンである。 
{\tt  ei}で表すのは任意の型の式であり、キーワードの \keyw{others} とそれに対応する式{\tt emplus1}とはオプションとなる。 
cases式では、 {\tt pij} パターンの1つが {\tt e}にマッチした文脈中で評価された{\tt ei} 式の値を示す。 
選択された {\tt ei} は、パターンの1つを式 {\tt e}とマッチさせることができた最初の入口である。
もしパターンのうちのどれも{\tt e}にマッチしない場合には、 \keyw{others} 節がなくてはならないし、そこでcases式は与えられた文脈中で評価される{\tt emplus1}の値を示す。
     
\item[例題:] 
 VDM言語におけるif式は、大部分のプログラム言語において用いられているものに相等するが、その一方 VDM言語における cases式は、大部分のプログラム言語よりもより一般的なものとなる。
このことは実際にパターンマッチングがおきる事例から見て取れるであろうが、しかしまた大部分のプログラム言語におけるようなパターンが定数である必要がないためでもある。
  条件式の使用例はマージソートアルゴリズムの記述により提供される:
  \begin{lstlisting}
  lmerge : seq of nat * seq of nat -> seq of nat
  lmerge (s1,s2) ==
    if s1 = [] then s2
    elseif s2 = [] then s1
    elseif (hd s1) < (hd s2)
    then [hd s1]\verb+^+(lmerge (tl s1, s2))
    else [hd s2]\verb+^+(lmerge (s1, tl s2));

  mergesort : seq of nat -> seq of nat
  mergesort (l) ==
    cases l:
      [] -> [],
      [x] -> [x],
      l1\verb+^+l2 -> lmerge (mergesort(l1), mergesort(l2))
    end
  \end{lstlisting}
cases式によって提供されたパターンマッチングは、型の合併を扱うことに役立つ。
たとえば、\pageref{exprdef} ページからの型定義\texttt{Expr}を用いることで次を得る:
  \begin{lstlisting}
  print_Expr : Expr -> seq1 of char
  print_Expr (e) ==
    cases e:
      mk_Const(-) -> "Const of"\verb+^+(print_Const(e)),
      mk_Var(id,-) -> "Var of"\verb+^+id,
      mk_Infix(mk\_(e1,op,e2)) -> "Infix of"\verb+^+print_Expr(e1)^","
                                      \verb+^+print_Op(op)\verb+^+","
                                      \verb+^+print_Expr(e2),
      mk_Cond(t,c,a) -> "Cond of"\verb+^+print_Expr(t)\verb+^+","
                                 \verb+^+print_Expr(c)\verb+^+","
                                 \verb+^+print_Expr(a)
    end;

  print_Const : Const -> seq1 of char
  print_Const(mk\_Const(c)) ==
    if is_nat(c)
    then "nat"
    else -- must be bool
         "bool";
  \end{lstlisting}
  \label{printExprDef}
  関数 \texttt{print\_Op}は同様に定義されるであろう。
\end{description}

\section{限量式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{限量式} 
    \dsep \ldots
    }

  \Rule{限量式}{
    \Ruleref{全称限量式} \dsep
    \Ruleref{存在限量式} \dsep
    \Ruleref{1存在限量式}
    } 

  \Rule{全称限量式}{
    \Lop{forall}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }
    
  \Rule{存在限量式}{
      \Lop{exists}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{1存在限量式}{
    \Lop{exists1}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] 限量式には3つの形式がある:
  {\it 全称} ( \keyw{forall}と記述される), {\it 存在} ( \keyw{exists}と記述される), そして {\it 1 存在} ( \keyw{exists1}と記述される)である。
以下に述べられるように、各々はブール値である \keyw{true} または \keyw{false}の値をとる。

   {\it 全称限量式} は次の形式をもつ:
  \begin{lstlisting}
    forall mbd1, mbd2, \ldots, mbdn \& e
  \end{lstlisting}
  ここで各々の {\tt mbdi} は多重束縛 {\tt pi \keyw{in set} s} (あるいは型束縛であるならば {\tt pi : 型})であり、 {\tt e} は {\tt mbdi}のパターン識別子を含むブール式である。 
この値は、{\tt e}を {\tt mbd1, mbd2, \ldots,
    mbdn}における束縛のすべてにおいて文脈上で評価して、\keyw{true}であるならば \keyw{true}となりそうでない場合は\keyw{false} となる。

   {\it 存在限量式} は次の形式をもつ:
  \begin{lstlisting}
    exists mbd1, mbd2, \ldots, mbdn \& e
  \end{lstlisting}
  ここで {\tt mbdi} および {\tt e} は、全称限量式におけるものと同じである。
ここで{\tt mbd1, mbd2, \ldots, mbdn}における束縛の少なくとも1つを選択した文脈上で評価した場合に{\tt e} が \keyw{true}であったならば、この値は \keyw{true} となりそうでない場合は \keyw{false} となる。

   {\it 1 存在限量式} は次の形式をもつ:
  \begin{lstlisting}
    exists1 bd \& e
  \end{lstlisting}
  ここで{\tt bd}は 集合束縛か型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛のうちのちょうど1つを選択した文脈上で評価して{\tt e} が \keyw{true} であるならば、この値は\keyw{true}となりそうでない場合は \keyw{false} となる。

 すべての限量式は、可能な優先度の中で最も低い優先度を持つ。
これは、可能な限り長い構成式が使われることを意味する。
式は、構文的に可能な限りの右側へ続く。


\item[例題:] 
存在限量の例は以下の \texttt{QualificationOk}で提示される関数で与えられる。
この関数は、\cite{Fitzgerald&98}における化学プラント警報システムの仕様書からとってきたものであるが、ある専門家の集団が要求された資質を満たすか否かを照合するものである。
  \begin{lstlisting}
  types

  ExpertId = token;
  Expert :: expertid : ExpertId
            quali : set of Qualification
  inv ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: set of Expert * Qualification -> bool
  QualificationOK(exs,reqquali) ==
      exists ex in set exs & reqquali in set ex.quali
  \end{lstlisting}
  この関数 \texttt{min} は全称限量の例を示す: 
  \begin{lstlisting}
  min(s:set of nat) x:nat
  pre s <> \{\} 
  post x in set s and
       forall y in set s \verb+\+ \{x\} & y < x
  \end{lstlisting}
1 存在限量は、すべての写像\texttt{m}が満足する関数プロパティを述べるために用いることができる:
  \begin{lstlisting}
  forall d in set dom m &
    exists1 r in set rng m & m(d) = r
  \end{lstlisting}


\end{description}

\section{iota式}\label{iotaexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{iota式} \dsep
    \ldots
    }

  \Rule{iota式}{
    \Lop{iota}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] {\it iota式}は次の形式をもつ:
  \begin{lstlisting}
    iota bd \& e
  \end{lstlisting}
  ここで{\tt bd} は集合束縛かまたは型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛に一致して本体式 {\tt e} を \keyw{true} とする唯一の値が存在するならば、\keyw{iota} 演算子を唯一用いることができる(i.e.\ {\tt \keyw{exists1} bd \& e} は \keyw{true}でなくてはならない)。 
 iota式の意味定義は、本体式 ({\tt e})を満たす唯一の値を返すということである。

\item[例題:] 
 次に定義された値 \texttt{sc1,...,sc4} を用いる
  \begin{lstlisting}
    sc1 = mk_Score (<France>, 3, 0, 0, 9);
    sc2 = mk_Score (<Denmark>, 1, 1, 1, 4);
    sc3 = mk_Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = mk_Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{lstlisting}
これより
  
  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent 最後の例は実行不可能であり、加えて最後の2式は未定義となることに注意しよう竏酎O者は式を満たす値が多くなるからであり、後者は式を満たす値がないからである。

\end{description}

\section{集合式}\label{setexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{集合列挙} \dsep \Ruleref{集合内包} \dsep
    \Ruleref{集合範囲式} \dsep \ldots
    }
  
  \Rule{集合列挙}{
    \Lit{\{}, \OptPt{\Ruleref{式リスト}}, \Lit{\}}
    }

  \Rule{式リスト}{
    \Ruleref{式}, \SeqPt{\Lit{,}, \Ruleref{式}}
    }

  \Rule{集合内包}{
    \Lit{\{}, \Ruleref{式}, \Lit{$|$}, \Ruleref{束縛リスト}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

  \Rule{集合範囲式}{
    \Lit{\{}, \Ruleref{式}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{\}}
    }

\item[意味定義:] {\it 集合列挙}は次の形式をもつ:
  \begin{lstlisting}
    \{e1, e2, e3, \ldots, en\}
  \end{lstlisting}
 ここで {\tt e1} から {\tt en} までは一般の式である。
列挙された式の値の集合を構成する。
空集合は \verb+{}+ と書かれなければならない。

    {\it 集合内包}式は次の形式をもつ:
  \begin{lstlisting}
    \{e | mbd1, mbd2, \ldots, mbdn \& P\}
  \end{lstlisting}
 述語 {\tt P}が \keyw{true}と評価される束縛すべてのもとで、式{\tt e} を評価することで1つの集合が構成される。
多重束縛には集合束縛と型束縛の両方を含めることができる。
したがって{\tt mbdn} は {\tt pat1 \keyw{in set} s1, pat2 : tp1,
    \ldots \keyw{in set} s2}というようになるであろうが、ここにおける {\tt pati} はパターンであり (通常は単なる識別子である)、 {\tt s1} や {\tt s2} は式で構成される集合である ( これに対して{\tt tp1}は、型束縛もまた用いることができることを示すために使われている)。 
ただし型束縛はインタープリタでは実行できないので注意したい。

   {\it 集合範囲式} は集合内包の特別な場合である。
これは次の形式をもつ
  \begin{lstlisting}
    \{e1, \ldots, e2\}
  \end{lstlisting}
 ここでの {\tt e1} と {\tt e2} は数式である。
この集合範囲式は {\tt e1} から {\tt e2} までに含まれる整数の集合を表記する。
 {\tt e2} が {\tt e1} よりも小さい場合には、集合範囲式は空集合を表す。

\item[例題:] 
 \texttt{Europe=\{<France>,<England>,<Denmark>,<Spain>\}} および \\
 \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (ここでの \texttt{sc1,...,sc4} は前述の例にて定義されたもの) の値を用いて次を得る

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\section{列式} \label{seqexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{列列挙} \dsep \Ruleref{列内包} \dsep
    \Ruleref{部分列} \dsep \ldots
    }

  \Rule{列列挙}{
    \Lit{[}, \OptPt{\Ruleref{式リスト}}, \Lit{]}
    }

  \Rule{列内包}{
    \Lit{[}, \Ruleref{式}, \Lit{|}, \Ruleref{集合束縛}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{]}
    }

  \Rule{部分列}{
    \Ruleref{式}, \lfeed
    \Lit{(}, \Ruleref{式},
    \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{)}
    }

\item[意味定義:]  {\it 列列挙}は次の形式をもつ:
  \begin{lstlisting}
    [e1, e2, \ldots, en]
  \end{lstlisting}
  ここでの{\tt e1}から {\tt en} は一般の式である。 
これは列挙された要素の列を構成する。
空列は {\tt []}と書かれなければならない。

   {\it 列内包} は次の形式をもつ:
  \begin{lstlisting}
    [e | pat in set S \& P]
  \end{lstlisting}
 ここでの式 {\tt e} は、パターン {\tt pat} からもってきた識別子を用いることになる(通常このパターンは単なる識別子となるが、唯一実際上の必要条件としては、ちょうど1つのパターン識別子のみがパターン中に存在するということである)。 
{\tt S} は値 (通常は自然数)の集合である。
このパターン識別子の束縛は何らかの種類の数値に対するものでなければならず、これにより結果列における要素の順を指示するために用いられる。
述語 {\tt P}が \keyw{true}と評価されるすべての束縛上で式{\tt e}を評価することにより、列を構成する。

列 {\tt l} の{\it 部分列} というのは {\tt l}の連続する要素からなる列;索引 {\tt n1}以上 {\tt n2}以下のもの、である。 
次の形式をもつ:
  \begin{lstlisting}
    l(n1, ..., n2)
  \end{lstlisting}
 ここでの {\tt n1} と {\tt n2} は正の整数式である。
 下限の {\tt n1}(空でない列での最初の索引) が1 より小さい場合は、列式は列の最初の要素から始まることとなる。
上限の{\tt n2}(空でない列で索引中最大のもの) が列の長さよりも大きい場合は、列式は列の最後の要素で終わることとなる。

%  A {\it sequence modifier} has the form:
%  \begin{lstlisting}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{lstlisting}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[例題:] \texttt{GroupA} が次の列に等しい場合
  \begin{lstlisting}
    [ mk_Score(<Brazil>,2,0,1,6), 
      mk_Score(<Norway>,1,2,0,5),
      mk_Score(<Morocco>,1,1,1,4),
      mk_Score(<Scotland>,0,1,2,1) ]
  \end{lstlisting}
  \label{GroupAdef}
  以下が導かれる:

  \begin{tabular}{lcl}
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i).team \\
            | i \keyw{in set inds} GroupA \\
                  \mbox{\hspace{1em}} \& GroupA(i).won <> 0]}
    &$\equiv$ & 
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA\\
            \mbox{\hspace{1em}} \& GroupA(i).won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)} 
    &$\equiv$ & 
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{5.65cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA \\
            \mbox{\hspace{1em}} \& GroupA(i).points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\section{写像式} \label{mapexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{写像列挙} \dsep \Ruleref{写像内包} \dsep \ldots
    }

  \Rule{写像列挙}{
    \Lit{\{}, \Ruleref{写}, \SeqPt{\Lit{,}, \Ruleref{写}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    } 
  
  \Rule{写}{
    \Ruleref{式}, \Lit{|->}, \Ruleref{式}
    }
  
  \Rule{写像内包}{
    \Lit{\{}, \Ruleref{写}, \Lit{|}, \Ruleref{束縛リスト},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

\item[意味定義:] {\it 写像列挙} は次の形式をもつ:
  \begin{lstlisting}
    \{d1 |-> r1, d2 |-> r2, \ldots, dn |-> rn\}
  \end{lstlisting}
  ここですべての定義域式 {\tt di} と値域式{\tt ri}は一般の式である。
 空写像は {\tt \{|->\}}と書かれなければならない。
      
  {\it 写像内包} は次の形式をもつ:
  \begin{lstlisting}
    \{ed |-> er | mbd1, \ldots, mbdn \& P\}
  \end{lstlisting}
 ここでの構成 {\tt mbd1, \ldots, mbdn} は、式 {\tt ed} および {\tt er} から集合 (または型)をきめる変数の多重束縛である。
 {\it 写像内包} は、述語 {\tt P}を\keyw{true}と評価するすべての可能なかぎりの束縛上で、式{\tt ed} および {\tt er}を評価することにより写像を構成する。

\item[例題:] \texttt{GroupG}は次の写像と等しいと仮定する
  \begin{lstlisting}
    \{ <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) \}
  \end{lstlisting}
  \label{GroupGdef}
  この場合に次が成り立つ:

  \begin{tabular}{lcl}
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{4em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\section{組構成子式} \label{tupexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{組構成子} \dsep \ldots
    }

  \Rule{組構成子}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{式リスト}, \Lit{)}
    }

\item[意味定義:]  {\it 組構成子式} は次の形式をとる:
  \begin{lstlisting}
    mk_(e1, e2, \ldots, en)
  \end{lstlisting}
 ここで {\tt ei} は一般の式である。
 相等および不等演算子のみが使用できる。
     
\item[例題:] 前述の例で定義された写像 \texttt{GroupG} を用いて、次が得られる:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG} 
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\section{レコード式} \label{recexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{レコード構成子} \dsep
    \Ruleref{レコード修正子} \dsep \ldots
    }

  \Rule{レコード構成子}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, 
    \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{レコード修正子}{
    \Lop{mu}, \Lit{(}, \Ruleref{式}, \Lit{,}, 
    \Ruleref{レコード修正}, \lfeed \SeqPt{\Lit{,}, \Ruleref{レコード修正}}
    \Lit{)}
    }

  \Rule{レコード修正}{
    \Ruleref{識別子}, \Lit{|->}, \Ruleref{式}
    }

\item[意味定義:] {\it レコード構成子}は次の形式をもつ:
  \begin{lstlisting}
    mk_T(e1, e2, \ldots, en)
  \end{lstlisting}
 ここでの式 {\tt (e1, e2, \ldots, en)} の型は、レコード型{\tt T}にある対応する入り口の型に一致する。

  {\it レコード修正} は次の形式をとる:
  \begin{lstlisting}
    mu (e, id1 |-> e1, id2 |-> e2, \ldots, idn |-> en)
  \end{lstlisting}
 ここで式 {\tt e} の評価として、修正されるべきレコード値を返す。
識別子 {\tt idi}は、{\tt e}のレコード型の中ですべて異なる名称をもつ入り口でなければならない。
     
\item[例題:] \texttt{sc} が値 \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} であるならば
  \begin{lstlisting}
    mu(sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    \MYEQUIV mk\_Score(<France>,3,1,0,10)
  \end{lstlisting}
さらなる例題として関数 \texttt{win}の説明を行う。
この関数は2つのチームと1つのスコアをもつ。
スコアの集合から与えられているチームに相当するスコア(勝ったチームには\texttt{wsc}、負けたチームには\texttt{lsc})を各々割り当て、\keyw{mu}演算子を用いてこれらを更新する。
チームの集合はここで、新しいスコアをもとのものと置き換えることで更新される。
  \begin{lstlisting}
  win : Team * Team * set of Score -> set of Score
  win (wt,lt,gp) ==
    let wsc = iota sc in set gp & sc.team = wt,
       lsc = iota sc in set gp & sc.team = lt
    in let new_wsc = mu(wsc, won |-> wsc.won + 1,
                            points |-> wsc.points + 3),
         new_lsc = mu(lsc, lost |-> lsc.lost + 1)
      in (gp \verb+\+ \{wsc,lsc\}) union \{new_wsc, new_lsc\}
  pre forall sc1, sc2 in set gp &
          sc1 <> sc2 <=> sc1.team <> sc2.team
          and \{wt,lt\} subset \{sc.team | sc in set gp\}
  \end{lstlisting}

\end{description}

\section{適用式}\label{app-expr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{適用} \dsep
    \Ruleref{項目選択} \dsep
    \Ruleref{組選択} \dsep
    \Ruleref{関数型インスタンス化} \dsep
    \ldots
    }

  \Rule{適用}{
    \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{項目選択}{
    \Ruleref{式}, \Lit{.}, \Ruleref{識別子}
    }

  \Rule{組選択}{
    \Ruleref{式}, \Lit{.\#}, \Ruleref{数字}
    }

  \Rule{関数型インスタンス化}{
    \Ruleref{名称}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
    }

\item[意味定義:] 
  {\it 項目選択式} はレコードに対して用いることができるが、第~\ref{records} 節ですでに説明したのでここではそれ以上の説明は行わない。
 {\it 適用} は、ある写像において検索を行い、列に索引をし、最後に関数を呼び出すために用いられる。
第~\ref{maps} 節で、写像において検索を行うとはどういうことかはすでに述べてある。同様に第~\ref{sequences} 節では、列に索引をするとはどのように行うのかが説明されている。

VDM言語においては、ここで更に1つの操作を呼び出すことが可能である。
これは標準VDM-SLにおいては許されていないことであり、この種の操作呼び出しは状態を変更してしまう可能性があるので、混合式においては慎重に使用されるべきである。
このような操作呼び出しで例外を起こすことが許されてはいないことに注意したい。

 このような操作呼出しでは評価の順が重要となる可能性がある。
したがって型検査では、式の中でユーザーが操作呼出しを有効化や無効化することを許す。

 組選択式は、組から特別な構成要素を抽出するために用いられる。
式の意味は、 もし \texttt{e} がいくつかの組 \keyw{mk\_}\texttt{(v1,...,vN)}であると評価され、 \texttt{M} が範囲 \verb+{1,...,N}+ 内の1つの整数であるならば、 \texttt{e.\#M}は \texttt{vM}となるということである。
\texttt{M} が \verb+{1,...,N}+ からはずれているならば、この式は未定義である。

 {\it 関数型インスタンス化\/} は、適当な型をもつ多相関数のインスタンス生成に用いられる。
これは次の形式をもつ:
  \begin{lstlisting}
    pf [ t1, ..., tn ]
  \end{lstlisting}
 ここで {\tt pf} は多相関数の名称であり、 {\tt t1,  \ldots, tn} は型である。
結果の関数は、関数定義で与えられた変数型の名称の代わりに、型 {\tt  t1, \ldots, tn} を用いる。

\item[例題:] 
\texttt{GroupA} は1つの列 ( \pageref{GroupAdef}ページ)、 \texttt{GroupG} は1つの写像 (\pageref{GroupGdef}ページ)、そして \texttt{selection\_sort} は1つの関数( \pageref{selectionSortdef}ページ)であったことを思い起こそう:

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ & 
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

 多相関数使用と関数型インスタンス化の1つの例として、第~\ref{functiondef}節から例題の関数を用いる:
  \begin{lstlisting}
    let emptyInt = empty_bag[int] in
      plus_bag[int](-1, emptyInt())

  \MYEQUIV

    \{ -1 |-> 1 \}
  \end{lstlisting}

\end{description}

% #ifdef VDMPP
\section{new式}
\label{sec:creation}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{new式} 
    }
  \Rule{new式}{
    \Lop{new}, \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\item[意味定義:]  {\it new式}は次の形式をもつ:

  \begin{lstlisting}
    new classname(e1, e2, ..., en)
  \end{lstlisting}
{\it new式}を用いることで、クラス記述からオブジェクトを生成すること(これはまた{\em インスタンス生成}とも呼ばれる ) が可能である。
 {\it new式}による効果は、{\tt classname}クラスに記述された他と識別できる新しいオブジェクトが生成されることである。
{\it new式} の値は、新しいオブジェクトへの参照である。

{\it new式} がパラメーターなしで呼び出された場合は、中のすべてのインスタンス変数は ``既定'' 値 (i.e.\ それらの初期化条件で定義された値)をとった1つのオブジェクトが生成される。
パラメーターありの場合には {\it new式} は  \emph{構成子}~(第~\ref{constructors}を参照)に相当し、カスタマイズされたインスタンスを生成する(つまり\ ここでのインスタンス変数は既定値とは異なる値をとることも許される)。


\item[例題:] \texttt{Queue} という1つのクラスを仮定し、この既定インスタンスは空であるとする。
 またこのクラスは1つの構成子(これもまた \texttt{Queue}と呼ばれる) を含み、これは単一のパラメーターをとりこれが任意のスタートキューを表す値のリストであるとする。このように仮定すると\texttt{Queue}の既定インスタンスを生成することができ、実際のキューは次の式を用いて空である
\begin{lstlisting}
  new Queue()
\end{lstlisting}
そして次の式を用いることで\texttt{Queue}の1つのインスタンスを生成することができるが、 ここにおいて実際のキューはたとえば\texttt{e1, e2, e3}となる
\begin{lstlisting}
  new Queue([e1, e2, e3])
\end{lstlisting}

 \pageref{TreeDef} ページで定義されたクラス \texttt{Tree} を用いることで、 \texttt{node}s を構成する新しい \texttt{Tree} インスタンスを生成する:
\begin{lstlisting}
mk_node(new Tree(), x, new Tree())
\end{lstlisting}
    
\end{description}

\section{self式}
\label{sec:self}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{self式} 
    }
  \Rule{self式}{
    \Lop{self}
  }

\item[意味定義:] {\it self式}は次の形式をもつ:

  \begin{lstlisting}
    self
  \end{lstlisting}
  self式は現在実行中のオブジェクトへの参照を返す。
継承の連鎖における名前空間を単一化するために、用いることができる。

\item[例題:] \pageref{TreeDef} ページで定義された\texttt{Tree}クラス を用いることで、B木検索アプローチを用いてデータを保存する \texttt{BST} と呼ばれるサブクラスを記述することができる。
これにより、B木検索挿入を実行する操作を指定することができる:
\begin{lstlisting}
    Insert : int ==> ()
    Insert (x) ==
      (dcl curr_node : Tree := self;

       while not curr_node.isEmpty() do
         if curr_node.rootval() < x
         then curr_node := curr_node.rightBranch()
         else curr_node := curr_node.leftBranch();
       curr_node.addRoot(x);
       )
\end{lstlisting}
この操作は、挿入に先立ちそこから行き来するルートを見つけるため、self式を用いる。 
更なる例題が第 \ref{call-stmt}に示される。
\end{description}

\section{スレッドID式}
\label{sec:threadid}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{スレッドID式} 
    }
  \Rule{スレッドID式}{
    \Lop{threadid}
  }
  
\item[意味定義:] {\it スレッドID式}は次の形式をもつ:

  \begin{lstlisting}
    threadid
  \end{lstlisting}
  スレッドID式は、その式が実行されているスレッドを一意に識別する自然数を返す。
% #ifdef VICEMAN
  周期的なスレッドはそれぞれの周期の状態における新しいスレッドIDを得ることに注意する。
% #endif

\item[例題:] 
スレッドIDを用いることで、許可述語を使って、VDM++にJAVAスタイルのwait-notifyを実装するVDM++基本クラスを提供することが可能となる。
このwait-notify手法で利用できるオブジェクトはすべて、この基本クラスから派生するものでなければならない。
\begin{lstlisting}
class WaitNotify

  instance variables
    waitset : set of nat := \{\};

  operations
    \PROTECTED wait: () ==> ()
    wait() == 
      let p = threadid
      in (
        AddToWaitSet( p );
        Awake();
       );

    AddToWaitSet : nat ==> ()
    AddToWaitSet( p ) ==
      waitset := waitset union \{ p \};
      
    Awake: () ==> ()
    Awake() == 
      skip;
  
    \PROTECTED notify: () ==> ()
    notify() == 
        if waitset <> \{\} then
          let arbitrary_process in set waitset
          in  waitset := waitset \verb+\+ \{arbitrary_process\};

    \PROTECTED notifyAll: () ==> ()
    notifyAll() ==
         waitset := \{\};

  sync
    mutex(notifyAll, AddToWaitSet, notify);
    per Awake => threadid not in set waitset;

\keyw{end} WaitNotify
\end{lstlisting}
この例ではスレッドID式が2箇所で用いられている:
\begin{itemize}
\item スレッドに対する\texttt{Wait} 操作中に、このオブジェクトへの関心を記録するため。
\item  \texttt{Awake}に対する 許可述語中。
関与するスレッドは、\texttt{Wait}を用いた記録を行った後に \texttt{Awake}を呼ぶべきである。
そしてこのスレッドは、\texttt{notify}に対するもうひとつのスレッド呼出しの後、待ち集合からスレッドIDが取り除かれるまでブロックされる。
\end{itemize}

%% #ifdef VICEMAN
周期的なスレッドを持っているときは、wait-notify構造の使用について注意する必要がある。
(なぜなら、それぞれの新しい周期にたいしてスレッドIDが変化するからである)
%% #endif

\end{description}
%% #endif VDMPP

\section{ラムダ式}\label{lambda}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{ラムダ式} \dsep \ldots
    }

  \Rule{ラムダ式}{
    \Lop{lambda}, \Ruleref{型束縛リスト}, \Lit{\&}, \Ruleref{式}
    }

\Rule{型束縛リスト}{
  \Ruleref{型束縛}, \SeqPt{\Lit{,}, \Ruleref{型束縛}}
  }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }
        
\item[意味定義:] {\it ラムダ式} は次の形式をもつ:
  \begin{lstlisting}
    lambda pat1 : T1, !\ldots!, patn : Tn \& e
  \end{lstlisting}
 ここで {\tt pati} はパターン、{\tt Ti} は型式、そして{\tt e} は本体式である。 
パターン{\tt pati} におけるパターン識別子のスコープが本体式である。
ラムダ式は多相ではありえないが、それとは別に、意味定義においては第~\ref{functiondef}節に説明される陽関数定義に相当する。
ラムダ式によって定義される関数は、入れ子になった本体中で新しいラムダ式を用いることでカリー化することが可能となる。
ラムダ式が1つの識別子と結びついたとき、再帰関数を定義することもまた可能である。
\item[例題:] 以下のようにラムダ式を用いて、増加関数を定義することができる:
  \begin{lstlisting}
    Inc = lambda n : nat & n + 1
  \end{lstlisting}
さらに加算関数はカリー化できる:
  \begin{lstlisting}
    Add = lambda a : nat & lambda b : nat & a + b
  \end{lstlisting}
もしこれが唯一の引数に適用された場合には、新しいラムダ式が返される:
  \begin{lstlisting}
    Add(5) !\(\equiv\)! lambda b : nat & 5 + b
  \end{lstlisting}
 ラムダ式は、高階関数との関連で用いられる場合に役立つ。
 たとえば \pageref{setfilterdef}ページに定義される関数 \texttt{set\_filter}を用いてみると:
  \begin{lstlisting}
  set_filter[nat](lambda n:nat & n mod 2 = 0)({1,...,10})
  !\MYEQUIV! {2,4,6,8,10}
  \end{lstlisting}
\end{description}


\section{narrow式}
\label{narrow}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{ 式} 
    }
  \Rule{ narrow式}{
    \Lit{\keyw{narrow}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] {\it narrow式}の値は、与えた式の結果の型を、指定された型に変換したものである。

静的型チェックおよび動的型チェックにより、無関係の型間の変換は型エラーとなる。

\item[例題1:]
この例では、Test() および Test'() の実行結果には差がないが、
Test() は「def」型チェックエラーとなる。

\begin{lstlisting}
class A

types
public C1 :: a : nat;
public C2 :: b : nat;
public S = C1 | C2;

operations
public
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

public
Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
end A
\end{lstlisting}

%% #ifdef VDMPP
\item[例題2:]
この例では、Test() および Test'() の実行結果には差がないが、
Test() は型チェックエラーとなる。

\begin{lstlisting}
class S
end S

class C1 is subclass of S

instance variables
public a : nat := 1;

end C1

class C2 is subclass of S

instance variables
public b : nat := 2;

end C2

class A

operations
public
Test: () ==>  seq of nat
Test() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> e.a,
                (isofclass(C2, e)) -> e.b
               end | i in set inds list ];

public
Test': () ==>  seq of nat
Test'() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> narrow_(e, C1).a,
                (isofclass(C2, e)) -> narrow_(e, C2).b
               end | i in set inds list ];
end A
\end{lstlisting}
%% #endif VDMPP

\end{description}


\section{is式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{一般is式} \dsep
    \ldots
    }

  \Rule{一般is式}{
    \Ruleref{is式} \dsep
    \Ruleref{型判定}
    }


  \Rule{is式}{
    \Lop{is\_}, \Ruleref{名称}, \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
    \Ruleref{is基本型}, \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{is基本型}{
    \Lop{is\_}, 
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl 
      \Lop{nat1} \dsepl 
      \Lop{int} \dsep 
      \Lop{rat} \dsepl 
      \Lop{real} \dsep
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{型判定}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] 
 {\it is式} は基本値かまたはレコード値(なにかのレコード型に属するタグ付けされた値)とともに用いられる。 
このis式は、与えられた値が指定された基本型に属する場合、または値が指定されたタグを持つ場合に、trueとなる。他の場合はfalseとなる。

 型判定は、型が静的には決定されえない式に対して用いることができることから、より一般的な形式である。
式 \texttt{\keyw{is}\_(e,t)} は、 \texttt{e} が\texttt{t}型 でありその場合にのみ、trueとなる。
     
\item[例題:]  \pageref{scoredef}ページに定義されたレコード型 \texttt{Score} を用いて次を得る:     
     
  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

 型判定の例は以下のとおり:
  \begin{lstlisting}
    Domain : map nat to nat | seq of (nat*nat) -> set of nat
    Domain(m) ==
      if is_(m, map nat to nat)
      then dom m
      else {d | mk_(d,-) in set elems m}
  \end{lstlisting}
   加えて \pageref{exprIsExs}にも例題が載せられている。
\end{description}

%% #ifdef VDMPP

\section{基底クラス構成要素}\index{base class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{isofbaseclass式} \dsep
    \ldots
    }

  \Rule{isofbaseclass式}{
    \Lop{isofbaseclass},
    \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}}
  
\item[意味定義:] 関数 {\keyw{isofbaseclass}} がクラス名である\texttt{識別子}と
  オブジェクト参照式である\texttt{式}に適用された場合、\texttt{識別子}が
  上で\texttt{式}で参照されるオブジェクトの、継承チェーン上のルートスーパクラスのとき、
  かつその時に限り{\bf\ttfamily true}が返される。それ以外の場合には
  {\bf\ttfamily false}が返される。
  
\item[例題:] \label{treeExDef}
 \texttt{BinarySearchTree} が \texttt{Tree}のサブクラスであると仮定すると、\texttt{Tree}は他のクラスのサブクラスにはならないし、 \texttt{Queue} が \texttt{Tree}や \texttt{BinarySearchTree}に継承によって関係付けられることもない。
\texttt{t} を \texttt{Tree}のインスタンス、 \texttt{b} を \texttt{BinarySearchTree}のインスタンス、 \texttt{q} を \texttt{Queue}のインスタンス、とすると次の通り:
  
  \begin{tabular}{lcl}
    \keyw{isofbaseclass}\texttt{(Tree, t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(BinarySearchTree, b)} & $\equiv$ & \keyw{false}\\
    \keyw{isofbaseclass}\texttt{(Queue, q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, q)} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\section{クラス構成要素}\index{class membership expression}
\begin{description}
\item[構文] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{isofclass式} \dsep
    \ldots
    }
  \Rule{isofclass式}{
    \Lop{isofclass}, \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}
  }

\item[意味定義:] 関数 \keyw{isofclass} が、クラス名を表す\texttt{識別子}
  とオブジェクト参照である\texttt{式}に適用された場合、\texttt{式}が参照する
  オブジェクトのクラスが\texttt{識別子}で指定されたものと同じか、またはその
  サブクラスである場合に限り、ブール値である{\bf\ttfamily true}が返される。
  その他の場合には{\bf\ttfamily false}が返される。

\item[例題:] 前の例と同様に、\texttt{Tree},\texttt{BinarySearchTree}, \texttt{Queue}のクラスと、識別子 \texttt{t},\texttt{b}, \texttt{q}を仮定する:  
  
  \begin{tabular}{lcl}
    \keyw{isofclass}\texttt{(Tree,t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,q)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(Queue,q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,t)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,b)} & $\equiv$ & \keyw{true}
  \end{tabular}

\end{description}

\section{同基底クラス構成要素}%
\index{same base class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
     \Ruleref{samebaseclass式} \dsep
    \ldots
    }
  \Rule{samebaseclass式}{\Lop{samebaseclass}, \lfeed
  \Lit{(},
        \Ruleref{式1}, \Lit{,}, \Ruleref{式2}, \Lit{)}
    }
  
\item[意味定義:] 関数 \keyw{samebaseclass} がオブジェクト参照である
  \texttt{式1}と\texttt{式2}に適用された場合、両者が同じルートスーパークラス
  から派生したクラスのインスタンスであるときに限り、ブール値の{\bf\ttfamily true}が
  返される。それ以外の場合には{\bf\ttfamily false}が返される。
  
\item[例題:] 前に述べた例題と同様に、クラス\texttt{Tree}、\texttt{BinarySearchTree}, \texttt{Queue}, および識別子 \texttt{t},\texttt{b}, \texttt{q} を仮定し、\texttt{AVLTree} を \texttt{Tree}のもうひとつのサブクラス、
\texttt{BalancedBST} を \texttt{BinarySearchTree}のサブクラス、 \texttt{a}
を \texttt{AVLTree}のインスタンス、そして \texttt{bb} を\texttt{BalancedBST}のインスタンスとする:

  \begin{tabular}{lcl}
  \keyw{samebaseclass}\texttt{(a,b)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(a,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(b,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(t,bb)} & $\equiv$ & \keyw{false}\\
  \keyw{samebaseclass}\texttt{(q,a)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{同クラス構成要素}%
\index{same class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
     \Ruleref{sameclass式} \dsep
    \ldots
    }

  \Rule{sameclass式}{\Lop{sameclass}, \lfeed
  \Lit{(}, \Ruleref{式1}, \Lit{,},
        \Ruleref{式2}, \Lit{)}
   }
   
\item[意味定義:] 関数 \keyw{sameclass} がオブジェクト参照である
  \texttt{式1}と\texttt{式2}に適用されると、\texttt{式1}と\texttt{式2}で
  参照されるインスタンスのクラスが同じものである場合に限り、ブール値の{\bf\ttfamily true}
  が返される。それ以外の場合は{\bf\ttfamily false}が返される。
  
\item[例題:] 
第 \ref{treeExDef}節においてのクラス \texttt{Tree}、\texttt{BinarySearchTree}、 \texttt{Queue}、そして識別子 \texttt{t}、\texttt{b}、 \texttt{q} を仮定し、さらに\texttt{b'} が \texttt{BinarySearchTree} のもうひとつのインスタンスであると仮定した場合、次が得られる:

  \begin{tabular}{lcl}
  \keyw{sameclass}\texttt{(b,t)} & $\equiv$ & \keyw{false}\\
  \keyw{sameclass}\texttt{(b,b')} & $\equiv$ & \keyw{true}\\
  \keyw{sameclass}\texttt{(q,t)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\section{履歴式}\index{history expressions}
\label{sec:historyexpr}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{act式} \dsep
    \Ruleref{fin式} \dsep
    \Ruleref{active式} \dsep
    \Ruleref{req式} \dsep
    \Ruleref{waiting式} \dsep 
    \ldots
  }
  \Rule{act式}{
    \Lit{\#act}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#act}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{fin式}{
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{active式}{
    \Lit{\#active}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#active}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{req式}{
    \Lit{\#req}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#req}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{waiting式}{
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }

\item[意味定義:] 履歴式は許可述語においてのみ用いられる (第 \ref{sec:permissionpred}節参照)。
履歴式は以下の式を1つ以上含むことが許される:
  
\begin{itemize}
\item {\tt \#act (}{\em 操作名}{\tt )} {\em 操作名} 操作が起動された回数。
\item {\tt \#fin(}{\em 操作名}{\tt )} {\em 操作名}操作が完了した回数。
\item {\tt \#active(}{\em 操作名}{\tt )} 現在起動中である{\em 操作名}操作の数。 このとき:
{\tt \#active(}{\em
    操作名}{\tt )} $=$ {\tt \#act(}{\em 操作名}{\tt )}
  $-$ {\tt \#fin(}{\em 操作名}{\tt )}
\item {\tt \#req(}{\em 操作名}{\tt )}  {\em 操作名} 操作に対して発生した要求の数。
\item {\tt \#waiting(}{\em 操作名}{\tt )} {\em 操作名}操作に対する未解決の要求の数。 
このとき: {\tt
    \#waiting(}{\em 操作名}{\tt )} $=$ {\tt \#req(}{\em 操作名}{\tt )} $-$ {\tt \#act(}{\em 操作名}{\tt )}
\end{itemize}
これらすべての演算子に対して、名前リスト版である\texttt{\#}\textit{history op(op1,$\ldots$,opN)} は \texttt{\#}\textit{history op(op1)} \texttt{+} $\mathtt{\cdots}$ \texttt{+\#}\textit{history op(opN)}に対する簡易な省略形である。

\item[例題:] 
3つの操作 \texttt{A}, \texttt{B} そして \texttt{C} が実行されるある特別なスレッドの実行における1時点を想定しよう。
 要求、起動、完了、の列がこのスレッド中で起こる。
 このことは図\ref{historyfig}において視覚的にみてとれる。

\insertfig{history}{14cm}{履歴式}{\label{historyfig}}

ここに記号 \textit{rA} を操作 \texttt{A}の実行要求を示すものとして用い、 \textit{aA} は \texttt{A}の起動を示すもの、 \textit{fA} は操作 \texttt{A}の実行の完了を示すものとし、そして同様のことを操作 \texttt{B} と\texttt{C}に対しても用いる。 
各々の履歴式は、 時間間隔[\textbf{S},\textbf{T}]に対するものとしての以下の値をとる:
\end{description}

\begin{center}\small
\begin{tabular}{llll}
\texttt{\#act(A) = 1} & \texttt{\#act(B) = 1} & \texttt{\#act(C) = 1}
& \texttt{\#act(A,B,C) = 3}\\
\texttt{\#fin(A) = 1} & \texttt{\#fin(B) = 1} & \texttt{\#fin(C) = 0}
& \texttt{\#fin(A,B,C) = 2}\\
\texttt{\#active(A) = 0} & \texttt{\#active(B) = 0} & 
\texttt{\#active(C) = 1} & \texttt{\#active(A,B,C) = 1}\\
\texttt{\#req(A) = 2} & \texttt{\#req(B) = 1} & \texttt{\#req(C) = 3}
& \texttt{\#req(A,B,C) = 6}\\
\texttt{\#waiting(A) = 1} & \texttt{\#waiting(B) = 0} & 
\texttt{\#waiting(C) = 2} & \texttt{\#waiting(A,B,C) = 3}\\
\end{tabular}
\end{center}


%% #endif VDMPP

%% #ifdef VICEMAN
\section{time式}\index{time expression}\label{sec:time}

\begin{description}
\item[構文:] 
 \Rule{time式}{\Lop{time}}

\item[意味定義:] これは単純に、与えられたCPU上の現在の時間を問い合わせるものである。時間は自然数で提供されます。

\item[例:] たとえば、確実にある操作が実行されたことをログ（記録）に取りたい場合、 \texttt{logEnvToSys}のようにして操作を作成することができる。
\begin{lstlisting}

  public logEnvToSys: nat ==> ()

  logEnvToSys (pev) == e2s := e2s munion {pev |-> time};

\end{lstlisting}

\end{description}

%% #endif VICEMAN

\section{リテラルと名称}

\begin{description}
\item[構文:]
  \Rule{式}{    \ldots \dsep
    \Ruleref{名称} \dsep
    \Ruleref{旧名称} \dsep
    \Ruleref{記号リテラル} \dsep
    \ldots
    }

  \Rule{名称}{
    \Ruleref{識別子}, \OptPt{\Lit{`}, \Ruleref{識別子}}
    }

  \Rule{名称リスト}{
    \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
    }

  \Rule{旧名称}{
    \Ruleref{識別子}, \Lit{\char'176}
    }

\item[意味定義:] {\it 名称\/} と {\it 旧名称\/} は、関数、操作、値、状態構成要素の定義にアクセスするためによく用いられる。
 {\it 名称\/} は次の形式をもつ:
  \begin{lstlisting}
    id1`id2
  \end{lstlisting}
ここで {\tt id1} と {\tt id2} は単なる識別子である。
名称が唯一の識別子で構成される場合は、その識別子はスコープ内で定義されている。つまり、ローカルにパターン識別子かパターン変数として定義されているか、
あるいはグローバルに現モジュール内で関数、操作、値、またはグローバル変数として定義されているか、いずれかである。

そうでない場合は、識別子 {\tt id1}が
コンストラクタが定義されているモジュール名/クラス名を
を示している (
  第~\ref{modules}節並びに
  第~\ref{sec:classdep}節
  および付録 \ref{ap:lexis}も参照)。
 {\it 旧名称\/} は、操作定義の事後条件(第~\ref{op-def}節参照)および仕様文の事後条件(第~\ref{se:specification}節参照)において、グローバル変数の旧値にアクセスするためによく用いられる。
これは次の形式をもつ:

  \begin{lstlisting} 
    id~ 
  \end{lstlisting} 
 ここで {\tt id} は状態構成要素である。

  {\it 記号リテラル\/} はいくつかの基本型における定数値である。

\item[例題:] {\it 名称} と {\it 記号リテラル\/} はこの本の中ですべての例題を通して用いられている (付録~\ref{Symbols}参照)。

%%% #ifdef VDMSL
  VDM-SL における{\it 旧名称}の使用例として、
  以下のように定義された state を考えてみよう:
  \begin{lstlisting}
    state sigma of
      numbers : seq of nat
      index   : nat
    inv  mk_sigma(numbers, index) == index not in set elems numbers
    init s == s = mk_sigma([], 1)
    end
  \end{lstlisting}
%%% #endif VDMSL

%%% #ifdef VDMPP
  また VDM++/VDM-RT における{\it 旧名称}の使用例としては、
  以下のように定義されたインスタンス変数を考えてみよう:
  \begin{lstlisting}
    instance variables
      numbers: seq of nat := [];
      index  : nat := 1;
    inv index not in set elems numbers;
  \end{lstlisting}
%%% #endif VDMPP

 これによって変数 {\tt index}を増加させる陰操作を定義することができる:
  \begin{lstlisting}
    IncIndex()
    ext wr index : nat
    post index = index~ + 1
  \end{lstlisting}
 操作 {\tt IncIndex} は、\keyw{ext wr} 節に示されるように、変数 {\tt index}を操作する。
事後条件の中で、 {\tt index} の新しい値は {\tt index}の旧値に  \texttt{1}を足したものと等しい。
(これ以上は第~\ref{op-def}節の操作についてを参照)。

モジュール/クラス
名の簡単な例として、
ここで以下のように、 \texttt{build\_rel} という関数が \texttt{CGRel} という
モジュール/クラス
において定義された(そしてエクスポートされた)と仮定する:
\begin{lstlisting}
  types

    Cg = <A> | <B> | <C> | <D> | <E> | <F> | 
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = map Cg to set of Cg

  functions

    build_rel : set of (Cg * Cg) -> CompatRel
    build_rel (s) == {|->}
\end{lstlisting}

別のモジュール/クラスにおいては、
最初にモジュール\texttt{CGRel}lを輸入し、 
それから、以下の呼出しを行なうことでこの関数にアクセスすることができる

  \begin{lstlisting}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{lstlisting}

  なおVDM++ と VDM-RT では \texttt{build\_rel} 関数は
  アクセスモディファイアを追加することによって定義されているクラスの外からの
  アクセスを許すことができる。

\end{description}

\section{未定義式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{未定義式}
    }

  \Rule{未定義式}{
    \Lop{undefined}
    }
  
\item[意味定義:] {\it 未定義式} は、ある式の結果が定義されないことを明白に述べるために用いられる。
 たとえばこれは、if-then-else式でelse分岐を評価した結果をどうすべきかが決定されていない場合などに、用いることができるであろう。
{\it 未定義式} が評価される場合、インタプリタは実行を終了し未定義式が評価されたと記録する。

実用において、未定義式の使用は事前条件のとは異なる:
事前条件の使用とは、関数が呼ばれたときに事前条件が満たされることを保障するのは呼び出す側の責任であることを意味する;
未定義式の使用であれば、エラー処理を行うのは呼び出された関数の責任となる。

\item[例題:] \texttt{Score} 値のbuildの前に、型の不変条件が保たれるかをチェックすることができる:

  \begin{lstlisting}
  build_score : Team * nat * nat * nat * nat -> Score
  build_score (t,w,d,l,p) ==
    if 3 * w + d = p
    then mk_Score(t,w,d,l,p)
    else undefined
  \end{lstlisting}
\end{description}

\section{事前条件式}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{事前条件式}
    }
  \Rule{事前条件式}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{式}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{式}}},
                 \Lit{)}
    }
  
\item[意味定義:] 
 \texttt{e} が関数型であると仮定すると、 式 \keyw{pre\_}\texttt{(e,e1,...,en)} は、\texttt{e}の事前条件が引数 \texttt{e1,...,em}に対してtrueでありかつその場合にのみtrueとなるが、ここで\texttt{m}は\texttt{e}の事前条件のarity(引数の数)である。
 \texttt{e} が関数でなかったり、 \texttt{m} $>$ \texttt{n} であったりした場合は、結果は \texttt{true}となる。
 \texttt{e} が事前条件をもたない場合は、式はtrueと等しい。
\item[例題:] 
  以下のように定義された関数 \texttt{f} と \texttt{g} を考えよう
  \begin{lstlisting}
  f : nat * nat -> nat
  f(m,n) == m div n
  pre n <> 0;

  g (n: nat) sqrt:nat
  pre n >= 0
  post sqrt * sqrt <= n and
       (sqrt+1) * (sqrt+1) > n
  \end{lstlisting}
この場合、次の式は
  \begin{lstlisting}
  pre_(let h in set {f,g, lambda mk_(x,y):nat * nat & x div y\} 
       in h, 1,0,-1)
  \end{lstlisting}  
以下と等しくなる
  \begin{itemize}
  \item \texttt{h}が \texttt{f} に束縛されている場合は \texttt{\keyw{pre}\_f(1,0)}と等しいと考えられるため、falseとなる;
  \item \texttt{h}が \texttt{g}に束縛されている場合は \texttt{\keyw{pre}\_g(1)}と等しいと考えられるため、trueとなる;
  \item  \texttt{h} が \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} に束縛されている場合はこの関数に対して定義された事前条件がないため、 trueとなる。
  \end{itemize}
 \texttt{h} がいかに束縛されていたとしても、最後の引数  (\texttt{-1}) は決して使われないことに注意しよう。
\end{description}

%%% パターン

\chapter{パターン}\label{patterns}

\begin{description}
\item[構文:]
  \Rule{パターン束縛}{
    \Ruleref{パターン} \dsepl
    \Ruleref{束縛}
    }

  \Rule{パターン}{
    \Ruleref{パターン識別子} \dsep
    \Ruleref{一致値} \dsep
    \Ruleref{集合列挙パターン} \dsep
    \Ruleref{集合合併パターン} \dsep
    \Ruleref{列列挙パターン} \dsep
    \Ruleref{列連結パターン} \dsep
    \Ruleref{写像列挙パターン} \dsep
    \Ruleref{写像併合パターン} \dsep
    \Ruleref{組パターン} \dsep
    \Ruleref{レコードパターン}
    }

  \Rule{パターン識別子}{
    \Ruleref{識別子} \dsepl \Lit{-}
    }

  \Rule{一致値}{
    \Ruleref{記号リテラル} \dsep \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{集合列挙パターン}{
    \Lit{\{}, [\Ruleref{パターンリスト}], \Lit{\}}
    }

  \Rule{集合合併パターン}{
    \Ruleref{パターン}, \Lit{\keyw{union}}, \Ruleref{パターン}
    }

  \Rule{列列挙パターン}{
    \Lit{[}, [\Ruleref{パターンリスト}], \Lit{]}
    }

  \Rule{列連結パターン}{
    \Ruleref{パターン}, \Lit{\char'136}, \Ruleref{パターン}
    }

  \Rule{写像列挙パターン}{
    \Lit{\{}, [\Ruleref{写パターンリスト}], \Lit{\}}
    }
    
  \Rule{写パターンリスト}{
    \Ruleref{写パターン}, \SeqPt{\Lit{,}, \Ruleref{写パターン}}
    }
    
  \Rule{写パターン}{
    \Ruleref{パターン}, \Lit{|->}, \Ruleref{パターン}
  }

   \Rule{写像併合パターン}{
    \Ruleref{パターン}, \Lit{\keyw{munion}}, \Ruleref{パターン}
    }

  \Rule{組パターン}{
    \Lop{mk\_(}, \Ruleref{パターン}, \Lit{,}, \Ruleref{パターンリスト}, \Lit{)}
    }
 
  \Rule{レコードパターン}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, [\Ruleref{パターンリスト}], \Lit{)}
    }
   
  \Rule{パターンリスト}{
    \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
    }

\item[意味定義:] パターンは常に文脈中で用いられ、1つの特定の型の1つの値に一致する。
マッチングでは、あるパターンがある値と一致する可能性があるかの照合を行い、そしてパターン中のパターン識別子に対応する値を結びつけ、識別子がそのスコープ内で、これらの値を意味するようにする。
パターンを用いることのできるいくつかの場合においては、束縛も同様に用いることができる (次節を参照)。
もし束縛が用いられていたら、それは単純に言って、与えられたパターンに一致する可能性のある値を束縛することに更なる情報(型式または集合式)が用いられていることを意味する。

 マッチングは次のように定義される
  \begin{enumerate}
  \item  {\it パターン識別子} はどんな型にも合致するしどんな値にも一致し得る。
それが識別子であるならば、その識別子はその値に束縛される;
それがdon't-care記号 \Lit{-}であるならば、どのような束縛も起こらない。

  \item {\it 一致値} はそれ自身の値に対してのみ一致し得る; どのような束縛もなされない。
一致値がたとえば {\tt 7} とか {\tt <RED>}とかのようにリテラルでない場合は、パターン識別子に対してこれを区別するために、括弧にかこまれた式でなければならない。

  \item  {\it 集合列挙パターン} は集合値のみと適合する。
1つ1つのパターンは1つの集合の異なる要素と一致させられ; すべての要素が一致しなければならない。

  \item   {\it 集合合併パターン} は集合値のみと適合する。
1つの集合を2つに分けた部分集合に対して、2つのパターンが一致する。
2つの部分集合は、互いに素で、かつ合併すると元の集合になるように選ばれる。
元の集合の要素数が2以上の時、2つの部分集合は空で無いように分割される。
元の集合の要素数が1の時は、1つの部分集合は、空となる。

  \item  {\it 列列挙パターン} は唯一列値にのみ合致する。
 各々のパターンは列値中の対応する要素に対して一致する; 列長とパターン数は等しくなければならない。

  \item  {\it 列連結パターン} は唯一列値とのみ合致する。
 2つのパターンは、共に連結するともとの列値をつくることができる2つの部分列に、一致する。 
2つの部分列は常に空でないように選ばれる。

  \item  {\it 写像列挙パターン} は写像値とのみ合致する。

　 \item  {\it 写パターンリスト} は1つの写像の、それぞれ異なる写（maplet）と一致する; すべての写が一致しなければならない。

 \item  {\it 写像併合パターン} は写像値とのみ合致する。
 1つの写像を2つに分けた部分写像に対して、2つのパターンが一致する。
2つの部分写像は、互いに素となり、かつ併合すると元の写像と一致するように選ばれる。
元の写像の要素数が2以上の時、2つの部分写像は空で無いように分割される。
元の写像の要素数が1の時は、1つの部分写像は、空となる。

  \item  {\it 組パターン} は同じ要素数をもつ組にのみ合致する。
 パターンの各々は、組値の中で対応する要素に対して一致させられる。

  \item  {\it レコードパターン} は同じタグをもつレコード値にのみ適合する。
  パターンの各々は、レコード値の項目に対して一致させられる。
 レコードのすべての項目が一致させられなくてはならない。
  \end{enumerate}

\item[例題:] 以下にパターンの使用例を説明する。

\paragraph{パターン識別子の例}
最も単純なパターンはパターン識別子である。
この例は次に述べるlet式で与えられる:
\begin{lstlisting}
  let top = GroupA(1)
  in top.sc
\end{lstlisting}
ここで識別子 \texttt{top} は列\texttt{GroupA}の先頭と結びつき、したがって識別子はlet式の本体で用いられることが許される。

\paragraph{一致値の例}
以下の例では一致値を用いる:
\begin{lstlisting}
  let a = <France>
  in cases GroupA(1).team:
             <Brazil> -> "Brazil are winners",
             (a)      -> "France are winners",
             others    -> "Neither France nor Brazil are winners"
     end;
\end{lstlisting}
一致値は唯一それ自身の値と一致させることが可能なので、ここで \texttt{GroupA} の先頭のチームが \texttt{<Brazil>} であるならば最初の節で一致する; もし \texttt{GroupA} の先頭のチームが\texttt{<France>} であるなら2番目の節で一致する。
これら以外は\keyw{others}が一致する。
ここで \texttt{a}を囲んだ括弧の使用が、\texttt{a} を一致値とみなすよう強要していることに留意しよう。

\paragraph{集合列挙パターンの例}
集合列挙は、パターンを1つの集合の要素と一致させる。
たとえば次において
\begin{lstlisting}
  let {sc1, sc2, sc3, sc4} = elems GroupA
  in sc1.points + sc2.points + sc3.points + sc4.points;
\end{lstlisting}
識別子 \texttt{sc1}, \texttt{sc2}, \texttt{sc3} および\texttt{sc4} は \texttt{GroupA}の4つの要素と結び付けられる。
束縛の選択はゆるいものであることに注目しよう - たとえば\texttt{sc1} は\texttt{\keyw{elems}GroupA} の[どのような] 要素と結び付いてもよい。
この場合、もし \texttt{\keyw{elems} GroupA} がちょうど4つの要素を含んでいるわけではなかったら、この式は良形とはいえない。

\paragraph{集合合併パターンの例}
集合合併パターンは、集合を再帰関数呼出しに分解させるために用いることができる。
この1つの例は集合を (任意の順での)列に変換する関数 \texttt{set2seq}である:
\begin{lstlisting}
  set2seq[@elem] : set of @elem -> seq of @elem
  set2seq(s) ==
    cases s:
      {} -> [],
      {x} -> [x],
      s1 union s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
    end
\end{lstlisting}
caseの3番目の選択肢で、集合合併パターンを使用しているのがわかる。
これは \texttt{s1} と \texttt{s2} を\texttt{s}の任意の部分集合に束縛し、それによって \texttt{s}を区分けする。
 Toolboxインタープリタは常に互いに素の区分けを実現する。

\paragraph{列列挙パターンの例}
列列挙パターンは、1つの列から指定された要素を抽出するために用いることができる。この1つの例として関数 \texttt{promoted}があり、これはスコアの列の最初から2つの要素を抽出し、チームの中の対応する2つを返す:
\begin{lstlisting}
  promoted : seq of Score -> Team * Team
  promoted([sc1,sc2]^-) == mk_(sc1.team,sc2.team);
\end{lstlisting}
ここで \texttt{sc1} は引数列の先頭と結びつき、\texttt{sc2} は列の2番目の要素と結びつく。
もし\texttt{promoted} が要素数が2つない列で呼び出されるなら、ランタイムエラーが起きる。
リストの残りの要素には興味を持たないので、それら残りに対して don't careパターンを用いていることに注目したい。

\paragraph{列連結パターンの例}
前に述べた例でも、列連結パターンの使用を行っている。
もうひとつの例として関数\texttt{quicksort}があるが、これは標準のクイックソートアルゴリズムを実装している:
\begin{lstlisting}
  quicksort : seq of nat -> seq of nat
  quicksort (l) ==
    cases l:
      [] -> [],
      [x] -> [x],
      [x,y] -> if x < y then [x,y] else [y,x],
      -^[x]^- -> quicksort ([y | y in set elems l & y < x]) ^ 
                 [x] ^ quicksort ([y | y in set elems l & y > x])
    end
\end{lstlisting}
ここで、 case式の最後のcases式選択肢で、列連結パターンは \texttt{l}をある任意のピボット(かなめ)要素と2つの部分列に分解するのに用いられている。
ピボットはリストをピボットより小さい値と大きい値に区分けるために用いられ、2つの区分けされた部分は再帰的にソートされる。

\paragraph{写像列挙パターンの例}
写像列挙パターンは、パターンを1つの写像と個々の写（maplet）と一致させる。
例えば、次の例では

\begin{lstlisting}
 let {1 |-> a, a |-> b, b |-> c} = {1 |-> 4, 2 |-> 3, 4 |-> 2} 
 in mk_(a, b, c)
\end{lstlisting}
aは、対応する定義域の値が1なので、4と一致する。
aが４なので、定義域の値が4である写の値域の値すなわちbの値は２になる。
同様に、bが２なので、cは3になる。

\paragraph{写像併合パターンの例}
写像併合パターンは、写像の写（maplet）を1つずつ処理する再帰関数に用いることができる。
ここでは、写像を（任意の順番で）写の列に変換する関数map2seqを示す。

\begin{lstlisting}
public map2seq[@T1, @T2] : map @T1 to @T2 -> seq of (map @T1 to @T2)
map2seq(m) ==
  cases m:
    ({|->})	-> [],
    {- |-> -}	-> [m],
    m1 munion m2 -> map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
  end;
\end{lstlisting}

ここで、case式の3番目のcases式選択肢で、写像併合パターンを使用している。
m1とm2を写像mの任意の（互いに素な）部分写像に束縛する。

\paragraph{組パターンの例}
組パターンは、組構成要素を識別子と結びつけるために用いることができる。
たとえば上で定義された関数 \texttt{promoted} は2つを返すので、以下の値定義では \texttt{GroupA}の勝ったチームの方を識別子\texttt{Awinner}に結びつける:
\begin{lstlisting}
  values

    mk_(Awinner,-) = promoted(GroupA);
\end{lstlisting}

\paragraph{レコードパターンの例}
レコードパターンはレコードのいくつかの項目が同じ式で用いられるときに役立つ。
たとえば次の式は、チーム名から点数スコアへの写像を構成する:
\begin{lstlisting}
  { t |-> w * 3 + l | mk_Score(t,w,l,-,-) in set elems GroupA}
\end{lstlisting}
 \pageref{printExprDef}ページの関数 \texttt{print\_Expr} もまた、レコードパターンのいくつかの例を与えてくれる。


\end{description}

%%% 束縛
\chapter{束縛}\label{bind}

\begin{description}
\item[構文:]
  \Rule{束縛}{
    \Ruleref{集合束縛} \dsepl \Ruleref{型束縛}
    }

  \Rule{集合束縛}{
    \Ruleref{パターン}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{多重束縛}{
    \Ruleref{多重集合束縛} \dsep
    \Ruleref{多重型束縛}
    }

  \Rule{多重集合束縛}{
    \Ruleref{パターンリスト}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{多重型束縛}{
    \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}
    }

%\item[意味定義:] {\it 束縛}は、ある値にパターンを一致させる。
\item[意味定義:] {\it 束縛}は、あるパターンをある値に一致させる。
 {\it 集合束縛} において、値は束縛の集合式によって定義された集合から選ばれる。
 {\it 型束縛} において、値は型式で定義された型から選ばれる。
 {\it 多重束縛}は、いくつかのパターンが同じ集合または型に束縛されることを除けば {\it 束縛} と同じである。
型束縛はインタープリタで実行させることは {\bf できない} ことに注意しよう。
これは、インタープリタに自然数というような無限の定義域の検索を要求するということであるからだ。

\item[例題:] 束縛は主に、これらの例にみられるように限量式や内包で用いられる:
  \begin{lstlisting}
    forall i, j in set inds list & i < j => list(i) <= list(j)
      
    { y | y in set S & y > 2 }

    { y | y: nat & y > 3 }

    occurs : seq1 of char * seq1 of char -> bool
    occurs (substr,str) ==
      exists i,j in set inds str & substr = str(i,...,j);

  \end{lstlisting}
\end{description}

%%% 値（定数）定義

\chapter{値(定数)定義} \label{valuedef}

値 (value) 定義は、伝統的プログラム言語における定数定義に相当する。

\begin{description}

\item[構文:]
  \Rule{値定義群}{
    \Lop{values},
    \OptPt{\Ruleref{アクセス値定義}}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{アクセス値定義}},
           \OptPt{\Lit{;}}
    }

%  \ifthenelse{\boolean{VDMpp}}{
    \Rule{アクセス値定義}{
       \OptPt{\Ruleref{アクセス}},
         \Ruleref{値定義}
    }%}{}

  \Rule{値定義}{
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

\item[意味定義:] 値定義は以下の形式を持つ
  \begin{lstlisting}
    values
      access pat1 = e1;
      !\ldots!
      access patn = en
  \end{lstlisting}
なお {\tt access} パートはVDM++ と VDM-RT でのみ利用可能である。
  
(値定義で定義された)グローバル値は、 VDM言語記述の全レベルで参照が可能である。
しかしながら、1つの仕様記述が実行可能であるためには、
使用される前に値定義の中で定義されていなければならない。
この ``使用前の宣言'' 原則は、VDMインタープリタによって値定義にのみ適用される。
たとえば、関数などは宣言される前に用いられることが可能なのである。
標準 ISO/VDM-SL では、定義の順番における制限はいっさい存在しない。
値定義にも他と同様に型制限を提供することが可能なので、
そのことでより正確な型情報を得るのに役立てることができる。

VDM++ および VDM-RT の
アクセス記述子の詳細は、第 \ref{ch:interface}節で述べられる。 

\item[例題:] 以下の例は \cite{Fitzgerald&98} からとったものであるが、識別子\texttt{p1} と \texttt{eid2}にトークン値を与え、\texttt{e3} に\texttt{Expert} レコード値を与え、そして \texttt{a1}に \texttt{Alarm} レコード値を与える。
\begin{lstlisting}
     types

     Period = token;
     ExpertId = token;
     Expert :: expertid : ExpertId
               quali : set of Qualification
     inv ex == ex.quali <> \{\};
     Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     Alarm :: alarmtext : seq of char
              quali : Qualification

     values
 
     public p1: Period = mk_token("Monday day");
     private eid2 : ExpertId = mk_token(145);
     protected e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
     a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{lstlisting}
  この例が示すように、ある値はそれ自身が定義される前に定義された他の値に依存できる。
  アクセスモディファイアの\keyw{private}、\keyw{protected}、\keyw{public}は
  VDM++ と VDM-RT でのみ利用可能である。
  トップレベルの VDM-SL 仕様記述は多くのファイルやモジュールからの
  仕様記述で成り立つことができる(節~\ref{modules}参照)。 
  値定義の順番が重要であるように、ある値定義を他のモジュールの定義に依存させないことが
  推奨される。

\end{description}

%%% インスタンス変数
%%% 状態定義

\chapter{変更可能な状態要素の宣言}\label{chap:state}

VDMの操作を用いて値を変更することのできる状態要素の定義は、
VDM-SL と VDM++（VDM-RT）では構文的に異なっている。
VDM-SLはモジュールベースであるため、状態定義は
単一のレコード型のような構成要素となる。
一方、 VDM++ と VDM-RT はオブジェクト指向ベースであるため
状態要素は定義の継承を可能にするためにより柔軟でなければならず、
このためインスタンス変数という形式で定義される。
本章の以下の2つの節では、それぞれの状態定義方法について説明を行う。

\section{インスタンス変数 (VDM++ and VDM-RT)}
\label{sec:ivars}

クラス定義からインスタンス化されたオブジェクトと、そのクラス自身のどもらも、
それぞれ内部状態を持つことができる。
それはオブジェクトまたはクラスの \emph{インスタンス変数} とも呼ばれる。 
オブジェクトの場合には、この状態をオブジェクト内のグローバル状態として参照する。

\begin{description}
\item[構文:]
  \Rule{インスタンス変数定義群}{
    \Lop{instance}, \Lop{variables}, \lfeed
    \OptPt{\Ruleref{インスタンス変数定義}, \lfeed
           \SeqPt{\Lit{;}, 
               \Ruleref{インスタンス変数定義}
                 }
          }
  }

  \Rule{インスタンス変数定義}{
    \Ruleref{アクセス指定定義} \dsep
    \Ruleref{不変条件定義}
  }

  \Rule{アクセス指定定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
    \Ruleref{代入定義}
  }

\Rule{代入定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=},
  \Ruleref{式}}
  }
\Rule{不変条件定義}{
  \Lop{inv}, \Ruleref{式}
  }

%\Rule{init文}{
%  \Lop{init}, \Ruleref{文}
%  }

\item[意味定義:] 内部状態を定義するセクションを始めるためには、
  {\tt instance variables}というキーワードが必要である。
  このキーワードに続けて
インスタンス変数定義と不変条件定義のリストが並べられる。
各々のインスタンス変数定義は、対応する型指定をともなうインスタンス変数名からなる。そこには初期値とアクセスおよび \keyw{static} 指定子を含めることもできる。
アクセスおよび \keyw{static} 指定子についての詳細は、
第\ref{ch:interface}節にみることができる。

不変条件定義の方法により、インスタンス変数の値を制限することが可能である。
各々の不変条件定義は、1つ以上のインスタンス変数を含み、クラスオブジェクトのインスタンス変数の値上で定義される可能性もある。
スーパークラスから継承されるものを含むクラスにあるすべてのインスタンス変数は、不変条件式で使用することができる。
各不変条件定義は、式がtrueとなるようにインスタンス変数の値を制限するブール式でなければならない。
すべての不変条件式は、そのクラスの各々のオブジェクトの全存在期間でtrueとなる必要がある。

あるクラスの全てにわたる不変条件式というのは、そのクラスおよびその複数のスーパークラスの不変条件定義のすべてが、まずは1)複数のスーパークラス、次は2)そのクラス自身、の中で定義された順に論理\keyw{and}で結合されたものである。

%あるクラスが1つまたはそれ以上の不変条件定義を含む場合、{\tt inv\_classname}という名の操作が暗黙的にこのクラス中に構築される
%\footnote{インタープリタではサポートされていない。}。
この操作はプライベートのものであり、パラメーターはもたず、不変条件式の実行に対応し1つのブール値を返す。

\item[例題:]

以下の例はインスタンス変数定義を示している。
このクラスでは1つのインスタンス変数が詳しく述べられる: 
  \begin{lstlisting}
  \keyw{class} GroupPhase

  \keyw{types}

    GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>;
    Team = ... -- as on page \pageref{scoredef}
    Score::team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat;


  instance variables
    gps : map GroupName to set of Score;
  inv forall gp in set rng gps & 
        (card gp = 4 and
         forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)

  end GroupPhase
  \end{lstlisting}

\end{description}

\section{状態定義 (VDM-SL)}\label{statedef}

仕様記述内でグローバル変数が必要な場合には、状態定義をすることが可能である。
この状態定義の要素は、その操作内で参照できるグローバル変数のコレクションと
見なすことが可能である。
モジュールの状態定義は、モジュール内の(その状態を使用している)操作
定義のいずれかがVDMインタープリタによって使用される前に初期化される。

\begin{description}
\item[構文:]
  \Rule{状態定義}{
    \Lop{state}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \lfeed
    \OptPt{\Ruleref{不変条件}}, \OptPt{\Ruleref{初期化}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{不変条件}{
    \Lop{inv}, \Ruleref{不変条件初期関数}
    }

  \Rule{初期化}{
    \Lop{init}, \Ruleref{不変条件初期関数}
    }

  \Rule{不変条件初期関数}{
    \Ruleref{パターン}, \Lit{==}, \Ruleref{式}}

\item[意味定義:] 状態定義は次の形式をもつ:
  \begin{lstlisting}
    state ident of
      id1 : type1
      !\ldots!
      idn : typen
    inv  pat1 == inv
    init pat2 == init
    end
  \end{lstlisting}
  状態識別子 {\tt idn}は特定の型 {\tt typen}であると宣言される。不変条件 {\tt inv}はいつも状態 {\tt ident}が保たなければならない特性を意味している論理式である。
  {\tt init}は初めに成立しなければならない状態を指示する。
  インタープリタを使用するためには、(もしも、状態を使用している操作が実行されるならば)初期化述語が必要であることに注意すべきである。
  加えてこの初期化述語の本体は状態全体の名称(その名称はパターン
  として使用されなくてはならない)を等式の左辺値とし、右辺値は正しい
  型のレコード値として評価される二項相当式でなくてはならない。これ
  はインタープリタが {\tt init} 状態を評価すること可能にする。初期化述語の簡単な例を以下に示す:

  \begin{lstlisting}
  state St of
    x:nat
    y:nat
    l:seq1 of nat
  init s == s = mk_St(0,0,[1])
  end
  \end{lstlisting}

  不変条件と初期値の両方の仕様記述では、全体として状態を操作しなければならない。
  また、それを状態名(例を参照)でタグ付けされたレコードとして参照することによって行う。
  状態中の項目がoperationで操作されるとき、状態名が前に付いていない項目名によって、項目は直接参照されなければならない。


\item[例:] 以下の例では、一つの状態変数を作成している:
  \begin{lstlisting}
  types 

  GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

  state GroupPhase of
    gps : map GroupName to set of Score
  inv mk_GroupPhase(gps) ==
    forall gp in set rng gps & 
      (card gp = 4 and
       forall sc in set gp & sc.won + sc.lost + sc.drawn <= 3)
  init gp ==
    gp = mk_GroupPhase ({ <A> |-> 
                                init_sc ({<Brazil>, <Norway>, 
                                    <Morocco>, <Scotland>}),
                         ...})
  end

  functions

  init_sc : set of Team -> set of Score
  init_sc (ts) ==
    { mk_Score (t,0,0,0,0) | t in set ts }
  \end{lstlisting}
  不変条件において、各グループには4 つのチームがあり、どのチームも3ゲーム以上行わないことを提示する。
  初めは、どのチームもゲームをしていない。

\end{description}

%%% 操作定義
\chapter{操作定義} \label{op-def}

操作については第~\ref{algorithm}節ですでに述べてきた。 
ここでは一般的な形式について説明し、 VDM++ と VDM-RT で、
クラスのインスタンスの構成に用いられる、
\emph{構成子} という名前の特別な操作に関しては、
第~\ref{constructors}節で説明を行う。
なお \keyw{async} というキーワードは、VDM-RTだけで用いることができる。

\begin{description}
\item[構文:]
  \Rule{操作定義群}{
    \Lop{operations},
    \OptPt{\Ruleref{アクセス操作定義}}, \lfeed
           \SeqPt{\Lit{;},
                  \Ruleref{アクセス操作定義}} ,  \OptPt{\Lit{;}
    }}

    \Rule{アクセス操作定義}{(
      \OptPt{\Lop{pure}},
      \OptPt{\Lop{async}}
      \OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsep\
     (
      \OptPt{\Lop{pure}}, \OptPt{\Lop{async}}
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{操作定義}
    }

\Rule{操作定義}{
  \Ruleref{陽操作定義} \dsep
  \Ruleref{陰操作定義} \dsep
  \Ruleref{拡張陽操作定義}
  }

\Rule{陽操作定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{操作型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーター群}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{操作本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
  }

\Rule{陰操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Ruleref{陰操作本体}
  }

\Rule{陰操作本体}{
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}, \lfeed
  \OptPt{\Ruleref{例外}}
  }

\Rule{拡張陽操作定義}{
  \Ruleref{識別子}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Lit{==}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed
  \OptPt{\Ruleref{例外}}
}

\Rule{操作型}{
  \Ruleref{任意の型}, \Lit{{\tt ==>}}, \Ruleref{任意の型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{()}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{操作本体y}{
  \Ruleref{文} \dsep
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!操作}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!操作}
  }

\Rule{外部節}{
  \Lop{ext}, \Ruleref{var情報}, \SeqPt{\Ruleref{var情報}}
  }

\Rule{var情報}{
  \Ruleref{モード}, \Ruleref{名称リスト}, \OptPt{\Lit{:}, \Ruleref{型}}
  }

\Rule{モード}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{名称リスト}{
  \Ruleref{識別子}, \SeqPt{\Lit{,}, \Ruleref{識別子}}
  }

\Rule{例外}{
  \Lop{errs}, \Ruleref{エラーリスト}
  }

\Rule{エラーリスト}{
  \Ruleref{エラー}, \SeqPt{\Ruleref{エラー}}
  }

\Rule{エラー}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{式}, \Lit{->}, \Ruleref{式}
  }

\item[意味定義:]

  VDMでの操作はデフォルトでは同期であるが、キーワード``\keyw{async}''が VDM-RT の
  操作定義の前で使用されると、その操作は非同期操作として扱われることを意味する。
  このことが意味するのは、その操作は戻り値を持つことができず、非同期操作を
  呼び出したスレッドは自身の実行をそのまま続行するということである。
  なおコンストラクタは非同期であると宣言できないことに注意して欲しい。

  % Pure 操作
  もしある操作が ``\keyw{pure}'' であると宣言されていて、その操作が関数の文脈
  で使用された場合（すなわち関数、不変条件、事前/事後条件の中で使用された場合）
  には、その実行はアトミックに行われる。関数の文脈でない場合に呼び出されたときは、
  pure操作の呼び出しは基本的に通常の操作と同じであるが、幾つかの制約が課されている。
  以下にその制約を挙げる；
  
  \begin{itemize}
  \item pure操作は状態を変えることはできない
  \item pure操作は非pure操作を呼ぶことはできない
  \item pure操作には permission predicates 定義することはできない
  \item pure操作を再定義する操作も、またpure操作でなければならない
  \item pure操作に History counters を使うことはできない
  \item mutex はpure操作を参照することはできない
  \item pure操作は値を返さなければならない
  \item pure操作は \keyw{async} として宣言することはできない。
    なぜなら非同期操作は戻り値の型として \keyw{void} を持つことを要求されているからだ
  \item スレッドの本体はpure操作にはなれない
  \item pure操作の中で \keyw{exit} を呼び出すことはできない
  \end{itemize}

  
VDM++ と VDM-RTの両者の、
アクセスと \keyw{static} 指定子の詳細については、第 \ref{ch:interface}節で解説される。
静的操作の中では、静的でない操作を呼ぶことは許されていない、またself式を
静的操作の定義内で用いることはできない、ということも注意しよう。

以下は陽操作の例である。1つのチームがもうひとつを打ち負かす場合に
VDM-SLなら状態 \texttt{GroupPhase} を、
VDM++ なら \texttt{GroupPhase}クラスのインスタンス変数を更新する
様子を示すものだ。

\begin{lstlisting}
  Win : Team * Team ==> ()
  Win (wt,lt) ==
    let gp in set dom gps be st 
         {wt,lt} subset {sc.team | sc in set gps(gp)}
    in gps := gps ++ { gp |-> 
                        {if sc.team = wt
                         then mu(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                         else if sc.team = lt
                         then mu(sc, lost |-> sc.lost + 1)
                         else sc 
                    | sc in set gps(gp)}}
    pre exists gp in set dom gps & 
          {wt,lt} subset {sc.team | sc in set gps(gp)};
\end{lstlisting}
\label{winDef}
1つの陽操作は1つの文(あるいは1つのブロック文を用いてまとめられたいくつかの文)からなるが、
これについては第 \ref{sec:stmt}節で述べられている。 
文は、必要とするどのような
状態/
インスタンス
変数に対しても、適当と判断したときに読込みや書出しを行いアクセスすることが許されている。

陰操作は、オプションである事前条件、または必要不可欠な事後条件を用いて指定される。
たとえば、ここに暗黙に陰操作\texttt{Win}を指定できる:
\begin{lstlisting}
  Win (wt,lt: Team)
  ext wr gps : map GroupName to set of Score
  pre exists gp in set dom gps & 
          {wt,lt} subset {sc.team | sc in set gps(gp)}
  post exists gp in set dom gps &
         {wt,lt} subset {sc.team | sc in set gps(gp)}
         and gps = gps~ ++ 
                       { gp |-> 
                         {if sc.team = wt
                          then mu(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                          else if sc.team = lt
                          then mu(sc, lost |-> sc.lost + 1)
                          else sc 
                     | sc in set gps(gp)}};
\end{lstlisting}

外部節では、その操作が扱う
状態/インスタンス
変数をリストする。
予約語である \keyw{rd} の後にリストされた
状態/インスタンス
変数は読み取りのみができるが、
\keyw{wr}の後にリストされた変数は読みとりと書きだしの両方行うことができる。
 
VDM-SLの場合、事前、事後条件の定義が存在すると、
インタープリタも操作定義の事前、事後条件に対応した新しい関数を作成する。
しかし、もし仕様記述がグローバルな状態を含んでいた場合、
その状態も新たに作成された関数の一部となる。 
したがって、以下のシグネチャを持つ関数が、事前、事後条件を伴う操作に対して作成される。
\footnote{しかしながら、これらの事前、事後条件の述語は、
  単なるブール関数であることを忘れてはならない。
  また、その状態は、このような述語関数を呼び出すことによって変化しない}:
\begin{lstlisting}
  pre_Op : InType * State +> bool

  post_Op : InType * OutType * State * State +> bool
\end{lstlisting}
以下は例外である:
\begin{itemize}
\item もし、操作が引数を取らないなら、シグネチャの{\tt InType}部分を {\tt \keyw{pre\_}Op} と {\tt \keyw{post\_}Op}
の両方で省略する。

\item もし、操作が値を返さないなら、{\tt OutType}部分を {\tt \keyw{post\_}Op}シグネチャにおいて省略する。

\item もし、仕様記述が状態を定義しないなら、両方のシグネチャの{\tt State}部分は省略する。

\end{itemize}

{\tt \keyw{post\_}Op}シグネチャにおいて、最初の {\tt State}は旧状態
（操作呼び出し前の状態）であり、2番目の {\tt State}は操作呼び出し後の状態である。

例えば、以下の仕様記述を考える:

%% \begin{quotation}
%% \begin{minipage}[t]{.4\textwidth}
\begin{lstlisting}
module A

definitions

state St of
  n : nat
end

operations

Op1 (a : nat) b :nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end A

\end{lstlisting}
%% \end{minipage}
%% \begin{minipage}[t]{.4\textwidth}
\begin{lstlisting}
module B

definitions

operations

Op1 (a : nat) b : nat
pre a > 0
post b = 2 * a;

Op2 () b : nat
post b = 2;

Op3 ()
post true

end B
\end{lstlisting}
%% \end{minipage}
%% \end{quotation}

\textbf{module A}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

%% \begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline  
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))              
  & \texttt{n}を2に、\texttt{a}を1に束縛する \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2)) 
  & \texttt{a} を1に、\texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))   
  & \texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))     
  & \texttt{n} の前の状態を1に、
    \texttt{n} の後の状態を2に束縛する \\
\hline
\end{tabular}

\textbf{module B}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

%% \begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\begin{tabular}{|p{0.4\textwidth}|p{0.4\textwidth}|} \hline
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} を1に束縛する\\
\keyw{post}\_Op1(1,2)  & \texttt{a} を1に、\texttt{b}を2に束縛する\\
\keyw{post}\_Op2(2)    & \texttt{b}を2に束縛する\\
\keyw{post}\_Op3()     & 何も束縛しない\\
\hline
\end{tabular}

\vspace{2ex}

例外節は、ある操作がエラー状態にどのように対処するかを記述をすることに用いることができる。
例外節が存在する理由は、正常なケースと例外ケースを切り離すことを可能にするためである。
例外を用いた記述では、どのように例外を起こすかについて言及はしていないが、どのような環境でエラー状態が起こり得るか、また操作を呼
び出した結果どのような影響が起きるかについて示す手段が与えられる。

例外節は次の形式をもつ:
\begin{lstlisting}
   errs COND1: c1 -> r1
       !\ldots!
       CONDn: cn -> rn
\end{lstlisting}
条件名 {\tt COND1}, \ldots, {\tt CONDn} は識別子で、
起きる可能性があるエラーの種類を記述する\footnote{これらの名前は単に
  記憶を助けてくれる値であり、つまり意味定義上は重要でない。}。 
条件式 {\tt c1}, \ldots, {\tt cn} は、異なる種類のエラーに対する
事前条件と考えることができる。
このようにこれらの式においては、引数リストから識別子をまた外部節リストからは変数を
用いることができる (それらは事前条件と同じスコープをもつ)。
結果の式である {\tt r1},\ldots, {\tt rn} は相対的にみれば、
異なる種類のエラーに対する事後条件と同じと考えられる。
これらの式においては、結果の識別子とグローバル変数 (書き込みのできる)
の旧値もまた用いることができる。
このように、ここでのスコープは事後条件のスコープに相当する。

\keyw{errs} 句を用いる操作定義は、オリジナルの事前条件と
     {\tt c1},\ldots, {\tt cn}の全ての条件の論理和が実質的な事前条件となる。
     また、この場合の実質的な事後条件は、({\tt orig\_pre \keyw{and} orig\_post)}
     と{\tt c1 \keyw{and} r1}, \ldots, {\tt cn \keyw{and} rn}の論理和となる。
     
表面的には、ここでの例外と事前条件との間にはいくらか重複があるようにみえる。
しかしながらこれらの間には、どちらをいつ用いるべきか指し示す概念的な違いが存在する。 
事前条件は、その操作の呼び出しが正しく行なわれるためにどんなことを保証しなければならないかを指定する; 例外節は、例外条件が満たされたときに記述された操作がエラー処理の責任をとることを示す。
したがって通常は、例外節と事前条件は重複しない。

次に示す例の VDM-SLの操作は、以下の状態定義を使用するものとする:
\begin{lstlisting}
  state qsys of
    q : Queue
  end
\end{lstlisting}    

また VDM++/VDM++ を使っている場合には、次のインスタンス変数定義を使用するものとする:
\begin{lstlisting}
  instance variables
    q : Queue
  end
\end{lstlisting}    

この例では、陰操作の例外がどのように用いられるか示されている:
\begin{lstlisting}
  DEQUEUE() e: [Elem]
  ext wr q : Queue
  post q~ = [e] ^ q
  errs QUEUE_EMPTY: q = [] -> q = q~ and e = nil
\end{lstlisting}

これはデキュー操作であって、 型{\tt Queue}の グローバル変数 {\tt q}を用いて、
キューから型{\tt Elem}の 要素{\tt e}をとりのぞく。 
ここでの例外は、キューが空の場合で、そのときに操作がどのように振る舞うべきかを
指定している。

VDM-SL モデルに対する VDM インタープリターは以下の関数を作成することに留意する:
\begin{lstlisting}
  post_DEQUEUE: [Elem] * qsys * qsys +> bool
\end{lstlisting}

%% #ifdef VDMPP

%The time post-condition has the same scope as the post-condition and
%deals with the duration of the operation from the invocation moment
%until the moment it finishes. Thus describing for explicitly specified
%operations, the duration of the statement.
%
%The following two extra concepts are
%introduced: {\tt now\verb+~+}, representing the time the operation is
%invoked (moment of incrementing {\tt \#act}) and {\tt now},
%representing the time the operation is completely finished (moment of
%incrementing {\tt \#fin}). The expression:
%\begin{lstlisting}
%  now - now\verb+~+
%\end{lstlisting}
%represents the duration of the operation. 
%
%For instance, consider the specification of a system for controlling a
%set of traffic lights. We might have the following instance variables:
%\begin{lstlisting}
%  \keyw{instance variables}
%    red: \keyw{bool};
%    green: \keyw{bool};
%    amber: \keyw{bool};
%  \keyw{inv} (red => (\keyw{not} green \keyw{and not} amber)) \keyw{and}
%     (green => (\keyw{not} amber \keyw{and not} red)) \keyw{and}
%     (amber => (\keyw{not} red \keyw{and not} green))
%\end{lstlisting}
%Then the following operation specifies that on execution the light
%must change from red to green within 20 time units:
%\begin{lstlisting}
%    RedToGreen()
%    \keyw{ext wr} red: \keyw{bool}
%       \keyw{wr} green: \keyw{bool}
%    \keyw{pre} red
%    \keyw{post} green
%    \keyw{time post now} - \keyw{now}~ < 20
%\end{lstlisting}

%% #endif VDMPP

\end{description}

%% #ifdef VDMPP
\section{構成子 (VDM++ and VDM-RT)}\label{constructors}

構成子は操作である。それ自身が定義されたクラスと同じ名前をもち、
そのクラスの新しいインスタンスを作る。
このため戻り値の型は、その同じクラス名でなければならず、
もし戻り値が指定されるとすれば \keyw{self}となるべきであるが、
これは省略可能で、暗黙的に \keyw{self} が返される。
そして、構成子はクラスの新しいインスタンスを初期化するために使用されるので、
構成子を \keyw{static} と宣言することは許されていない。

1つのクラス内では、第~\ref{sec:classdep}節で述べられる操作のオーバーローディングを用いて
多重構成子を定義することが可能である。

%% #endif VDMPP

%%% 文
%% \chapter{statement}\label{sec:stmt}
\chapter{文}
\label{sec:stmt}

%%% トップレベル仕様記述
% \chapter{Top-level Specification in VDM}
\chapter{VDMにおける仕様のトップレベル}
\label{top-level}

%%% 同期と制約
%% \chapter{Synchronization Constraints (VDM++ and VDM-RT)}\label{ch:sync}
\chapter{同期と制約 (VDM++ and VDM-RT)}\label{ch:sync}

In general a complete system contains objects of a passive
nature (which only react when their operations are invoked) and active
objects which `breath life' into the system. These active objects
behave like virtual machines with their own processing thread of
control and after start up they do not need interaction with other
objects to continue their activities.
In another terminology a system could be described as
consisting of a number of active clients requesting services of passive
or active servers.
In such a parallel environment the server objects need
synchronization control to be able to guarantee internal consistency,
to be able to maintain their state invariants.
Therefore, in a parallel world, a passive object needs to
behave like a Hoare monitor with its operations as entries.

If a sequential system is specified (in which only one thread of control
is active at a time) only a special case of the general properties is used
and no extra syntax is needed. However, in the course of development from
specification to implementation more differences are likely to appear.

The following default synchronization rules for each object apply in
VDM++ and VDM-RT:
\begin{itemize}
\item operations are to be viewed as though they are atomic, from the
point of the caller;
\item operations which have no corresponding permission predicate are
  subject to no restrictions at all;
\item synchronization constraints apply equally to calls within an
  object (i.e.\ one operation within an object calls another operation
  within that object) and outside an object (i.e.\ an operation from
  one object calls an operation in another object);
\item operation invocations have the semantics of a rendez-vous (as in
Ada, see \cite{adalrm}) in case two active objects are involved. Thus if an
object $O_1$ calls an operation $o$ in object $O_2$, if $O_2$ is currently
unable to start operation $o$ then $O_1$ blocks until the operation may be
executed. Thus invocation occurs when both the calling object and the
called object are ready. (Note here a slight difference from the
semantics of Ada: in Ada both parties to the rendez-vous are active
objects; in VDM++ and VDM-RT only the calling party is active).
\end{itemize}
The synchronization definition blocks of the class description provide the
user with ways to override the defaults described above.

\begin{description}
\item[Syntax:]
  \Rule{synchronization definitions}{
    \Lop{sync}, \OptPt{\Ruleref{synchronization}}
  }
  \Rule{synchronization}{
    \Ruleref{permission predicates}
  }

\item[Semantics:]

Synchronization is specified in VDM++ and VDM-RT using permission predicates.

\end{description}


\section{Permission Predicates}
\label{sec:permissionpred}

The following gives the syntax used to state
rules for accepting the execution of concurrently callable operations.
Some notes are given explaining these features.

\begin{description}
\item[Syntax:]
  \Rule{permission predicates}{
    \Ruleref{permission predicate}, \SeqPt{\Lit{;}, \lfeed
    \Ruleref{permission predicate}}
  }
\Rule{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Rule{mutex predicate}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{name list} \Lit{)}}

\item[Semantics:] Permission to accept execution of a requested
operation depends on a guard condition in a (deontic) permission
predicate of the form:

\begin{quote}
{\keyw{per}} {\em operation name} \texttt{=>} {\em guard condition}
\end{quote}

The use of implication to express the permission means that truth of
the guard condition (expression) is a necessary but not sufficient
condition for the invocation. The permission predicate is to be read
as stating that if the guard condition is false then there is
non-permission. Expressing the permission in this way allows further
similar constraints to be added without risk of contradiction through
inheritance for the subclasses. There is a default for all operations:

\begin{quote}
{\keyw{per}} {\em operation name} \texttt{=>} \keyw{true}
\end{quote}

but when a permission predicate for an operation is specified
this default is overridden.

Guard conditions can be conceptually divided into:
\begin{itemize}
\item
a {\em history guard} defining the dependence on events in the past;
\item
an {\em object state guard}, which depends on the instance variables of the
object, and
\item
a {\em queue condition guard}, which depends on the
states of the queues formed by operation invocations (messages) awaiting
service by the object.
\end{itemize}
These guards can be freely mixed. \textbf{Note} that there is no
\textit{syntactic} distinction between these guards - they are all
expressions. However they may be distinguished at the semantic level.

A mutex predicate allows the user to specify either that all
operations of the class are to be executed mutually exclusive, or that
a list of operations are to be executed mutually exclusive to each
other. Operations that appear in one mutex predicate are allowed to
appear in other mutex predicates as well, and may also be used in the
usual permission predicates. Each mutex predicate will implicitly be
translated to permission predicates using history guards for each
operation mentioned in the name list. For instance,
\begin{lstlisting}
sync
  mutex(opA, opB);
  mutex(opB, opC, opD);
  per opD => someVariable > 42;
\end{lstlisting}
would be translated to the following permission predicates:
\begin{lstlisting}
sync
  per opA => #active(opB) = 0;
  per opB => #active(opA) = 0 and
             #active(opC) + #active(opD) = 0;
  per opC => #active(opB) + #active(opD) = 0;
  per opD => #active(opB) + #active(opC) = 0 and
             someVariable > 42;
\end{lstlisting}

Note that it is only permitted to have one ``stand-alone'' permission
predicate for each operation. It is also important to note that if
permission predicates are made over operations that are overloaded
(see Section~\ref{sec:classdep}) then it will incorporate all of their history
counters as the same operation. The {\bf\ttfamily{\#active}} operator
is explained below.

A \keyw{mutex(all)} constraint specifies that all of the operations
specified in that class \textit{and any superclasses} are to be
executed mutually exclusively.
\end{description}


\subsection{History guards}
\begin{description}
\item[Semantics:] A history guard is a guard which depends on the
sequence of earlier invocations of the operations of the object
expressed in terms of history expressions (see section
\ref{sec:historyexpr}). History expressions denotes the number
of activations and completions of the operations, given as functions

\keyw{\#act} and \keyw{\#fin}, respectively.
\begin{quote}
\keyw{\#act}: operation name $\rightarrow$ $\Nat$ \\
\keyw{\#fin}: operation name $\rightarrow$ $\Nat$
\end{quote}

Furthermore, a derived function {\bf\ttfamily \#active} is available such that
{\bf\ttfamily \#active}{\tt (A}{\tt )} $=$ {\bf\ttfamily \#act}{\tt (A}{\tt )} $-$
{\bf\ttfamily \#fin}{\tt (A}{\tt )}, giving the number of currently active
instances of {\tt A}. Another history function -- {\bf\ttfamily{\#req}} -- is
defined in section~\ref{queuesec}.
\item[Examples:]
Consider a Web server\label{example:webserver} that is capable of
supporting 10 simultaneous
connections and can buffer a further 100 requests. In this case we
have one instance variable, representing the mapping from URLs to
local filenames:
\begin{lstlisting}
instance variables
  site_map : map URL to Filename := {|->}
\end{lstlisting}

The following operations are defined in this class (definitions
omitted for brevity):

\begin{tabular}{lll}
\texttt{ExecuteCGI:} & \texttt{URL ==> File} & Execute a CGI script on the server\\
\texttt{RetrieveURL:} & \texttt{URL ==> File} & Transmit a page of html\\
\texttt{UploadFile:} & \texttt{File * URL ==> ()} & Upload a file onto the server\\
\texttt{ServerBusy:} & \texttt{() ==> File} & Transmit a ``server busy'' page\\
\texttt{DeleteURL:} & \texttt{URL ==> ()} & Remove an obsolete file
\end{tabular}

Since the server can support only 10 simultaneous connects, we can
only permit an execute or retrieve operation to be activated if the
number already active is less than 10:
\begin{lstlisting}
    per RetrieveURL => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
    per ExecuteCGI  => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
\end{lstlisting}
\end{description}

\subsection{The object state guard}
\begin{description}
\item[Semantics:]
The object state guard is a boolean expression which depends on the values of
one (or more) instance variable(s) of the object itself. Object state
guards differ from operation pre-conditions in that a call to an
operation whose permission predicate is false results in the caller
blocking until the predicate is satisfied, whereas a call to an
operation whose pre-condition is false means the operation's behaviour
is unspecified.

\item[Examples:]
Using the web server example again, we can only allow file removal if
some files already exist:
\begin{lstlisting}
    per DeleteURL   => dom site_map <> {};
\end{lstlisting}

Constraints for safe execution of the operations {\tt Push} and {\tt Pop}
in a stack object can be expressed using an object state guard as:
\begin{lstlisting}
per Push => length < maxsize;
per Pop => length > 0;
\end{lstlisting}
where {\tt maxsize} and {\tt length} are instance variables of
the stack object.

It is often possible to express such constraints as a
consequence of the history,
for example the empty state of the stack:
\begin{lstlisting}
    length = 0 <=> #fin(Push) = #fin(Pop);
\end{lstlisting}
However, the size is a property which is better regarded as a
property of the particular stack instance, and in such cases it is
more elegant to use available instance variables which store the effects
of history.

%In replacing history expressions by state based ones, however,
%it should be remembered, that the change of a state value which
%results from an action, defined in a post-condition, may not occur as
%the last action of the corresponding operation.
%
%Furthermore, object state guards may only be used if mutual exclusion
%is specified in addition for all operations in order to avoid problems
%with possible simultaneous access to the instance variables.
\end{description}


\subsection{Queue condition guards}\label{queuesec}
\begin{description}
\item[Semantics:]
A queue condition guard acts on requests waiting in the queues for the
execution of the operations.
This requires use of a third history function {\bf\ttfamily \#req} such that
{\bf\ttfamily \#req}{\tt (A)} counts the number of messages which have been received by the
object requesting execution of operation {\tt A}.
Again it is useful to introduce the function {\bf\ttfamily \#waiting} such that:
{\bf\ttfamily \#waiting}{\tt (A}{\tt )} $=$ {\bf\ttfamily \#req}{\tt (A}{\tt )} $-$ {\bf\ttfamily \#act}{\tt (A}{\tt )},
which counts the number of items in the queue.

\item[Examples:]
Once again, with the web server we can only activate the
\texttt{ServerBusy} operation if 100 or more connections are waiting:
\begin{lstlisting}
per ServerBusy  => #waiting(RetrieveURL) +
                   #waiting(ExecuteCGI) >= 100;
\end{lstlisting}

The most important use of such expressions containing queue
state functions is for expressing priority between operations. The
protocol specified by:
%mutex(A,B) $\wedge$ per B \kw{=>} \#req(A) = 0
\begin{lstlisting}
per B => #waiting(A) = 0;
\end{lstlisting}
gives priority to waiting  requests for activation of {\tt A}. There
are, however, many other situations when operation dispatch depends on
the state of waiting requests.  Full description of the queuing
requirements to allow specification of operation selection based on
request arrival times or to describe `shortest job next' behaviour
will be a future development.

Note that \texttt{\#\keyw{req}(A)} have value 1 at the time of evaluation of
the permission predicate for the first invocation of operation
\texttt{A}. That is,
\begin{lstlisting}
per A => #req(A) = 0;
\end{lstlisting}
would always block.

\end{description}

\subsection{Evaluation of Guards}

Using the previous example, consider the following situation: the web
server is handling 10 \texttt{RetrieveURL} requests already. While it
is dealing with these requests, two further \texttt{RetrieveURL}
requests (from objects $O_1$ and $O_2$) and one \texttt{ExecuteCGI}
request (from object $O_3$) are received. The permission predicates
for these two operations are false since the number of active
\texttt{RetrieveURL} operations is already 10. Thus these objects
block.

Then, one of the active \texttt{RetrieveURL} operations reaches
completion. The permission predicate so far blocking $O_1$, $O_2$ and
$O_3$ will become ``true'' simultaneously.
This raises the question: which object is allowed to proceed? Or even
all of them?

Guard expressions are only reevaluated when an event occurs (in this
case the completion of a \texttt{RetrieveURL} operation). In addition to
that the test of a permission predicate by an object and its (potential)
activation is an atomic operation. This means, that when the first
object evaluates its guard expression, it will find it to be true and
activate the corresponding operation (\texttt{RetrieveURL} or
\texttt{ExecuteCGI} in this case). The other objects evaluating their
guard expressions afterwards will find that
\keyw{\#active}{\tt (RetrieveURL) +} \keyw{\#active}{\tt (ExecuteCGI) = 10}
and thus remain blocked. \textit{Which object is allowed to evaluate the guard
expression first is undefined.}

It is important to understand that the guard expression need only
evaluate to \keyw{true} at the time of the activation. In the
example as soon as $O_1$, $O_2$ or $O_3$'s request is activated its
guard expression becomes false again.


\section{Inheritance of Synchronization Constraints}
\label{ch:sync-inh}

Synchronization constraints specified in a superclass are inherited by
its subclass(es).
The manner in which this occurs depends on
the kind of synchronization.

\subsection{Mutex constraints}
Mutex constraints from base classes and derived classes are
simply added. If the base class and derived class have the mutex
definitions {$M_{A}$} and {$M_{B}$}, respectively, then the derived
class simply has both mutex constraints {$M_{A}$}, and
{$M_{B}$}. The binding of operation names to actual operations is
always performed in the class where the constraint is
defined. Therefore a \keyw{mutex(all)} constraint defined in a
superclass and inherited by a subclass only makes the operations from
the base class mutually exclusive and does not affect operations of
the derived class.

Inheritance of mutex constraints is completely analogous to the
inheritance scheme for  permission predicates. Internally mutex
constraints are always expanded into appropriate permission predicates
which are added to the existing permission predicates as a
conjunction. This inheritance scheme ensures that the result (the
final permission predicate) is the same, regardless of whether the mutex
definitions are expanded in the base class and inherited as permission
predicates or are inherited as mutex definitions and only expanded in
the derived class.

The intention for inheriting synchronization constraints in the way
presented is to ensure, that any derived class at least
satisfies the constraints of the base class.  In addition to that it
must be possible to strengthen the synchronization constraints. This
can be necessary if the derived class adds new operations as in the
following example:
\begin{lstlisting}
class A
operations

  writer: () ==> ()
  writer() == is not yet specified

  reader: () ==> ()
  reader() == is not yet specified

  sync
  per reader => #active(writer) = 0;
  per writer => #active(reader, writer) = 0;
end A

class B is subclass of A
operations

  newWriter: () ==> ()
  newWriter() == is not yet specified

  sync
  per reader => #active(newWriter) = 0;
  per writer => #active(newWriter) = 0;
  per newWriter => #active(reader, writer, newWriter) = 0;

end B
\end{lstlisting}

Class \texttt{A} implements reader and writer operations with the permission
predicates specifying the multiple readers-single writer protocol. The
derived class \texttt{B} adds \texttt{newWriter}. In order to ensure
deterministic behaviour \texttt{B} also has to add permission
predicates for the inherited operations.

The actual permission predicates in the derived class
are therefore:
\begin{lstlisting}
per reader => #active(writer)=0 and #active(newWriter)=0;
per writer => #active(reader, writer)=0 and #active(newWriter)=0;
per newWriter => #active(reader, writer, newWriter)=0;
\end{lstlisting}

A special situation arises when a subclass overrides an
operation from the base class. The overriding operation is
treated as a new operation.  It has no permission predicate (and in
particular inherits none) unless one is defined in the subclass.

The semantics of inheriting mutex constraints for overridden
operations is completely analogous: newly defined overriding
operations are not restricted by mutex definitions for equally named
operations in the base class. The \keyw{mutex(all)} shorthand makes all
inherited and locally defined operations mutually
exclusive. Overridden operations (defined in a base class) are not
affected. In other words, all operations, that can be called with an
unqualified name (``locally visible operations'') will be mutex to
each other.

%%% スレッド
%% \chapter{Threads (VDM++ and VDM-RT)}\label{ch:thread}
\chapter{スレッド (VDM++ and VDM-RT)}\label{ch:thread}

Objects instantiated from a class with a {\em thread} part are called
{\em active} objects.  The scope of the instance variables and
operations of the current class is considered to extend to the thread
specification. Note that from a tool perspective the thread for the
expression a user would like to evaluate in relation to a VDM model is
called a debug thread. This thread has a special role in the sense
that when it is finished the entire execution is completed (and thus
all other threads ready to be scheduled in or running will be thrown
away and aborted). If a session where a series of expressions are
being evaluated this is not true (in this case the other threads will
be continued when the next expression is executed,
see~\cite{Larsen&13a} for more details about ``sessions'').
Thus if one would like to ensure a specific number
of such other threads to be completed before stopping the execution
one needs to block the debug thread using a synchronisation as
explained in Chapter~\ref{ch:sync}.

\begin{description}
\item[Syntax:]  \Ruledef{thread definitions}{ \Lop{thread},
\OptPt{\Ruleref{thread definition}} } \Rule{thread definition}{
    \Ruleref{periodic thread definition} \dsep
    \Ruleref{procedural thread definition} }

  \Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation}  \dsep
    \Ruleref{sporadic obligation}
  }
\end{description}

Subclasses inherit threads from superclasses.
If a class inherits from several classes only one of these may declare
its own thread (possibly through inheritance). Furthermore, explicitly
declaring a thread in a subclass will override any inherited thread.

\section{Periodic Thread Definitions (VDM-RT)}\label{se:periodic-thread}

The periodic obligation can be regarded as the way of describing repetitive activities in a class.
As the `period' implies a explicit notion of time, this construct is only available in VDM-RT.

\begin{description}
%\item[Syntax (VDM++):] For VDM++, where time is not explicit, it looks like:
%
%\Ruledef{periodic obligation}{
%  \Lop{periodic},\Lit{(}, \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
%}
%
%\item[Semantics (VDM++):] The type of the expression should always yield a natural number, otherwise a run-time error will occur. The expression denotes the size of the time slice, after which the operation \Lop{name} is called, repetitively. The size of the time slice can be used to specify \emph{execution ratios} between multiple periodic threads in VDM++. Its behavior in relation to the other parts of the specification is defined by the interpreter settings with respect to time slicing and scheduling. Note however, that these values have \emph{no} explicit relation to real time.

\item[Syntax(VDM-RT):] Time is explicit in VDM-RT, using a discrete clock with a 1~nsec resolution, where the periodic obligation looks like:

  \Ruledef{periodic obligation}{
    \Lop{periodic}, \lfeed
    \Lit{(}, \Ruleref{expression}, \Ruleref{expression}, \Ruleref{expression},  \Ruleref{expression}, \Lit{)}, \lfeed \Lit{(}, \Ruleref{name}, \Lit{)}
  }

\item[Semantics (VDM-RT):] The type of the expressions should all yield a natural number (as we use a natural number valued wall-clock in the VDM-RT interpreter), otherwise a run-time error will occur. Note that the evaluation of the expressions also causes time to elapse whenever the \Lop{start} or \Lop{start\_list} statement is executed. The expressions all denote a time value with a resolution of 1~nsec.
For each periodic obligation, four different numbers are used. They are, in order
of appearance (also illustrated in Figure~\ref{fig:PeriodJitterDelayOffset}):

\begin{enumerate}
\item \textbf{period:} This is a non-negative, non-zero value that describes the length of the
time interval between two adjacent events in a strictly periodic event stream (where jitter = 0). Hence, a value of 1E9 denotes a period of 1~second.
\item \textbf{jitter:} This is a non-negative value that describes the amount of time variance that is allowed
around a single event. We assume that the interval is balanced [-j, j]. Note that jitter is
allowed to be bigger than the period to characterize so-called event bursts.
\item \textbf{delay:} This is a non-negative value smaller than the period which is used to denote the minimum
inter arrival distance between two adjacent events.
\item \textbf{offset:} This is a non-negative value which is used to denote the absolute time value at which
the first period of the event stream starts. Note that the first event occurs in the interval
[offset, offset + jitter].
\end{enumerate}

\begin{figure}
\begin{center}
\resizebox{0.8\textwidth}{!}{\includegraphics{pjdoTuple.png}}
\caption{{Period (p), jitter (j), delay (d) and offset (o)}\label{fig:PeriodJitterDelayOffset}}
\end{center}
\end{figure}

Given a defined time resolution $\Delta$T, a thread with a periodic
obligation invokes the mentioned operation at the beginning of each
time interval with length {\em period}.  This creates the periodic
execution of the operation simulating the discrete equivalent of
continuous relations which have to be maintained between instance
variables, parameter values and possibly other external values
obtained through operation invocations.  It is not possible to dynamically 
change the length of the interval.

Periodic obligations are intended to describe e.g.\
analogue physical relations between values in formulas (e.g.\ transfer
functions) and their discrete event simulation.
It is a requirement on the implementation to
guarantee that the execution time of the operation is at least smaller
than the used periodic time length.
If other operations are present the user has to guarantee that
the fairness criteria for the invocation of these other operations are
maintained by reasoning about the time slices used internally and
available for external invocations.

Note that a periodic thread is \textit{neither} created \textit{nor} started when an instance
of the corresponding class is created. Instead, as with procedural threads,
\Lop{start} (or \Lop{start\_list}) statements should be used with periodic threads.


\item[Examples:]
Consider a timer class which periodically increments its  clock in its
own thread. It provides operations for starting, and stopping timing,
and reading the current time.

\begin{lstlisting}
class Timer
values
  PERIOD : nat = 1000;
\end{lstlisting}

The Timer has two instance variables the current time and a flag
indicating whether the Timer is active or not (the current time is
only incremented if the Timer is active).
\begin{lstlisting}
instance variables
  curTime : nat := 0;
  acti    : bool := false;
\end{lstlisting}

The Timer provides straightforward operations which need no further
explanation.
\begin{lstlisting}
operations
  public Start : () ==> ()
  Start() ==
    (acti := true;
     curTime := 0);

  public Stop : () ==> ()
  Stop() ==
    acti := false;

  public GetTime : () ==> nat
  GetTime() ==
    return curTime;

  IncTime: () ==> ()
  IncTime() ==
    if acti
    then curTime := curTime + 100;
\end{lstlisting}

The Timer's thread ensures that the current time is incremented. The period 
with which this is done is 1000 time units (nanoseconds). The allowed jitter is 10 time units
and the minimal distance between two instances is 200 time units and finally
no offset has been used.
%We take one time unit for the Timer to correspond to 10 system time units.

\begin{lstlisting}
thread
  periodic (PERIOD, PERIOD/100, PERIOD/5, 0) (IncTime)

end Timer
\end{lstlisting}

\end{description}


\section{Sporadic Thread Definitions (VDM-RT)}\label{se:sporadic-thread}

The sporadic obligation can be regarded as the way
of describing stochastic activities in a class.

\begin{description}
\item[Syntax: (VDM-RT):]\mbox{}\\

  \Ruledef{sporadic obligation}{
    \Lop{sporadic}, \lfeed \Lit{(}, \Ruleref{expression},  \Ruleref{expression},   \Ruleref{expression},
    \Lit{)}, \lfeed \Lit{(}, \Ruleref{name}, \Lit{)}
  }

\item[Semantics: (VDM-RT)] The type of the expressions should all yield a natural number (as we use a natural number valued wall-clock in the VDM-RT interpreter), otherwise a run-time error will occur. Note that the evaluation of the expressions also causes time to elapse whenever the \Lop{start} or \Lop{start\_list} statement is executed. The expressions all denote a time value with a resolution of 1~nsec.
For each sporadic obligation, three different numbers are used. They are, in order
of appearance:

\begin{enumerate}
\item \textbf{delay:} This value is used to denote the minimum
inter arrival distance between two adjacent thread invocations.
\item \textbf{bound:} This value, greater than \textbf{delay}, is the maximum inter arrival distance between two adjacent thread invocations.
\item \textbf{offset:} This is a non-negative value which is used to denote the absolute time value at which the first period starts, randomly in the interval $[offset, offset + bound]$.
\end{enumerate}

Given these definitions, and assuming the last thread was invoked at $t_0$ then the next invocation is randomly scheduled in the interval $[t_0 + delay, t_0 + bound]$.

\item[Examples:]

Analogous to the example in \Lop{periodic} for the \texttt{Timer} class, the sporadic definition could be as follows:

\begin{lstlisting}
class Timer
...

thread
  sporadic (100, 1000, 0) (IncTime)

end Timer
\end{lstlisting}

\end{description}

\section{Procedural Thread Definitions (VDM++ and VDM-RT)}\label{se:proc-thread}

A procedural thread provides a mechanism to explicitly define the
external behaviour of an active object through the use of {\em
statements}, which are executed when the object is started (see
section \ref{sec:start}).
%Apart from the statements which are allowed
%in operation bodies (as described in  section \ref{sec:stmt}), it is
%also possible to use {\em answer statements} and {\em select
%statements}.
%based on similar constructs in the language {\small
%POOL}~\cite{Boer91}.
%These allow conditional behaviour within the thread depending on the
%environment.  An answer statement explicitly states that the object
%executing it is prepared to execute a (set of) operation(s).  A select
%statement specifies the conditional execution of operations.

\begin{description}
\item[Syntax:]
  \Ruledef{procedural thread definition}{
    \Ruleref{statement} }

%  \Rule{select statement}{
%    \Lop{sel},
%    \Lit{(},
%    \Ruleref{guarded command}, \lfeed
%    \SeqPt{\Lit{,},
%          \Ruleref{guarded command}},
%    \Lit{)}
%  }

%  \Rule{guarded command}{
%    \OptPt{\Ruleref{expression}},
%    \OptPt{\Ruleref{answer statement}}, \lfeed
%    \OptPt{\Lop{$->$},
%    \Ruleref{statement}}
%  }

%  \Rule{answer statement}{
%    \Lop{answer},
%    \Brack{\Ruleref{name} \dsepl
%    \Lop{all}}
%  }

\item[Semantics:] \mbox{}
A procedural thread is scheduled for execution following the
application of a start statement to the object owning the thread. The
statements in the thread are then executed sequentially, and when
execution of the statements is complete, the thread
dies. Synchronization between multiple threads is achieved using
permission predicates on shared objects.
%Select statements and answer statements can
%occur at any place in a thread and allow conditional execution of the
%thread on the basis of operation invocation requests received by the
%thread. Any number of select and answer statements may occur in a
%thread definition, and they may be freely mixed with other
%statements. Note that select and answer statements may only used in
%active objects (threads), though this restriction is presently not
%enforced by the Toolbox.
%
%The following provisos apply:
%\begin{itemize}
%\item {\em guarded command} may not be empty; it must contain one {\em
%expression}, {\em answer statement} or {\em statement} at minimum.
%\item {\em expression} in {\em guarded command} must be boolean (if it
%is absent its default value is {\bf\ttfamily true}).
%\item {\em name} in the rule for {\em answer statement} must be
%defined in the class or in one of its superclasses.
%\end{itemize}
%Guards without an answer statement can be used to describe the {\em
%else} behaviour of the select statement.
%
%An answer statement \texttt{\keyw{answer} o} waits until the thread
%receives a request for operation \texttt{o}. It then executes this and
%the statement terminates. The \texttt{\keyw{answer all}} statement
%waits until the thread receives a request for any operation defined in
%that class (or superclass), executes that operation and then
%terminates.
%
%The general form of the select statement is
%\begin{lstlisting}
%  \keyw{sel}
%     guard1, \keyw{answer} o1 -> s1,
%       \vdots
%     guardN, \keyw{answer} oN -> sN;
%\end{lstlisting}
%Each line after the \texttt{sel} is a guarded command. For each
%guarded command, each of the guard, answer statement,  and statement
%is optional, but at least one of them must appear.
%
%The select statement is then executed as follows:
%\begin{description}
%\item[Step 1:] All conditions of the guarded command \texttt{guard1}
%$\ldots$ \texttt{guardN} are evaluated.  The guards whose conditions
%result in false are discarded.  The remainder are known as {\em open}
%guards.
%\item[Step 2:] The set of operation names occurring in the answer
%statements of the open guards is determined ({\em open operation
%set}).  The set of all invocations of operations within the open
%operation set is determined (the open invocation set).
%
%We then have three choices
%\begin{description}
%\item[Choice 1] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are open guards without an answer statement
%\end{itemize}
%  then an arbitrary open guard without an answer statement is selected
%  and   its associated statement sequence is executed.  The select
%  statement then terminates.
%\item[Choice 2] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are {\em no} open guards without an answer statement
%\end{itemize}
%then the thread waits until an operation in the open operation set is
%invoked by another object. Following completion of this operation the
%corresponding statement is executed. After this the select statement
%terminates.
%\item[Choice 3] If the set of invocations is {\em not} empty then the
%invocation in the open invocation set which was received first is
%selected. An arbitrary guard with an answer statement matching the
%invoked operation is selected. The operation is executed and after
%that the statement sequence associated with that guard is
%executed. Following this the select statement terminates.
%\end{description}
%\end{description}
%
%In addition to the basic mechanism described above a few points are
%worth noting:
%\begin{itemize}
%\item A select statement must always contain at least one {\em open}
%guard.
%\item A calling object will block until its call is answered by the
%select statement.
%\item The calling object and the thread synchronize on the operation
%call. However if a guarded command includes an answer statement and a
%statement to be executed afterwards, synchronization only occurs on
%the operation named in the answer statement. That is, the calling
%object may proceed following completion of the operation, and does not
%wait for execution of the statement listed in the guarded command.
%\end{itemize}
%
\item[Examples:]  \mbox{}
The example below demonstrates procedural threads by using them to
compute the factorial of a given integer concurrently.

\begin{lstlisting}
class Factorial

instance variables
  result : nat := 5;
operations

public factorial : nat ==> nat
factorial(n) ==
  if n = 0
  then return 1
  else (dcl m : Multiplier;
        m := new Multiplier();
        m.calculate(1,n);
        start(m);
        result:= m.giveResult();
        return result
      )

end Factorial

class Multiplier

instance variables
  i : nat1;
  j : nat1;
  k : nat1;
  result : nat1

operations

public calculate : nat1 * nat1 ==> ()
calculate (first, last) ==
  (i := first; j := last);

doit : () ==> ()
doit() ==
( if i = j
  then result := i
  else (dcl p : Multiplier;
        dcl q : Multiplier;
        p := new Multiplier();
        q := new Multiplier();
        start(p);
        start(q);
        k := (i + j) div 2;
        -- division with rounding down
        p.calculate(i,k);
        q.calculate(k+1,j);
        result := p.giveResult() *  q.giveResult ()
       )
);

public giveResult : () ==> nat1
giveResult() ==
  return result;

sync
-- cyclic constraints allowing only the
-- sequence calculate; doit; giveResult

per doit => #fin (calculate) > #act(doit);
per giveResult => #fin (doit) > #act (giveResult);
per calculate => #fin (giveResult) = #act (calculate)

thread
  doit();

end Multiplier
\end{lstlisting}



%First we consider some examples which illustrate the
%basic mechanism of select statements. Suppose we have a thread with
%instance variables \texttt{x:\keyw{nat}}, \texttt{y:\keyw{nat}} and
%\texttt{l:\keyw{seq1 of nat}}, and operations \texttt{o1} and
%\texttt{o2}. Consider the following select statement:
%\begin{lstlisting}
%  \keyw{sel} (
%    x <= 0, \keyw{answer} o1 -> x:= 1,     -- gc1
%    x >= 0,\mbox{\hspace{0.2em}}          -> y := x,    -- gc2
%            \keyw{answer} o2 -> l := [1]   -- gc3 )
%\end{lstlisting}
%We consider a number of different scenarios:
%\begin{enumerate}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc1}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set consists of only \texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, \texttt{gc2} is open and has no answer
%statement. Therefore choice 1 is taken. The statement \texttt{y := x}
%is executed then the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & -3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} &
%[1,2,3]\\ \hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc2}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, and there are no open guards without an answer
%statement. Therefore choice 2 is taken and the thread waits. While it
%waits it can only respond to invocations of \texttt{o1} or
%\texttt{o2}. Suppose then that while waiting it receives a call to
%\texttt{o1}: \texttt{o1} is executed, then the statement \texttt{x :=
%1} is executed and the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and invocations have been received for operations \texttt{o1} and
%\texttt{o2} (\texttt{o2} arriving first).
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Now since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc3} is selected because the invocation of
%\texttt{o2} was received first. \texttt{o2} is executed and on
%completion the statement \texttt{l := [y]} is executed. The select
%statement then terminates.
%\end{description}
%
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and an invocation has been received for operation \texttt{o1}.
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains only \texttt{o1}.
%\item[Choice] Again, since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc1} is selected  and \texttt{o1} is
%executed. On completion the statement \texttt{ x:= 1} is executed. The
%select statement then terminates.
%\end{description}
%\end{enumerate}
%
%We now give a more complex example.  Suppose we wish to model the
%behaviour of an ATM machine. We might have the following instance
%variables:
%\begin{lstlisting}
%  \keyw{instance variables}
%    status : <InService> | <OutOfService> |  <CardInserted> |
%             <CardAccepted> := <InService>;
%    currentCard : [ATMCard] := \keyw{nil};
%    pinTries : \keyw{nat} := 0;
%    balance :  \keyw{nat} := 10000;
%    keypad : Keypad := \keyw{new} Keypad();
%    accountDB : AccountDB := \keyw{new} AccountDB();
%    retained : \keyw{set} of ATMCard := \{\};
%\end{lstlisting}
%Here \texttt{ATMCard} is a class representing an ATM card,
%\texttt{Keypad} is a simple object that models digit entry by the
%user, and \texttt{AccountDB} is an object modelling the mapping from
%card numbers to account details.
%
%We might wish to perform the following operations on this class (for
%brevity we do not include their definition here):
%
%\begin{tabular}{lll}
%\texttt{EnterCard :} & \texttt{ATMCard ==> ()}  & Enter a card into
%                          the machine\\
%\texttt{GetPin :}    & \texttt{() ==> ()}       & Get the PIN digits typed
%                                                  at \\
%                     &                          & the keypad\\
%\texttt{VerifyPin:}  & \texttt{\keyw{nat} ==> ()}
%                                                & Check the validity of the PIN \\
%                     &                          & given\\
%\texttt{RetainCard :}& \texttt{() ==> ()}       & Retain the card if three failed\\
%                     &                          & attempts to enter the PIN\\
%\texttt{WithdrawCash :}
%                     & \texttt{\keyw{nat} ==> ()}
%                                                & Withdraw cash\\
%\texttt{WithdrawCard :}
%                     & \texttt{() ==> ()}       & Withdraw card from the \\
%                     &                          & machine\\
%\texttt{ReplenishMachine :}
%                    & \texttt{() ==> ()}        & Refill machine with cash
%\end{tabular}
%
%Then we might specify the thread behaviour of this class as follows:
%\begin{lstlisting}
%    \keyw{while true do}
%      \keyw{if} status = <InService>
%      \keyw{then} (
%        \keyw{sel} (\keyw{answer} EnterCard);
%        \keyw{while} status <> <InService> \keyw{do}
%          \keyw{sel} ( status = <CardInserted> \keyw{and} pinTries < 3
%                               \keyw{answer} GetPin,
%               status = <CardInserted> \keyw{and} pinTries = 3
%                               -> RetainCard(),
%               status = <CardAccepted> \keyw{and} balance > 300
%                               \keyw{answer} WithdrawCash,
%               status = <CardAccepted> \keyw{answer} WithdrawCard
%              );
%        \keyw{if} balance <= 300
%        \keyw{then} status := <OutOfService> )
%      \keyw{else}
%        \keyw{sel} (status = <OutOfService> \keyw{answer} ReplenishMachine);
%\end{lstlisting}
%This thread repeatedly loops until the object is destroyed. Within
%this loop behaviour diverges according to whether \texttt{status =
%<InService>} or not. Initially the status is \texttt{<InService>} so
%the \texttt{then} clause will be executed. The thread will then wait
%until a card is entered into the machine.
%
%Following this we loop until the status returns to
%\texttt{<InService>}, which only occurs when the operations
%\texttt{WithdrawCard} or \texttt{RetainCard} are executed. Within this
%loop the thread conditionally allows invocations of the operations
%\texttt{GetPin}, \texttt{WithdrawCash} and
%\texttt{WithdrawCard}. Additionally the thread invokes
%\texttt{RetainCard} itself once 3 unsuccessful attempts have been made
%to enter a pin code.
%
%When this loop is exited the status is \texttt{<InService>}. However
%if insufficient cash is left in the machine it goes out of
%service. This terminates the \texttt{then} clause.
%
%In the \texttt{else} clause, it can be seen that the only way this
%clause can be entered is if the status is
%\texttt{<OutOfService>}. Thus the thread waits until the machine is
%replenished.
%
%Observe that in the second \keyw{sel} statement, if (\texttt{status =
%<CardAccepted>
%\keyw{and} balance > 300}) then the thread could behave
%non-deterministically, since two guards would be open simultaneously.
%
\end{description}
%
%Note that the two methods of specifying synchronization (permission
%predicates %, trace structures
%and answer statements) should not be
%mixed in a class specification: only one of these may be used.
%
%A procedural thread definition has precedence over a
%synchronization specification in a class; when using this way of
%specification, the full external behaviour of an active object has to
%be specified (i.e. for each operation an answer statement must be
%present).  The synchronization definitions can then be derived
%from the procedural thread.  If there is a contradiction between
%synchronization derived from the procedural thread and the specified
%synchronization behaviour then the class is erroneous.

%\section{Inheriting from Active Objects}
%\label{ch:thread-inh}
%
%Threads can, in some cases, be inherited in {\vdmpp}; the situations in which
%this is allowed are determined by whether or not there exists
%a sensible interpretation of polymorphism between active objects (see Section
%\ref{sec:polyao}). The different situations in which inheriting from
%active superclasses is allowed is summarized in the following table:
%
%{\small
%\begin{center}
%\begin{tabular}{|c||c|c|c|c|c|}
%\hline
%& & & {\em active,} & {\em active,}\\
%superclass & {\em none} & {\em passive} & {\em declarative} & {\em procedural}\\
%& & & {\em thread} & {\em thread}\\
%\hline
%\hline
%& & behaviour as & inheritance & inheritance\\
%{\em none} & --- & defined by & allowed, see & allowed, see\\
%& & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%& behaviour as & behaviour as & inheritance & inheritance \\
%{\em passive} & defined by & defined by & allowed, see & allowed, see \\
%& the subclass & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em declarative} & allowed, see & allowed, see & allowed, see & {\bf not} \\
%{\em thread} & Section \ref{decinh} & Section \ref{decinh} & Section \ref{decinh} & allowed\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em procedural} & allowed, see & allowed, see & {\bf not} & allowed, see \\
%{\em thread} & Section \ref{procinh} & Section \ref{procinh} & allowed & Section \ref{procinh} \\
%\hline
%\end{tabular}
%\end{center}}
%
%\subsection{Polymorphism for Active Objects}\label{sec:polyao}
%
%A basic issue for understanding polymorphism for active objects
%is the notion of risk of interference caused by the thread of such objects.
%A basic understanding to this is provided by the Bernstein rules.
% (see e.g. \cite{bernstein66} or \cite[pages 289--290]{peterson}).
%Bernstein defines the {\em read-set} $R$ for statement $S_i$, $\fnapply{R}{S_i} = \setrange{a_1, a_2}{a_n}$, as:
%\begin{quote}
%the set of all variables referenced in statement $S_i$, such that the value
%of each $a_j$ did not change during the execution of $S_i$.
%\end{quote}
%The {\em write-set} $W$ for statement $S_i$, $\fnapply{W}{S_i}= \setrange{b_1,
%b_2}{b_n}$, is then defined as:
%\begin{quote}
%the set of all variables referenced in
%statement $S_i$ such that each $b_j$ is
%updated (i.e. gets a new value) in $S_i$.
%\end{quote}
%
%The following three conditions must hold for two successive statements
%(say: $S_1$ and $S_2$) in order to be executed concurrently and always
%produce the same result as if they were executed sequentially (the
%Bernstein conditions):
%\begin{enumerate}
%\item
%$\fnapply{R}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\end{enumerate}
%
%As an example, consider two statements $S_1$ and $S_2$. Suppose that
%$S_1$ updates a variable $b$, and that $S_2$ is defined as
%$\ass{c}{a + b}$. Since
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \set{b}$, concurrent
%execution of $S_1$ and $S_2$ is not allowed.
%
%In a similar fashion, in {\vdmpp} the read- and write-sets can be defined
%for threads in terms of instance variables.
%
%For presentation purposes a distinction is made between active objects with
%a {\em declarative} thread (periodic obligation) and those with a
%{\em procedural} thread (sequence of statements using answer and select
%statements).
%
%\subsection{Declarative Threads}\label{decinh}
%
%Consider two classes {\tt A} and {\tt B} with a periodic obligation,
%for {\tt A}, say, defined as:
%  \begin{lstlisting}
%    periodic (intervalA)(mA)
%  \end{lstlisting}
%and for {\tt B}, say, defined as:
%  \begin{lstlisting}
%    periodic (intervalB)(mB)
%  \end{lstlisting}
%then a class {\tt C}, defined as subclass of both {\tt A} and {\tt B},
%has a new thread with {\it two} periodic obligations, e.g. graphically
%depicted as follows:
%\ \\
%\ \\
%\insertfig{2periodic}{14cm}{Periodic obligations for class C}{}
%
%
%\subsection{Procedural Threads}\label{procinh}
%
%Polymorphism for active objects of which the behaviour is defined using
%procedural threads instead of declarative threads is more complicated.
%In {\vdmpp} it is only considered for classes with a non-terminating
%behaviour\footnote{It is possible to define terminating threads, implying that
%these (initially) {\it active} objects become {\it passive} after some time.},
%e.g. defined using a loop, typically:
%  \begin{lstlisting}
%    while true do\\
%    sel (
%      condA -> answer mA,
%      condB -> answer mB,
%      ...
%      condN -> answer mN
%    )
%  \end{lstlisting}
%or
%  \begin{lstlisting}
%    while true do
%    answer mA;
%    answer mB;
%    ...
%    answer mN
%  \end{lstlisting}
%
%Procedural threads of these forms define `answer-sets/sequences', i.e.
%sets or sequences defining the possible (orders of) operations these
%objects will answer to.
%Defining a subclass of two classes with such definitions implies that
%the subclass has an answer-sets/sequence composed by taking the union
%or weaving the two answer-sets/sequences of the superclasses into one another.
%So, suppose that objects from class {\tt A} respond to
%
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n}
%\end{expr}
%\end{vdm}
%and that objects from class {\tt B} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_{n+1}, m_{n+2}}{m_p}
%\end{expr}
%\end{vdm}
%and that class {\tt C} is a subclass of both {\tt A} and {\tt B}, then
%objects from class {\tt C} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n, m_{n+1}, m_{n+2}, \ldots, m_p}
%\end{expr}
%\end{vdm}
%
%Because the scope in which the instance variables of
%an object are visible includes the procedural thread, a proof obligation is
%raised to satisfy the Bernstein conditions.
%No problems arise in the simple case where {\tt C} is a subclass of
%{\tt A} and {\tt B} and no further coupling is made in {\tt C}
%between the instance variables of {\tt A} and {\tt B} -- the threads of
%{\tt A} and {\tt B} in {\tt C} only affect the {\tt A} and {\tt B} part
%of the instance variables in {\tt C},
%respectively, hence the Bernstein conditions are always satisfied.
%If, however, a connection is made in {\tt C} between the two state parts
%through an invariant, then it is no longer guaranteed that the Bernstein
%conditions are satisfied.

%\cleardoublepage
%\chapter{Real-time Behaviour}\label{ch:rt}
%
%For the description of requirements and the behaviour of a system
%(component) in real time a small number of concepts suffice.  These
%concepts are based on
%references~\cite{Hayes90,Mahony&91a,Mahony&91b,Mahony92,Mahony&92}.
%At first the time continuous functions are defined and introduced as
%{\em time variables}. Existing concepts like pre-conditions,
%post-\-cond\-it\-ions, hooked values etc. are overloaded with their
%time aspects.
%
%For a complete (sub)system a development process starting in the
%continuous time domain is envisaged.  The initial input-output
%relations from the requirements can be decomposed into a topology of
%subcomponents through refinement steps in the continuous time domain.
%The continuous behaviour of the topology of the derived objects can be
%mapped on equivalent objects, which operate themselves sequentially in
%a discrete time domain.  Relations between the continuous and the
%discrete objects are established through inheritance.  The resulting
%objects can follow the more common {\vdmpp} refinement steps with
%additional descriptions and rules for their time behaviour. The
%resulting time behaviour of the lower level objects in the
%specification will give the limitations/requirements for the component
%implementation.
%
%Time continuous variables appear in classes with a special role
%in the specification. Spreading these functions in arbitrary places is not
%foreseen.
%
%\section{Time continuous Functions}
%\label{sec:timeexpr}
%
%Time continuous functions are those in which time can be assumed to
%increase continuously and implicitly, thus without any influence from
%the specification.
%
%At the input side of a system {\em assumptions} can be made about
%these continuous signals. In many cases these assumptions will
%represent the physical properties of the real-world signals and the
%available sensors in the environment.  Such an assumption is
%functionally equivalent to a {\em pre-condition}.  There is no way of
%enforcing this condition, however, because the environment is in
%principle beyond the scope of control of the system specifier.  The
%consequence of this observation is that the correct behaviour of the
%system can only be guaranteed for those time periods where these
%assumptions are met.  In all other cases the system will react in an
%undefined way or not at all.  In other words: the assumptions on input
%signals are environmental requirements.
%
%The syntactical representation of time continuous variables is
%realised through a syntactic block comparable with the instance
%variables block, beginning with the keyword {\tt time variables}. Then
%the declaration of the names of the time functions follow.  The
%function value changes over time either according to a given formula,
%with the time as an independent variable, or changes as an observation
%value of a physical quantity in the environment.
%
%\begin{description}
%\item[Syntax:]
%\Rule{time variable definitions}{\Lop{time}, \Lop{variables},
%      time spec, \SeqPt{\Lit{;}, time spec}, \OptPt{\Lop{;}}}
%\Rule{time spec}{time var decl \dsep assumption \dsep effect}
%\Rule{time var decl}{\OptPt{\Lop{input}}, name list, \Lit{:}, type}
%\Rule{assumption}{\Lop{assumption}, name list, \Lit{==}, expression}
%\Rule{effect}{\Lop{effect}, name list, \Lit{==}, expression}
%
%\item[Semantics:] If instances are created from a continuous class
%(and used through clientship by other objects) each object represents
%a distinct time continuous function which has in principle no relation
%with the functions in the other instances, i.e. different
%observations.  The following rules hold:
%
%\begin{itemize}
%\item If different subclasses are inheriting from the same continuous
%  superclass, they share the same function, i.e. the same observation of
%  the environment.
%\item If instances are created from a continuous class (and used
%  through clientship by other objects) each object represents a distinct
%  time continuous function which has in principle no relation with the
%  functions in the other instances, i.e. different observations.
%\item Sharing of the information available in an object as server for
%  more than one client object, has to be realised by referencing through
%  clientship to the same server object.
%\end{itemize}
%
%This interpretation can be used e.g. with a number of sensors for the
%temperature in a room; they measure the local temperature in a certain area
%Sharing of the information available can be achieved by using
%an object as server form more
%than one client object.
%The local temperature variations are discarded and
%only one room temperature is used in the model.
%
%A special clause can be added to a time continuous functions to denote
%assumptions over their behaviour.  The keywords used are {\tt
%assumptions} for input variables and {\tt effects} for output
%variables.
%
%The use of the operation interface is reserved for the discrete system
%behaviour and provides the specification of a sampling mechanism, when
%used on continuous variables.
%
%\item[Examples:] \mbox{}
%
%  \begin{lstlisting}
%  class SensorBehaviour
%
%    time variables
%      input theta: real;
%      input myinput: real;
%    assumption myinput == myinput (t) = a * sin (w * t)
%
%  end SensorBehaviour
%  \end{lstlisting}
%
%These functions are in another notation the continuous time functions:
%
%  \begin{lstlisting}
%    theta (t) = temperature (t)
%  \end{lstlisting}
%  and
%  \begin{lstlisting}
%    myinput (t) = a * sin (w * t)
%  \end{lstlisting}
%
%\end{description}
%
%\section{From Continuous Time to Discrete Time}
%
%\subsection{The input side}
%
%To express the way hardware/software based systems handle the continuous time
%problems a next refinement step will practically always mean the discretisizing
%of the continuous time functions. This means that a sampling mechanism has to
%be specified.
%
%The advised steps to specify this translation into the discrete time
%domain is to:
%
%\begin{enumerate}
%\item Inherit into a new {\vdmpp} class from the continuous class the time
%  function.
%\item Specify a sampling operation.
%\item Introduce a thread which regularly invokes this operation,
%  with sample frequency $f_s\;(=\; \frac{1}{\Delta t})$.
%\end{enumerate}
%
%Discrete sampling involves an approximation of the continuous value.
%If the interval length is $\Delta t$ in the interval $<t_1 , t_1 +
%\Delta t>$, a value within $F \ll t_1 \ldots t_1 + \Delta t \gg $ is
%returned as the discrete result. According to the theory of Shannon,
%the sampling frequency should be at least twice the highest frequency
%which is present in the input signal. The error in the approximation
%can be calculated with standard signal processing operations.
%
%The approximation in time is also needed to handle the fact, that discrete
%observations of ideal time continuous functions always include measurement
%errors, rounding off errors, limited accuracy, etc.
%
%\begin{description}
%\item[Examples:] The advised discretisizing operation as first
%  refinement for the continuous class is represented by the following
%  class based on the continuous temperature class:
%
%\begin{lstlisting}
%  class Sensor is subclass of SensorBehaviour
%
%    values
%      fs: real = undefined
%
%    instance variables
%      tempvalues: seq of real := [];
%      currvalue: real;
%    inv len tempvalues > 0 => currvalue = tempvalues(len)
%
%    operations
%      gettemp: () ==> ()
%      gettemp() ==
%      ( currvalue := theta(t);
%        tempvalues := tempvalues ^ [currvalue]
%      )
%
%   thread
%     periodic (1/fs)(gettemp)
%
%end Sensor
%\end{lstlisting}
%
%The introduced sequence of values now models the history of all
%samples.  In a normal case in which a $2^{nd}$ order differential
%equation can describe the system behaviour, the length can be reduced
%to three values: those at $t$, $t - \Delta t$ and $t - 2 \Delta t$
%will be sufficient.
%
%\end{description}
%
%\subsection{The output side}
%
%At the output side a similar approach can be used, although some special
%considerations are needed here.
%If the discrete class is the `producer' of a series of discrete values over
%time, the output of the system itself will be continuous again.
%Therefore, the impossibility for real signals to perform discontinuous behaviour
%has to be build in.
%
%\begin{description}
%\item[Example:] In class {\tt HeaterController} there is an instance
%variable {\tt controlvalue} which represented at each time the
%discrete value of the output of the controller.  The transformation
%backwards into the continuous domain is again performed with an
%operation which sets at discrete time intervals the value of the
%continuous time variable.  At the times in between these moments the
%effect constraint specifies the maximum rate that can be achieved in
%the continuous domain.
%
%The two classes can be specified as follows:
%  \begin{lstlisting}
%  class HCBehaviour
%
%    time variables
%      controloutput: real
%
%  end HCBehaviour
%
%  class HeaterController is subclass of HCBehaviour
%
%    instance variables
%      controlvalue: nat
%
%    operations
%      setheatercontrol: () ==> ()
%      setheatercontrol() ==
%        controloutput(now) := controloutput
%
%    thread
%      periodic (1/fs) (setheatercontrol)
%
%  end HeaterController
%  \end{lstlisting}
%\end{description}
%
%The relation between the momentary values coming from the discrete world to
%the continuous time functions requires some extra discussion.
%The specific relationship between the discrete value and its continuous
%counterpart requires the concept of controlled register-like variables in the
%continuous domain, which
%do not change in time between two successive updates by the operation.
%Given a sampling distance $\Delta t$ and an interval beginning at $t_i$ with
%a value $F(t_i)$, the step reaction
%of the system will take some time constant say $\tau$ with
%$\tau \leq \Delta t$ to stabilise the output value. This value $\tau$ can be
%derived from the effect constraint. This gives the following continuous time
%behaviour:
%\begin{itemize}
%\item
%$<t_i,t_i + \tau>$: the rate defined by constraint,
%value within $F \ll t_{i-1} \ldots t_i \gg$ or equivalently
%$[F(t_{i-1}),F(t_i)]$ excluding possible `overshoot';
%\item
%$<t_i + \tau ,t_i + \Delta t>$: value should have been stabilised on $F(t_i)$;
%\item
%at $t_i + \Delta t$: value is $F(t_i)$.
%\end{itemize}
%
%This time description is of course a kind of macro description of the
%continuous output value. By including the behaviour of more detailed output
%channel components one can refine the above mentioned intervals again.
%The above specification is effectively
%the behaviour of a certain digital-to-analogue converter.

%%%
%% \chapter{Trace Definitions}\label{chap:trace}
\chapter{トレース定義}\label{chap:trace}

In order to automate the testing process VDM-10 contains a notation
enabling the expression of the traces that one would like to have
tested exhaustively. Such traces are used to express combinations of
sequences of operations that wish to be tested in all possible
combinations. In a sense this is similar to model checking limitations
except that this is done with real and not symbolic values. However,
errors in test cases are filtered away so other test cases with the
same prefix will be skipped automatically.

\begin{description}
\item[Syntax:]
\Ruledef{traces definitions}{\Lop{traces},
   \OptPt{named trace}, \SeqPt{\Lit{;}, \Ruleref{named trace}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term},
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition} \dsep
  \Ruleref{trace definition term}, \Lit{|}, \Ruleref{trace definition}
}

\Rule{trace definition}{
  \Ruleref{trace binding definition} \dsep
  \Ruleref{trace repeat definition}
}

\Ruledef{trace binding definition}{
  \Ruleref{trace let def binding} \dsep
  \Ruleref{trace let best binding}
}

\Ruledef{trace let def binding}{
  \Lop{let}, \Ruleref{local definition},
  \SeqPt{ \Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace let best binding}{
  \Lop{let} \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace repeat definition}{
  \Ruleref{trace core definition},
  \OptPt{\Ruleref{trace repeat pattern}}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{,}
  \Ruleref{numeric literal}, \Lit{\}}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace concurrent expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{call statement}
}

\Rule{trace concurrent expression}{
  \Lit{||}, \Lit{(}, \Ruleref{trace definition}, \lfeed
  \Lit{,}, \Ruleref{trace definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{trace definition}}, \Lit{)}
}

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\item[Semantics:] Semantically the trace definitions provided in a
             class have no effect. These definitions are simply used
             to enhance testing of a VDM specification using principles from
             combinatorial testing (also called all-pairs
             testing). So each trace definition can be considered as a
             regular expression describing the test sequences in which
             different operations should be executed to test the VDM
             specification. Inside the trace definitions, bindings may appear
             and for each possible binding a particular test case
             can be automatically derived. So one trace definition
             expands into a set of test cases. In this sense a test
             case is a sequence of operation calls executed after each
             other. Between each test case the VDM specification is
             initialised so they become entirely independent. From a
             static semantics perspective it is important to note that
             the expressions used inside trace definitions must be
             executed in the expansion process. This means that it
             cannot directly refer to instance variables, because
             these could be changed during the execution.

So here it makes sense to explain what kind of expansion the different
kinds of trace definitions gives rise to.

The \emph{trace definition lists} simply use a semicolon (``\texttt{;}'') and
this results in sequencing between the \emph{trace definition
  terms} used inside it.

In the \emph{trace definition term} it is possible to introduce
alternatives using the bar (``\texttt{|}'') operator. This results in
test cases for all alternatives.

The \emph{trace binding definition} exists in two forms where the
\emph{trace let def binding} simply enables the binding introduced to
be used after the \Lop{in} in the same way as in
let-expressions. Alternatively the \emph{trace let best binding} can
be used and this will expand to test cases with all the different
possible bindings.

The \emph{trace repeat definition} is used to introduce the
possibility of having repetitions of the operation calls used in the
trace.
The different kinds of repeat patterns have the following meanings:
\begin{itemize}
\item  \Lit{*} means 0 to n occurences (n is tool specific).
\item  \Lit{+} means 1 to n occurences (n is tool specific).
\item  \Lit{?} means 0 or 1 occurences.
\item  \Lit{\{}, n, \Lit{\}} means n occurences.
\item  \Lit{\{}, n, \Lit{,} m \Lit{\}} means between n and m occurences.
\end{itemize}

The \emph{trace core definitions} have three possibilities. These are
ordinary operation calls, trace concurrency expressions and bracketed
trace definitions respectively.
The \emph{trace concurrency expressions} are similar to the
\emph{nondeterministic statements} in the sense that the trace
definition lists inside it will be executed in all possible
permulations of the elements. This is particular useful for concurrent
VDM++ models where potential deadlocks can occur under some
circumstances.

\item[Examples:] In an example like the one below test cases will be
generated in all possible combination starting with a call
of \texttt{Reset} followed by one to four \texttt{Push}es of values
onto the stack followed again by one to three \texttt{Pop}s from the stack. \\
\begin{lstlisting}
class Stack

instance variables
    stack : seq of int := [];

operations

    public Reset : () ==> ()
    Reset () ==
      stack := [];

    public Pop : () ==> int
    Pop() ==
      def res = hd stack in
        (stack := tl stack;
         return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack;

    public Push: int ==> ()
    Push(elem) ==
      stack := stack ^ [elem];

    public Top : () ==> int
    Top() ==
      return (hd stack);

end Stack
class UseStack

instance variables

  s : Stack := new Stack();

traces

  PushBeforePop : s.Reset();
                  (let x in set {1,2} in s.Push(x)){1,4};
                  s.Pop(){1,3}

end UseStack
\end{lstlisting}
\end{description}



\bibliographystyle{newalpha}

\bibliography{../bib/dan}

\appendix

% Do not delete next line:
% Start Of Rules

\chapter{The Syntax of the VDM Languages} \label{app-a}

This appendix specifies the complete syntax for
the VDM languages.

\section{VDM-SL Document}

\Ruledef{document}{
  \Ruleref{any module}, \SeqPt{\Ruleref{any module}} \dsep
   \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{any module}{
  \Ruleref{module}
%\dsep
%  \Ruleref{dynamic link module}
  }

\subsection{Modules}

This entire subsection is not present in the current version of the
VDM-SL standard.
% \marginpar{\hspace*{-3mm}\fbox{{\footnotesize Non standard}}}

\Ruledef{module}{
  \Lop{module}, \Ruleref{identifier}, \Ruleref{interface}, \lfeed
  \OptPt{\Ruleref{module body}}, \Lop{end}, \Ruleref{identifier}
  }

\Ruledef{interface}{
  \OptPt{\Ruleref{import definition list}}, \lfeed
  \Ruleref{export definition}
  }

\Ruledef{import definition list}{
  \Lop{imports}, \Ruleref{import definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{import definition}}
  }

\Ruledef{import definition}{
  \Lop{from}, \Ruleref{identifier}, \Ruleref{import module signature}
  }

\Ruledef{import module signature}{
  \Lop{all} \dsep
  \Ruleref{import signature}, \SeqPt{\Ruleref{import signature}}
  }

\Ruledef{import signature}{
  \Ruleref{import types signature} \dsep
  \Ruleref{import values signature} \dsep
  \Ruleref{import functions signature} \dsep
  \Ruleref{import operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{import types signature}{
  \Lop{types}, \Ruleref{type import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type import}}, \OptPt{\Lit{;}}
  }

\Ruledef{type import}{
  \Ruleref{name}, \OptPt{\Lop{renamed}, \Ruleref{name}} \dsep
  \Ruleref{type definition}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import values signature}{
  \Lop{values}, \Ruleref{value import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value import}}, \OptPt{\Lit{;}}
  }

\Ruledef{value import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import functions signature}{
  \Lop{functions}, \Ruleref{function import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function import}}, \OptPt{\Lit{;}}
  }

\Ruledef{function import}{
  \Ruleref{name}, \OptPt{\OptPt{type variable list},
  \Lit{:}, \Ruleref{function type}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{import operations signature}{
  \Lop{operations}, \Ruleref{operation import}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation import}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation import}{
  \Ruleref{name}, \OptPt{\Lit{:}, \Ruleref{operation type}}, \OptPt{\Lop{renamed}, \Ruleref{name}}
  }

\Ruledef{export definition}{
  \Lop{exports}, \Ruleref{export module signature}
  }

\Ruledef{export module signature}{
  \Lop{all} \dsep
  \Ruleref{export signature}, \lfeed
  \SeqPt{\Ruleref{export signature}}
  }

\Ruledef{export signature}{
  \Ruleref{export types signature} \dsep
  \Ruleref{export values signature} \dsep
  \Ruleref{export functions signature} \dsep
  \Ruleref{export operations signature}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{export types signature}{
  \Lop{types}, \Ruleref{type export}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{type export}}, \OptPt{\Lit{;}}
  }

\Ruledef{type export}{
  \OptPt{\Lop{struct}}, \Ruleref{name}
  }

\Ruledef{export values signature}{
  \Lop{values}, \Ruleref{value signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{value signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{value signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{export functions signature}{
  \Lop{functions} \Ruleref{function signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{function signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{function signature}{
  \Ruleref{name list}, \OptPt{\Ruleref{type variable list}}, \Lit{:},  \lfeed
  \Ruleref{function type}
  }

\Ruledef{export operations signature}{
  \Lop{operations} \Ruleref{operation signature}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{operation signature}}, \OptPt{\Lit{;}}
  }

\Ruledef{operation signature}{
  \Ruleref{name list}, \Lit{:}, \Ruleref{operation type}
  }

%\Ruledef{state signature}{
%  \Lop{state}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
%  }

%\Ruledef{dynamic link module}{
%  \Lop{dlmodule}, \Ruleref{identifier}, \lfeed
%  \Ruleref{dynamic link interface},\lfeed
%  \OptPt{\Ruleref{use signature}},\lfeed
%  \Lop{end}, \Ruleref{identifier}
%  }

%\Ruledef{dynamic link interface}{
%  \OptPt{\Ruleref{dynamic link import definition list}}, \lfeed
%  \Ruleref{dynamic link export definition}
%  }

%\Ruledef{use signature}{
%   \Lop{uselib}, \Ruleref{text literal}
%   }

%\Ruledef{dynamic link import definition list}{
%  \Lop{imports}, \lfeed
%  \Ruleref{dynamic link import definition}, \lfeed
%  \SeqPt{\Lit{,}, \Ruleref{dynamic link import definition}}
%  }

%\Ruledef{dynamic link import definition}{
%  \Lop{from}, \Ruleref{identifier}, \lfeed
%  \Ruleref{dynamic link import types signatures}
%  }

%\Ruledef{dynamic link import types signatures}{
%  \Lop{types}, \Ruleref{name}, \lfeed
%  \SeqPt{\Lit{;}, \Ruleref{name}}, \OptPt{\Lit{;}}
%  }

%\Ruledef{dynamic link export definition}{
%  \Lop{exports}, \lfeed
%  \Ruleref{dynamic link export signature}, \lfeed
%  \SeqPt{\Ruleref{dynamic link export signature}}
%  }

%\Ruledef{dynamic link export signature}{
%  \Ruleref{values signature} \dsep
%  \Ruleref{functions signature} \dsep
%  \Ruleref{operations signature}
%  }

\section{VDM++ and VDM-RT Document}

\Ruledef{document}{
   \Ruleref{class}
   \dsepl\ \Ruleref{system}
   , \SeqPt{\Ruleref{class}
   \dsepl\ \Ruleref{system}
   }
}


\section{System (VDM-RT)}

\Ruledef{system}{
  \Lop{system}, \Ruleref{identifier},  \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}

\subsection{Classes}

\Ruledef{class}{
  \Lop{class}, \Ruleref{identifier}, \OptPt{\Ruleref{inheritance clause}}, \lfeed
  \OptPt{\Ruleref{class body}}, \lfeed
  \Lop{end}, \Ruleref{identifier}
}

\Ruledef{inheritance clause}{
      \Lop{is subclass of}, \Ruleref{identifier}, \Lit{,}, \SeqPt{\Ruleref{identifier}}
      }

\section{Definitions}

\Ruledef{class body}{
  \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{module body}{
  \Lop{definitions}, \Ruleref{definition block}, \SeqPt{\Ruleref{definition block}}
  }

\Ruledef{definition block}{
  \Ruleref{type definitions} \dsep
  \Ruleref{state definition} \dsep
  \Ruleref{value definitions} \dsep
  \Ruleref{function definitions} \dsep
  \Ruleref{operation definitions}
  \dsep
  \Ruleref{instance variable definitions} \dsep
%  \Ruleref{time variable definitions} \dsep
  \Ruleref{synchronization definitions} \dsep
  \Ruleref{thread definitions} \dsep
  \Ruleref{traces definitions}
  }

\subsection{Type Definitions}
\label{mathCSTypeDefs}

\Ruledef{type definitions}{
  \Lop{types},
  \OptPt{\Ruleref{access type definition}}
         , \lfeed
         \SeqPt{\Lit{;},
               {\Ruleref{access type definition}}},
         \OptPt{\Lit{;}}
        }
%  }%
  \nonstandard{1}

  \Ruledef{access type definition}{
     (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
     \Ruleref{type definition}
    }

The access part is only possible in VDM++ and VDM-RT.

  \Ruledef{access}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }

\Ruledef{type definition}{
  \Ruleref{identifier}, \Lit{=}, \Ruleref{type}, \OptPt{\Ruleref{invariant}} \dsep
  \Ruleref{identifier}, \Lit{::}, \Ruleref{field list}, \OptPt{\Ruleref{invariant}}
  }

\Ruledef{type}{
  \Ruleref{bracketed type} \dsep
  \Ruleref{basic type} \dsep
  \Ruleref{quote type} \dsep
  \Ruleref{composite type} \dsep
  \Ruleref{union type} \dsep
  \Ruleref{product type} \dsep
  \Ruleref{optional type} \dsep
  \Ruleref{set type} \dsep
  \Ruleref{seq type} \dsep
  \Ruleref{map type} \dsep
  \Ruleref{partial function type} \dsep
  \Ruleref{type name} \dsep
  \Ruleref{type variable}
  }

\Ruledef{bracketed type}{
  \Lit{(}, \Ruleref{type}, \Lit{)}
  }

\Ruledef{basic type}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token}
  }

\Ruledef{quote type}{
  \Ruleref{quote literal}
  }

\Ruledef{composite type}{
  \Lop{compose}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \Lop{end}
  }

\Ruledef{field list}{
  \SeqPt{\Ruleref{field}}
  }

\Ruledef{field}{
  \OptPt{\Ruleref{identifier}, \Lit{:}}, \Ruleref{type} \dsep
  \OptPt{\Ruleref{identifier}, \Lit{:-}}, \Ruleref{type}
  }

\Ruledef{union type}{
  \Ruleref{type}, \Lit{|}, \Ruleref{type}, \SeqPt{\Lit{|}, \Ruleref{type}}
  }

\Ruledef{product type}{
  \Ruleref{type}, \Lit{*}, \Ruleref{type}, \SeqPt{\Lit{*}, \Ruleref{type}}
  }

\Ruledef{optional type}{
  \Lit{[}, \Ruleref{type}, \Lit{]}
  }

\Ruledef{set type}{
  \Ruleref{set0 type} \dsep
  \Ruleref{set1 type}
}

\Ruledef{set0 type}{
  \Lop{set of}, \Ruleref{type}
  }

\Ruledef{set1 type}{
  \Lop{set1 of}, \Ruleref{type}
  }

\Ruledef{seq type}{
  \Ruleref{seq0 type} \dsep
  \Ruleref{seq1 type}
  }

\Ruledef{seq0 type}{
  \Lop{seq of}, \Ruleref{type}
  }

\Ruledef{seq1 type}{
  \Lop{seq1 of}, \Ruleref{type}
  }

\Ruledef{map type}{
  \Ruleref{general map type} \dsep
  \Ruleref{injective map type}
  }

\Ruledef{general map type}{
  \Lop{map}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{injective map type}{
  \Lop{inmap}, \Ruleref{type}, \Lop{to}, \Ruleref{type}
  }

\Ruledef{function type}{
  \Ruleref{partial function type} \dsep
  \Ruleref{total function type}
  }

\Ruledef{partial function type}{
  \Ruleref{discretionary type}, \Lit{->}, \Ruleref{type}
  }

\Ruledef{total function type}{
  \Ruleref{discretionary type}, \Lit{+>}, \Ruleref{type}
  }

\Ruledef{discretionary type}{
  \Ruleref{type} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{type name}{
  \Ruleref{name}
  }

\Ruledef{type variable}{
  \Ruleref{type variable identifier}
  }

%#ifdef VDMPP
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }

\subsection{The VDM-SL State Definition}

\Ruledef{state definition}{
  \Lop{state}, \Ruleref{identifier}, \Lop{of}, \Ruleref{field list}, \lfeed
  \OptPt{\Ruleref{invariant}}, \OptPt{\Ruleref{initialisation}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}
\Ruledef{invariant}{
  \Lop{inv}, \Ruleref{invariant initial function}
  }

\Ruledef{initialisation}{
  \Lop{init}, \Ruleref{invariant initial function}
  }

\Ruledef{invariant initial function}{
  \Ruleref{pattern}, \Lit{==}, \Ruleref{expression}
  }

\subsection{Value Definitions}

\Ruledef{value definitions}{
  \Lop{values},
  \OptPt{\Ruleref{access value definition}}, \lfeed
         \SeqPt{\Lit{;},
               \Ruleref{access value definition}
               },
         \OptPt{\Lit{;}}
        }
%  }
  \nonstandard{1}

%  \ifthenelse{\boolean{VDMpp}}{
    \Rule{access value definition}{
       \OptPt{\Ruleref{access}},
         \Ruleref{value definition}
    }
%}{}

\Ruledef{value definition}{
  \Ruleref{pattern}, \OptPt{\Lit{:}, \Ruleref{type}}, \Lit{=}, \Ruleref{expression}
  }
  \nonstandard{1}

\subsection{Function Definitions}\label{functiondef2}

\Ruledef{function definitions}{
  \Lop{functions},
  \OptPt{\Ruleref{access function definition}}, \lfeed
         \SeqPt{\Lit{;},
                \Ruleref{access function definition}},
         \OptPt{\Lit{;}
        }
  }
%  \nonstandard{1}

%\ifthenelse{\boolean{VDMpp}}{
  \Rule{access function definition}{
    \OptPt{\Ruleref{access}},
      \Ruleref{function definition}
  }
%}{}

\Ruledef{function definition}{
  \Ruleref{explicit function definition} \dsep
  \Ruleref{implicit function definition} \dsep
  \Ruleref{extended explicit function definition}
  }
  \nonstandard{1}

\Ruledef{explicit function definition}{
  \Ruleref{identifier},
  \OptPt{\Ruleref{type variable list}},
  \Lit{:}, \lfeed
  \Ruleref{function type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{measure}, \Ruleref{name}}
  }
  \nonstandard{1}

\Ruledef{implicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}
  }

In VDM-SL extended explicit function definition looks like:

%This should be removed and exchanged with a more general solution.
%#ifdef VDMSL
%\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

%\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}
%#endif VDMSL
In VDM++ and VDM-RT extended explicit function definition looks like:
%#ifdef VDMPP
\Ruledef{extended explicit function definition}{
  \Ruleref{identifier}, \OptPt{\Ruleref{type variable list}}, \lfeed
  \Ruleref{parameter types}, \lfeed
  \Ruleref{identifier type pair list}, \lfeed
  \Lit{==}, \Ruleref{function body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
}
%#endif VDMPP

\Ruledef{type variable list}{
  \Lit{[}, \Ruleref{type variable identifier}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{type variable identifier}}, \Lit{]}
  }

\Ruledef{identifier type pair}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{parameter types}{
  \Lit{(}, \OptPt{\Ruleref{pattern type pair list}}, \Lit{)}
  }

\Ruledef{identifier type pair list}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{identifier}, \Lit{:}, \Ruleref{type}}
}

\Ruledef{pattern type pair list}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern list},\Lit{:}, \Ruleref{type}}
  }

\Ruledef{parameters list}{
  \Ruleref{parameters}, \SeqPt{\Ruleref{parameters}}
  }

\Ruledef{parameters}{
  \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }

\Ruledef{function body}{
  \Ruleref{expression} \dsep
  \Lop{is subclass responsibility} \dsep
  \Lop{is not yet specified}
  } \nonstandard{1}

\subsection{Operation Definitions}\label{op-def2}

\Ruledef{operation definitions}{
  \Lop{operations},
  \OptPt{\Ruleref{access operation definition}}, \lfeed
         \SeqPt{\Lit{;},
                \Ruleref{access operation definition}
               },
         \OptPt{\Lit{;}}
  }\nonstandard{1}

%  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{access operation definition}{(
%#ifdef VICEMAN
      \OptPt{\Lop{pure}}, \OptPt{\Lop{async}}
%#endif VICEMAN
      \OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep\
     (
%#ifdef VICEMAN
      \OptPt{\Lop{pure}}, \OptPt{\Lop{async}}
%#endif VICEMAN
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
      \Ruleref{operation definition}
    }
%}{}

\Ruledef{operation definition}{
  \Ruleref{explicit operation definition} \dsep
  \Ruleref{implicit operation definition} \dsep
  \Ruleref{extended explicit operation definition}
  }\nonstandard{1}

\Ruledef{explicit operation definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{operation type}, \lfeed
  \Ruleref{identifier}, \Ruleref{parameters}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{operation body}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}
%#ifdef VDMPP
%  , \lfeed
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}
%#endif VDMPP
  }\nobreak\nonstandard{1}

\Ruledef{implicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Ruleref{implicit operation body}
  }

\Ruledef{implicit operation body}{
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \Lop{post}, \Ruleref{expression}, \lfeed
  \OptPt{\Ruleref{exceptions}}
  }

\Ruledef{extended explicit operation definition}{
  \Ruleref{identifier}, \Ruleref{parameter types}, \lfeed
  \OptPt{\Ruleref{identifier type pair list}}, \lfeed
  \Lit{==}, \Ruleref{operation body}, \lfeed
  \OptPt{\Ruleref{externals}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{expression}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{expression}}, \lfeed
  \OptPt{\Ruleref{exceptions}}
}\nonstandard{7}

\Ruledef{operation type}{
  \Ruleref{discretionary type}, \Lit{==>}, \Ruleref{discretionary type}
  }

\Ruledef{operation body}{
  \Ruleref{statement} \dsep
  \Lop{is subclass responsibility} \dsep
  \Lop{is not yet specified}
  } \nonstandard{1}

\Ruledef{externals}{
  \Lop{ext}, \Ruleref{var information}, \SeqPt{\Ruleref{var information}}
  }

\Ruledef{var information}{
  \Ruleref{mode}, \Ruleref{name list}, \OptPt{\Lit{:}, \Ruleref{type}}
  }

\Ruledef{mode}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{exceptions}{
  \Lop{errs}, \Ruleref{error list}
  }

\Ruledef{error list}{
  \Ruleref{error}, \SeqPt{error}
  }

\Ruledef{error}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{expression}, \Lit{->}, \Ruleref{expression}
  }

\subsection{Instance Variable Definitions (VDM++ and VDM-RT)}

\Ruledef{instance variable definitions}{
  \Lop{instance}, \Lop{variables}, \lfeed
  \OptPt{\Ruleref{instance variable definition}, \lfeed
         \SeqPt{\Lit{;},
               \Ruleref{instance variable definition}
               }
        }
  }

\Ruledef{instance variable definition}{
  \Ruleref{access assignment definition} \dsep
  \Ruleref{invariant definition}
  }

  \Rule{access assignment definition}{
    (\OptPt{\Ruleref{access}}, \OptPt{\Lop{static}})  \dsep
    (\OptPt{\Lop{static}}, \OptPt{\Ruleref{access}}), \lfeed
    \Ruleref{assignment definition}
  }

\Ruledef{invariant definition}{
  \Lop{inv}, \Ruleref{expression}
  }

%\Ruledef{init statement}{
%  \Lop{init}, \Ruleref{statement}
%  }

%\subsection{Time Variable Definitions}
%
%\Ruledef{time variable definitions}{
%      \Lop{time}, \Lop{variables},
%      \Ruleref{time spec}, \SeqPt{\Lit{;}, \Ruleref{time spec}}, \OptPt{\Lop{;}}}
%\Ruledef{time spec}{
%      \Ruleref{time var decl} \dsep \Ruleref{assumption} \dsep \Ruleref{effect}}
%\Ruledef{time var decl}{
%      \OptPt{\Lop{input}}, \Ruleref{name list}, \Lit{:}, \Ruleref{type}}
%\Ruledef{assumption}{
%      \Lop{assumption}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
%\Ruledef{effect}{
%      \Lop{effect}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}

\subsection{Synchronization Definitions (VDM++ and VDM-RT)}

\Ruledef{synchronization definitions}{
      \Lop{sync}, \OptPt{\Ruleref{synchronization}}}

\Ruledef{synchronization}{
      \Ruleref{permission predicates} %\dsep
%      \Ruleref{trace structures}
}

\Ruledef{permission predicates}{
      \Ruleref{permission predicate},\lfeed
      \SeqPt{\Lit{;}, \Ruleref{permission predicate}}}
\Ruledef{permission predicate}{
      \Lop{per}, \Ruleref{name},
      \Lop{=$>$}, \Ruleref{expression} \dsep
      \Ruleref{mutex predicate}}

\Ruledef{mutex predicate}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{name list} \Lit{)}}

% \Ruledef{trace structures}{
%       \SeqPt{\Ruleref{subtrace structure}, \Lit{;}},
%       \Ruleref{general trace structure}}
% \Ruledef{subtrace structure}{
%       \Lop{subtrace}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}
% \Ruledef{general trace structure}{
%       \Lop{general}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}

% \Ruledef{trace structure}{
%      \Ruleref{identifier} \dsep
%      \Lit{$<$}, \Ruleref{trace set}, \Lit{,}, \Ruleref{alphabet}, \Lit{$>$} \dsep
%      \Lop{pref}, \Lit{(}, \Ruleref{trace structure}, \Lit{)} \dsep
%      \Lop{del}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{w\_}, \Ruleref{trace structure} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{sync}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{{qsync}}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \lfeed
%      \Lit{,}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{**}, \Ruleref{alphabet}}
% \Ruledef{alphabet}{
%       \Lit{\{}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}, \Lit{\}} \dsep
%       \Lop{a\_}, \Ruleref{trace structure}}

% \Ruledef{trace set}{
%      \Ruleref{trace expression} \dsepl
%      \Ruleref{alphabet}, \Lit{$\ast$} \dsepl
%      \Lop{t\_}, \Ruleref{trace structure}}
% \Ruledef{trace expression}{
%       \Ruleref{term}, \SeqPt{\Lit{;}, \Ruleref{term}}}
% \Ruledef{term}{
%       \Ruleref{cterm} \dsepl \Ruleref{cterm}, \Lit{+} \dsepl \Ruleref{cterm}, \Lit{*}}
% \Ruledef{cterm}{
%       \Lit{(}, \Ruleref{trace expression}, \Lit{)} \dsepl \Ruleref{name}}

\subsection{Thread Definitions (VDM++ and VDM-RT)}

\Ruledef{thread definitions}{ \Lop{thread},
    \OptPt{\Ruleref{thread definition}} }

\Rule{thread definition}{
    \Ruleref{periodic thread definition} \dsep
    \Ruleref{procedural thread definition} }

\Ruledef{periodic thread definition}{
    \Ruleref{periodic obligation}  \dsep
    \Ruleref{sporadic obligation} }

%For VDM++ where time is not explicit, it looks like:
%
%\Ruledef{periodic obligation}{
%  \Lop{periodic},\Lit{(}, \Ruleref{expression}, \Lit{)}, \Lit{(}, \Ruleref{name}, \Lit{)}
%}

For VDM-RT where time is explicit, it looks like:

\Ruledef{periodic obligation}{
  \Lop{periodic}, \lfeed \Lit{(}, \Ruleref{expression},
  \Ruleref{expression}, \Ruleref{expression}, \Ruleref{expression},
  \Lit{)},\lfeed \Lit{(}, \Ruleref{name}, \Lit{)}
}

\Ruledef{sporadic obligation}{
  \Lop{sporadic}, \lfeed \Lit{(}, \Ruleref{expression}, \Ruleref{expression},
  \Ruleref{expression},  \Lit{)}, \lfeed \Lit{(}, \Ruleref{name}, \Lit{)}
}

For both VDM++ and VDM-RT, we can define:

\Ruledef{procedural thread definition}{
      \Ruleref{statement}}

\subsection{Trace Definitions}

\Ruledef{traces definitions}{\Lop{traces},
   \OptPt{named trace}, \SeqPt{\Lit{;}, \Ruleref{named trace}}
}

\Ruledef{named trace}{\Ruleref{identifier},
  \SeqPt{\Lit{/}, \Ruleref{identifier}},
  \Lit{:},\Ruleref{trace definition list}
}

\Ruledef{trace definition list}{
  \Ruleref{trace definition term},
  \SeqPt{\Lit{;}, \Ruleref{trace definition term}}
}

\Ruledef{trace definition term}{
  \Ruleref{trace definition} \dsep
  \Ruleref{trace definition term}, \Lit{|}, \Ruleref{trace definition}
}

\Rule{trace definition}{
  \Ruleref{trace binding definition} \dsep
  \Ruleref{trace repeat definition}
}

\Ruledef{trace binding definition}{
  \Ruleref{trace let def binding} \dsep
  \Ruleref{trace let best binding}
};

\Ruledef{trace let def binding}{
  \Lop{let}, \Ruleref{local definition},
  \SeqPt{ \Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace let best binding}{
  \Lop{let} \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \lfeed
  \Lop{in}, \Ruleref{trace definition}
}

\Ruledef{trace repeat definition}{
  \Ruleref{trace core definition},
  \OptPt{\Ruleref{trace repeat pattern}}
}

\Ruledef{trace repeat pattern}{
  \Lit{*} \dsep
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{numeric literal}, \Lit{,}
  \Ruleref{numeric literal}, \Lit{\}}
}

\Rule{trace core definition}{
  \Ruleref{trace apply expression} \dsep
  \Ruleref{trace concurrent expression} \dsep
  \Ruleref{trace bracketed expression}
}

\Rule{trace apply expression}{
  \Ruleref{call statement}
}

\Rule{trace concurrent expression}{
  \Lit{||}, \Lit{(}, \Ruleref{trace definition}, \lfeed
  \Lit{,}, \Ruleref{trace definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{trace definition}}, \Lit{)}
}

\Ruledef{trace bracketed expression}{
  \Lit{(}, \Ruleref{trace definition list}, \Lit{)}
}

\section{Expressions}

\Ruledef{expression list}{
  \Ruleref{expression}, \SeqPt{\Lit{,}, \Ruleref{expression}}
  }

\Ruledef{expression}{
  \Ruleref{bracketed expression} \dsep
  \Ruleref{let expression} \dsep
  \Ruleref{let be expression} \dsep
  \Ruleref{def expression} \dsep
  \Ruleref{if expression} \dsep
  \Ruleref{cases expression} \dsep
  \Ruleref{unary expression} \dsep
  \Ruleref{binary expression} \dsep
  \Ruleref{quantified expression} \dsep
  \Ruleref{iota expression} \dsep
  \Ruleref{set enumeration} \dsep
  \Ruleref{set comprehension} \dsep
  \Ruleref{set range expression} \dsep
  \Ruleref{sequence enumeration} \dsep
  \Ruleref{sequence comprehension} \dsep
  \Ruleref{subsequence} \dsep
  \Ruleref{map enumeration} \dsep
  \Ruleref{map comprehension} \dsep
  \Ruleref{tuple constructor} \dsep
  \Ruleref{record constructor} \dsep
  \Ruleref{record modifier}  \dsep
  \Ruleref{apply} \dsep
  \Ruleref{field select} \dsep
  \Ruleref{tuple select} \dsep
  \Ruleref{function type instantiation} \dsep
  \Ruleref{lambda expression} \dsep
  \Ruleref{new expression} \dsep
  \Ruleref{self expression} \dsep
  \Ruleref{threadid expression} \dsep
  \Ruleref{general is expression} \dsep
  \Ruleref{undefined expression} \dsep
  \Ruleref{precondition expression} \dsep
  \Ruleref{isofbaseclass expression} \dsep
  \Ruleref{isofclass expression} \dsep
  \Ruleref{samebaseclass expression}  \dsep
  \Ruleref{sameclass expression} \dsep
  \Ruleref{act expression} \dsep
  \Ruleref{fin expression} \dsep
  \Ruleref{active expression} \dsep
  \Ruleref{req expression} \dsep
  \Ruleref{waiting expression} \dsep
  \Ruleref{time expression} \dsep
  \Ruleref{name} \dsep
  \Ruleref{old name}  \dsep
  \Ruleref{symbolic literal}
}
\nonstandard{4}

\subsection{Bracketed Expressions}

\Ruledef{bracketed expression}{
  \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\subsection{Local Binding Expressions}

\Ruledef{let expression}{
  \Lop{let}, \Ruleref{local definition},
   \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{expression}
  }

\Ruledef{let be expression}{
  \Lop{let}, \Ruleref{multiple bind},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{expression}
  }

\Ruledef{def expression}{
  \Lop{def},
  \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{pattern bind}, \Lit{=}, \Ruleref{expression}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{expression}
  }
  \nonstandard{2}

\subsection{Conditional Expressions}

\Ruledef{if expression}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression},\lfeed
  \SeqPt{\Ruleref{elseif expression}}, \lfeed
  \Lop{else}, \Ruleref{expression}
  }

\Ruledef{elseif expression}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{expression}
  }

\Ruledef{cases expression}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:},\lfeed
  \Ruleref{cases expression alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others expression}}, \Lop{end}
  }

\Ruledef{cases expression alternatives}{
  \Ruleref{cases expression alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases expression alternative}}
  }

\Ruledef{cases expression alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{expression}
  }

\Ruledef{others expression}{
  \Lop{others}, \Lit{->}, \Ruleref{expression}
  }

\subsection{Unary Expressions}

\Ruledef{unary expression}{
  \Ruleref{prefix expression} \dsep
  \Ruleref{map inverse}
  }

\Ruledef{prefix expression}{
  \Ruleref{unary operator}, \Ruleref{expression}
  }

\Ruledef{unary operator}{
  \Ruleref{unary plus} \dsep
  \Ruleref{unary minus} \dsep
  \Ruleref{arithmetic abs} \dsep
  \Ruleref{floor} \dsep
  \Ruleref{not} \dsep
  \Ruleref{set cardinality} \dsep
  \Ruleref{finite power set} \dsep
  \Ruleref{distributed set union} \dsep
  \Ruleref{distributed set intersection} \dsep
  \Ruleref{sequence head} \dsep
  \Ruleref{sequence tail} \dsep
  \Ruleref{sequence length} \dsep
  \Ruleref{sequence elements} \dsep
  \Ruleref{sequence indices} \dsep
  \Ruleref{sequence reverse} \dsep
  \Ruleref{distributed sequence concatenation} \dsep
  \Ruleref{map domain} \dsep
  \Ruleref{map range} \dsep
  \Ruleref{distributed map merge}
  }

\Ruledef{unary plus}{
  \Lit{+}
  }

\Ruledef{unary minus}{
  \Lit{-}
  }

\Ruledef{arithmetic abs}{
  \Lop{abs}
  }

\Ruledef{floor}{
  \Lop{floor}
  }

\Ruledef{not}{
  \Lop{not}
  }

\Ruledef{set cardinality}{
  \Lop{card}
  }

\Ruledef{finite power set}{
  \Lop{power}
  }

\Ruledef{distributed set union}{
  \Lop{dunion}
  }

\Ruledef{distributed set intersection}{
  \Lop{dinter}
  }

\Ruledef{sequence head}{
  \Lop{hd}
  }

\Ruledef{sequence tail}{
  \Lop{tl}
  }

\Ruledef{sequence length}{
  \Lop{len}
  }

\Ruledef{sequence elements}{
  \Lop{elems}
  }

\Ruledef{sequence indices}{
  \Lop{inds}
  }

\Ruledef{sequence reverse}{
  \Lop{reverse}
  }

\Ruledef{distributed sequence concatenation}{
  \Lop{conc}
  }

\Ruledef{map domain}{
  \Lop{dom}
  }

\Ruledef{map range}{
  \Lop{rng}
  }

\Ruledef{distributed map merge}{
  \Lop{merge}
  }

\Ruledef{map inverse}{
  \Lop{inverse}, \Ruleref{expression}
  }

\subsection{Binary Expressions}

\Ruledef{binary expression}{
  \Ruleref{expression}, \Ruleref{binary operator}, \Ruleref{expression}
  }

\Ruledef{binary operator}{
  \Ruleref{arithmetic plus} \dsep
  \Ruleref{arithmetic minus} \dsep
  \Ruleref{arithmetic multiplication} \dsep
  \Ruleref{arithmetic divide} \dsep
  \Ruleref{arithmetic integer division} \dsep
  \Ruleref{arithmetic rem} \dsep
  \Ruleref{arithmetic mod} \dsep
  \Ruleref{less than} \dsep
  \Ruleref{less than or equal} \dsep
  \Ruleref{greater than} \dsep
  \Ruleref{greater than or equal} \dsep
  \Ruleref{equal} \dsep
  \Ruleref{not equal} \dsep
  \Ruleref{or} \dsep
  \Ruleref{and} \dsep
  \Ruleref{imply} \dsep
  \Ruleref{logical equivalence} \dsep
  \Ruleref{in set} \dsep
  \Ruleref{not in set} \dsep
  \Ruleref{subset} \dsep
  \Ruleref{proper subset} \dsep
  \Ruleref{set union} \dsep
  \Ruleref{set difference} \dsep
  \Ruleref{set intersection} \dsep
  \Ruleref{sequence concatenate} \dsep
  \Ruleref{map or sequence modify} \dsep
  \Ruleref{map merge} \dsep
  \Ruleref{map domain restrict to} \dsep
  \Ruleref{map domain restrict by} \dsep
  \Ruleref{map range restrict to} \dsep
  \Ruleref{map range restrict by} \dsep
  \Ruleref{composition} \dsep
  \Ruleref{iterate}
}

\Ruledef{arithmetic plus}{
  \Lit{+}
  }

\Ruledef{arithmetic minus}{
  \Lit{-}
  }

\Ruledef{arithmetic multiplication}{
  \Lit{*}
  }

\Ruledef{arithmetic divide}{
  \Lit{/}
  }

\Ruledef{arithmetic integer division}{
  \Lop{div}
  }

\Ruledef{arithmetic rem}{
  \Lop{rem}
  }

\Ruledef{arithmetic mod}{
  \Lop{mod}
  }

\Ruledef{less than}{
  \Lit{<}
  }

\Ruledef{less than or equal}{
  \Lit{<=}
  }

\Ruledef{greater than}{
  \Lit{>}
  }

\Ruledef{greater than or equal}{
  \Lit{>=}
  }

\Ruledef{equal}{
  \Lit{=}
  }

\Ruledef{not equal}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{approx}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{or}{
  \Lop{or}
  }

\Ruledef{and}{
  \Lop{and}
  }

\Ruledef{imply}{
  \Lit{=>}
  }

\Ruledef{logical equivalence}{
  \Lit{<=>}
  }

\Ruledef{in set}{
  \Lop{in set}
  }

\Ruledef{not in set}{
  \Lop{not in set}
  }

\Ruledef{subset}{
  \Lop{subset}
  }

\Ruledef{proper subset}{
  \Lop{psubset}
  }

\Ruledef{set union}{
  \Lop{union}
  }

\Ruledef{set difference}{
  \Lit{\char'134}
  }

\Ruledef{set intersection}{
  \Lop{inter}
  }

\Ruledef{sequence concatenate}{
  \Lit{\char'136}
  }

\Ruledef{map or sequence modify}{
  \Lit{++}
  }

\Ruledef{map merge}{
  \Lop{munion}
  }

\Ruledef{map domain restrict to}{
  \Lit{<:}
  }

\Ruledef{map domain restrict by}{
  \Lit{<-:}
  }

\Ruledef{map range restrict to}{
  \Lit{:>}
  }

\Ruledef{map range restrict by}{
  \Lit{:->}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\subsection{Quantified Expressions}

\Ruledef{quantified expression}{
  \Ruleref{all expression} \dsep
  \Ruleref{exists expression} \dsep
  \Ruleref{exists unique expression}
  }

\Ruledef{all expression}{
  \Lop{forall}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists expression}{
  \Lop{exists}, \Ruleref{bind list}, \Lit{\&}, \Ruleref{expression}
  }

\Ruledef{exists unique expression}{
  \Lop{exists1}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The Iota Expression}

\Ruledef{iota expression}{
  \Lop{iota}, \Ruleref{bind}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{Set Expressions}

\Ruledef{set enumeration}{
  \Lit{\{}, \OptPt{\Ruleref{expression list}}, \Lit{\}}
  }

\Ruledef{set comprehension}{
  \Lit{\{}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\Ruledef{set range expression}{
  \Lit{\{}, \Ruleref{expression}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{expression},
  \Lit{\}}
  }

\subsection{Sequence Expressions}

\Ruledef{sequence enumeration}{
  \Lit{[}, \OptPt{\Ruleref{expression list}}, \Lit{]}
  }

\Ruledef{sequence comprehension}{
  \Lit{[}, \Ruleref{expression}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{]}
  }

\Ruledef{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\subsection{Map Expressions}

\Ruledef{map enumeration}{
  \Lit{\{}, \Ruleref{maplet}, \SeqPt{\Lit{,}, \Ruleref{maplet}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{maplet}{
  \Ruleref{expression}, \Lit{|->}, \Ruleref{expression}
  }

\Ruledef{map comprehension}{
  \Lit{\{}, \Ruleref{maplet}, \Lit{|}, \Ruleref{bind list}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{expression}},
  \Lit{\}}
  }

\subsection{The Tuple Constructor Expression}

\Ruledef{tuple constructor}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{expression list}, \Lit{)}
  }

\subsection{Record Expressions}

\Ruledef{record constructor}{
  \Lop{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{record modifier}{
  \Lit{mu}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
  \Ruleref{record modification}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{record modification}}, \Lit{)}
  }

\Ruledef{record modification}{
  \Ruleref{identifier}, \Lit{|->}, \Ruleref{expression}
  }

\subsection{Apply Expressions}

\Ruledef{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Ruledef{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{tuple select}{
  \Ruleref{expression}, \Lit{.\#}, \Ruleref{numeral}
  }

\Ruledef{function type instantiation}{
  \Ruleref{name}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\subsection{The Lambda Expression}

\Ruledef{lambda expression}{
  \Lop{lambda}, \Ruleref{type bind list}, \Lit{\&}, \Ruleref{expression}
  }

\subsection{The narrow Expression}

\Ruledef{narrow expression}{
  \Lop{narrow\_},  \Lit{(}, \Ruleref{expression},  \Lit{,}, \Ruleref{type}, \Lit{)}
  }


\subsection{The New Expression (VDM++ and VDM-RT)}

  \Ruledef{new expression}{
    \Lop{new}, \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\subsection{The Self Expression (VDM++ and VDM-RT)}
  \Ruledef{self expression}{
    \Lop{self}
  }

\subsection{The Threadid Expression (VDM++ and VDM-RT)}
  \Ruledef{threadid expression}{
    \Lop{threadid}
  }

\subsection{The Is Expression}

\Ruledef{general is expression}{
  \Ruleref{is expression} \dsep
  \Ruleref{type judgement}
  }

\Ruledef{is expression}{
  \Lit{\keyw{is}\_},\nmk \Ruleref{name}, \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{is basic type}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }
\ntext{no delimiter is allowed}

\Ruledef{type judgement}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Ruleref{type}, \Lit{)}
  }

\subsection{The Undefined Expression}

\Ruledef{undefined expression}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsection{The Precondition Expression}

\Ruledef{pre-condition expression}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{expression}, \lfeed
                        \OptPt{\SeqPt{\Lit{,}, \Ruleref{expression}}},
               \Lit{)}
  }

\subsection{Base Class Membership (VDM++ and VDM-RT)}

\Ruledef{isofbaseclass expression}{
      \Lop{isofbaseclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\subsection{Class Membership (VDM++ and VDM-RT)}

\Ruledef{isofclass expression}{
      \Lop{isofclass}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{expression}, \Lit{)}}

\subsection{Same Base Class Membership (VDM++ and VDM-RT)}

\Ruledef{samebaseclass expression}{
      \Lop{samebaseclass}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsection{Same Class Membership (VDM++ and VDM-RT)}

\Ruledef{sameclass expression}{
      \Lop{sameclass}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \lfeed
      \Ruleref{expression}, \Lit{)}}

\subsection{History Expressions (VDM++ and VDM-RT)}

  \Ruledef{act expression}{
    \Lop{\#act}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#act}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{fin expression}{
    \Lop{\#fin}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#fin}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{active expression}{
    \Lop{\#active}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#active}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{req expression}{
    \Lop{\#req}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#req}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }
  \Ruledef{waiting expression}{
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name}, \Lit{)} \dsep
    \Lop{\#waiting}, \Lit{(}, \Ruleref{name list}, \Lit{)}
  }


\subsection{Time Expressions (VDM-RT)}

 \Ruledef{time expression}{\Lop{time}}

\subsection{Names}

\Ruledef{name}{
  \Ruleref{identifier}, \OptPt{\Lit{`}, \Ruleref{identifier}}
  }

\Ruledef{name list}{
  \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}
  }

\Ruledef{old name}{
  \Ruleref{identifier}, \Lit{\char'176}
  }

\section{State Designators}

\Ruledef{state designator}{
  \Ruleref{name} \dsep
  \Ruleref{field reference} \dsep
  \Ruleref{map or sequence reference}
  }

\Ruledef{field reference}{
  \Ruleref{state designator}, \Lit{.}, \Ruleref{identifier}
  }

\Ruledef{map or sequence reference}{
  \Ruleref{state designator}, \Lit{(}, \Ruleref{expression}, \Lit{)}
  }

\section{Statements}

\Ruledef{statement}{
  \Ruleref{let statement} \dsep
  \Ruleref{let be statement} \dsep
  \Ruleref{def statement} \dsep
  \Ruleref{block statement} \dsep
  %\ifthenelse{\boolean{VDMpp}}{
  \Ruleref{general assign statement}
%}%
%                              {\Ruleref{assign statement}}
  \dsep
  \Ruleref{if statement} \dsep
  \Ruleref{cases statement} \dsep
  \Ruleref{sequence for loop} \dsep
  \Ruleref{set for loop} \dsep
  \Ruleref{index for loop} \dsep
  \Ruleref{while loop} \dsep
  \Ruleref{nondeterministic statement} \dsep
  \Ruleref{call statement} \dsep
  \Ruleref{specification statement} \dsep
%#ifdef VDMPP
%  \Ruleref{select statement} \dsep
  \Ruleref{start statement} \dsep
  \Ruleref{start list statement} \dsep
  \Ruleref{stop statement} \dsep
  \Ruleref{stop list statement} \dsep
%  \Ruleref{delay statement} \dsep
%#endif VDMPP
%#ifdef VICEMAN
  \Ruleref{duration statement} \dsep
  \Ruleref{cycles statement} \dsep
%#endif VICEMAN
  \Ruleref{return statement} \dsep
  \Ruleref{always statement} \dsep
  \Ruleref{trap statement} \dsep
  \Ruleref{recursive trap statement} \dsep
  \Ruleref{exit statement} \dsep
  \Ruleref{error statement} \dsep
  \Ruleref{identity statement}
  }
  \nonstandard{2}

\subsection{Local Binding Statements}

\Ruledef{let statement}{
  \Lop{let}, \Ruleref{local definition}, \SeqPt{\Lit{,}, \Ruleref{local definition}}, \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{local definition}{
  \Ruleref{value definition} \dsep
  \Ruleref{function definition}
  }

\Ruledef{let be statement}{
  \Lop{let}, \Ruleref{multiple bind}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{expression}}, \Lop{in}, \lfeed
  \Ruleref{statement}
  }

\Ruledef{def statement}{
  \Lop{def}, \Ruleref{equals definition}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{equals definition}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }
  \nonstandard{1}

\Ruledef{equals definition}{
  \Ruleref{pattern bind}, \Lit{=},
   \Ruleref{expression}}

\subsection{Block and Assignment Statements}

\Ruledef{block statement}{
  \Lit{(}, \SeqPt{\Ruleref{dcl statement}}, \lfeed
  \Ruleref{statement}, \SeqPt{\Lit{;},  \Ruleref{statement}}, \OptPt{\Lit{;}},
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl statement}{
  \Lop{dcl}, \Ruleref{assignment definition}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{assignment definition}}, \Lit{;}
  }

\Ruledef{assignment definition}{
  \Ruleref{identifier}, \Lit{:}, \Ruleref{type}, \OptPt{\Lit{:=},
    \Ruleref{expression} }
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{general assign statement}{
  \Ruleref{assign statement} \dsep
  \Ruleref{multiple assign statement}
  }
%}%
%{}

\Ruledef{assign statement}{
  \Ruleref{state designator}, \Lit{:=},
    \Ruleref{expression}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{multiple assign statement}{
    \Lop{atomic},
    \Lit{(}
      \Ruleref{assign statement}, \Lit{;}, \lfeed
      \Ruleref{assign statement},
      \lfeed
      \OptPt{\SeqPt{\Lit{;},\Ruleref{assign statement}}},
    \Lit{)}
    }
%  }%
%{}


\subsection{Conditional Statements}\label{condstmt2}

\Ruledef{if statement}{
  \Lop{if}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}, \lfeed
  \SeqPt{\Ruleref{elseif statement}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{statement}}
  }

\Ruledef{elseif statement}{
  \Lop{elseif}, \Ruleref{expression}, \Lop{then}, \Ruleref{statement}
  }


\Ruledef{cases statement}{
  \Lop{cases}, \Ruleref{expression}, \Lit{:}, \lfeed
  \Ruleref{cases statement alternatives}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others statement}}, \Lop{end}
  }

\Ruledef{cases statement alternatives}{
  \Ruleref{cases statement alternative}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases statement alternative}}
  }

\Ruledef{cases statement alternative}{
  \Ruleref{pattern list}, \Lit{->}, \Ruleref{statement}
  }

\Ruledef{others statement}{
  \Lop{others}, \Lit{->}, \Ruleref{statement}
  }

\subsection{Loop Statements}

\Ruledef{sequence for loop}{
  \Lop{for}, \Ruleref{pattern bind}, \Lop{in},
  \lfeed
  \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }

\Ruledef{set for loop}{
  \Lop{for}, \Lop{all}, \Ruleref{pattern}, \Lop{in set},
  \Ruleref{expression},\lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{index for loop}{
  \Lop{for}, \Ruleref{identifier}, \Lit{=}, \Ruleref{expression},
  \Lop{to}, \Ruleref{expression}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{expression}}, \lfeed
  \Lop{do}, \Ruleref{statement}
  }

\Ruledef{while loop}{
  \Lop{while}, \Ruleref{expression}, \Lop{do}, \Ruleref{statement}
  }
\subsection{The Nondeterministic Statement}

\Ruledef{nondeterministic statement}{
  \Lit{||}, \Lit{(}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{statement}}, \Lit{)}
  }

\subsection{Call and Return Statements}

In VDM-SL a call statement looks like:
%#ifdef VDMSL
\Ruledef{call statement}{
  \Ruleref{name}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{expression list}}, \Lit{)}
}
%#endif VDMSL
In VDM++ and VDM-RT a call statement looks like:

%#ifdef VDMPP
  \Ruledef{call statement}{
    \OptPt{\Ruleref{object designator}, \Lit{.}},\lfeed
    \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)},
    }
  \Ruledef{object designator}{
    \Ruleref{name} \dsep
    \Ruleref{self expression} \dsep
    \Ruleref{new expression} \dsep
    \Ruleref{object field reference} \dsep
    \Ruleref{object apply}
  }

  \Ruledef{object field reference}{
    \Ruleref{object designator}, \Lit{.}, \Ruleref{identifier}
  }

  \Ruledef{object apply}{
    \Ruleref{object designator}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }
%#endif VDMPP

\Ruledef{return statement}{
  \Lop{return}, \OptPt{\Ruleref{expression}}
  }

\subsection{The Specification Statement}

\Ruledef{specification statement}{
  \Lit{[}, \Ruleref{implicit operation body}, \Lit{]}
  }\nonstandard{1}

%#ifdef VDMPP
%\subsection{The Select Statement}
%
%\Ruledef{select statement}{
%      \Lop{sel}, \Lit{(}, \Ruleref{guarded command},\lfeed
%      \SeqPt{\Lit{,}, \Ruleref{guarded command}}, \Lit{)}}
%\Ruledef{guarded command}{
%      \OptPt{\Ruleref{expression}}, \OptPt{\Ruleref{answer statement}},\lfeed
%      \OptPt{\Lop{$->$}, \Ruleref{statement}}}
%\Ruledef{answer statement}{
%      \Lop{answer}, \Brack{\Ruleref{name} \dsepl \Lop{all}}}
%
\subsection{Start and Start List Statements (VDM++ and VDM-RT)}

\Ruledef{start statement}{
    \Lop{start}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\Ruledef{start list statement}{
      \Lop{startlist}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\subsection{Stop and Stop List Statements (VDM++ and VDM-RT)}

\Ruledef{stop statement}{
    \Lop{stop}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

\Ruledef{stop list statement}{
      \Lop{stoplist}, \Lit{(}, \Ruleref{expression}, \Lit{)}}

%\subsection{The Delay Statement}
%
%\Ruledef{delay statement}{
%      \Lop{delay}, \Lit{(},\Ruleref{expression}, \Lit{)}}
%#endif VDMPP

%#ifdef VICEMAN
\subsection{The Duration and Cycles Statements (VDM-RT)}

\Ruledef{duration statement}{
  \Lop{duration}, \Lit{(}, \Ruleref{expression}, \Lit{)},\lfeed
  \Ruleref{statement}
}

\Ruledef{cycles statement}{
    \Lop{cycles}, \Lit{(}, \Ruleref{expression}, \Lit{)},\lfeed
    \Ruleref{statement}
  }

%#endif VICEMAN

\subsection{Exception Handling Statements}

\Ruledef{always statement}{
  \Lop{always}, \Ruleref{statement}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{trap statement}{
  \Lop{trap}, \Ruleref{pattern bind}, \Lop{with}, \Ruleref{statement},
  \lfeed
  \Lop{in}, \Ruleref{statement}
  }

\Ruledef{recursive trap statement}{
  \Lop{tixe}, \Ruleref{traps}, \Lop{in}, \Ruleref{statement}
  }

\Ruledef{traps}{
  \Lit{\{}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{pattern bind}, \Lit{|->}, \Ruleref{statement}},
  \Lit{\}}
  }

\Ruledef{exit statement}{
  \Lop{exit}, \OptPt{\Ruleref{expression}}
  }

\subsection{The Error Statement}

  \Ruledef{error statement}{
    \Lop{error}
    }\nonstandard{1}

\subsection{The Identity Statement}

\Ruledef{identity statement}{
  \Lop{skip}
  }

\section{Patterns and Bindings}

\subsection{Patterns}\label{patterns2}

\Ruledef{pattern}{
  \Ruleref{pattern identifier} \dsep
  \Ruleref{match value} \dsep
  \Ruleref{set enum pattern} \dsep
  \Ruleref{set union pattern} \dsep
  \Ruleref{seq enum pattern} \dsep
  \Ruleref{seq conc pattern} \dsep
  \Ruleref{map enumeration pattern} \dsep
  \Ruleref{map muinon pattern} \dsep
  \Ruleref{tuple pattern} \dsep
  \Ruleref{object pattern} \dsep
  \Ruleref{record pattern}
  }

\Ruledef{pattern identifier}{
  \Ruleref{identifier} \dsepl \Lit{-}
  }

\Ruledef{match value}{
  \Lit{(}, \Ruleref{expression}, \Lit{)} \dsep
  \Ruleref{symbolic literal}
  }

\Ruledef{set enum pattern}{
  \Lit{\{}, \OptPt{\Ruleref{pattern list}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{set union pattern}{
  \Ruleref{pattern}, \Lit{union}, \Ruleref{pattern}
  }

\Ruledef{seq enum pattern}{
  \Lit{[}, \OptPt{\Ruleref{pattern list}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{seq conc pattern}{
  \Ruleref{pattern}, \Lit{\char'136}, \Ruleref{pattern}
  }

\Ruledef{map enumeration pattern}{
\Lit{\{}, \Ruleref{maplet pattern list}, \Lit{\}} \dsep \Lit{\{}, \Lit{|->}, \Lit{\}}
}

\Ruledef{maplet pattern list}{
     \Ruleref{maplet pattern}, \SeqPt{\Lit{,}, \Ruleref{maplet pattern}}
    }

\Ruledef{maplet pattern}{
    \Ruleref{pattern}, \Lit{|->}, \Ruleref{pattern}
  }

\Ruledef{map muinon pattern}{
    \Ruleref{pattern}, \Lit{\keyw{munion}}, \Ruleref{pattern}
  }

\Ruledef{tuple pattern}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{pattern}, \Lit{,}, \Ruleref{pattern list}, \Lit{)}
  }

\Ruledef{record pattern}{
  \Lit{mk\_},\nmk \Ruleref{name}, \Lit{(}, \OptPt{\Ruleref{pattern list}}, \Lit{)}
  }
\ntext{no delimiter is allowed}


  \Ruledef{object pattern}{
      \Lop{obj\_}, \Ruleref{identifier}, \Lit{(}, [ \Ruleref{field pattern list} ], \Lit{)}\nmk
    }
 \ntext{\Ruleref{object pattern} is only be used in VDM++ and VDM-RT}

  \Ruledef{field pattern list}{
      \Ruleref{field pattern}, \SeqPt{\Lit{,},  \Ruleref{field pattern}}
    }

  \Ruledef{field pattern}{
      \Ruleref{identifier},  \Lit{|->}, \Ruleref{pattern}
    }

\Ruledef{pattern list}{
  \Ruleref{pattern}, \SeqPt{\Lit{,}, \Ruleref{pattern}}
  }

\subsection{Bindings}

\Ruledef{pattern bind}{
  \Ruleref{pattern} \dsepl \Ruleref{bind}
  }

\Ruledef{bind}{
  \Ruleref{set bind} \dsepl \Ruleref{seq bind} \dsepl \Ruleref{type bind}
  }

\Ruledef{set bind}{
  \Ruleref{pattern}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{seq bind}{
  \Ruleref{pattern}, \Lop{in seq}, \Ruleref{expression}
  }

\Ruledef{type bind}{
  \Ruleref{pattern}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{bind list}{
  \Ruleref{multiple bind}, \SeqPt{\Lit{,}, \Ruleref{multiple bind}}
  }

\Ruledef{multiple bind}{
  \Ruleref{multiple set bind} \dsep
  \Ruleref{multiple seq bind} \dsep
  \Ruleref{multiple type bind}
  }

\Ruledef{multiple set bind}{
  \Ruleref{pattern list}, \Lop{in set}, \Ruleref{expression}
  }

\Ruledef{multiple seq bind}{
  \Ruleref{pattern list}, \Lop{in seq}, \Ruleref{expression}
  }

\Ruledef{multiple type bind}{
  \Ruleref{pattern list}, \Lit{:}, \Ruleref{type}
  }

\Ruledef{type bind list}{
  \Ruleref{type bind}, \SeqPt{\Lit{,}, \Ruleref{type bind}}
  }

\chapter{Lexical Specification}\label{app-b}\label{ap:lexis}

\section{Characters}

The characters that comprise a valid VDM specification are defined in
terms of Unicode codepoints. The actual character encoding of a VDM
source file (for example UTF-8, ISO-Latin-1 or Shift-JIS) is not
defined, and the tool support is responsible for converting whatever
encoding is used into Unicode during the parse of the file.

All VDM keywords and delimiter tokens are composed of characters from
the Basic Latin block (``ASCII'' codepoints less than U+0080). On the
other hand, user identifiers (variable names, function names and so
on) can be composed of a rich variety of Unicode codepoints,
reflecting the need for fully internationalized specifications.

All Unicode codepoints have a ``category''. Certain categories are
entirely excluded from the set of codepoints that are permitted in
identifiers. This prevents, say, punctuation characters from being
used. On the other hand, to provide a degree of compatibility with the
original VDM ISO standard, and for backward compatibility, there are
different rules for the formation of user identifiers that only use
ASCII characters. For example, the underscore is permitted in
identifiers (U+005F), even though this is in the connecting
punctuation category, which would not normally be allowed.

See \url{http://www.fileformat.info/info/unicode/category/index.htm} for
more information about categories.

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
        \begin{tabular}{lp{13cm}}
        \multicolumn{2}{l}{\rm initial letter:} \\
        if   & codepoint $<$ U+0100 \\
        then &  Any character in categories Ll, Lm, Lo, Lt, Lu or U+0024 (a dollar sign) \\
        else & Any character except categories Cc, Zl, Zp, Zs, Cs,
                Cn, Nd, Pc \\
    \end{tabular}

\blankline
\begin{tabular}{lp{13cm}}
        \multicolumn{2}{l}{following letter: }\\
        if   & codepoint $<$ U+0100 \\
        then & Any character in categories Ll, Lm, Lo, Lt, Lu, Nd or
               U+0024 (a dollar sign) or U+005F (underscore) or U+0027 (apostrophe) \\
        else & Any character except categories Cc, Zl, Zp, Zs, Cs, Cn
    \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{digit:} \\
        {\tt 0}
        & {\tt 1}
        & {\tt 2}
        & {\tt 3}
        & {\tt 4}
        & {\tt 5}
        & {\tt 6}
        & {\tt 7}
        & {\tt 8}
        & {\tt 9}
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{hexadecimal digit:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f}
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{octal digit:} \\
        {\tt 0}
        & {\tt 1}
        & {\tt 2}
        & {\tt 3}
        & {\tt 4}
        & {\tt 5}
        & {\tt 6}
        & {\tt 7}
     \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{Character set}}
\label{charSetTable}

\end{table}



\clearpage % to force table to appear *here*


\section{Symbols}\label{Symbols}

The following kinds of symbols exist: keywords, delimiters,
% simple names -- these do not seem to exist anymore DJA
symbolic literals, and comments.  The transformation from characters to
symbols is given by the following rules; these use the same notation as the
syntax definition but differ in meaning in that no separators may appear
between adjacent terminals.  Where ambiguity is possible otherwise, two
consecutive symbols must be separated by a separator.

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{keyword}{
%#ifdef VDMPP
  \Lks{\#act}
  \Lks{\#active}
  \Lks{\#fin}
  \Lks{\#req}
  \Lks{\#waiting}
%  \Lksb{a\_}
  \Lksb{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
\Lks{as}
  \Lks{async}
  \Lks{atomic}
  \Lksb{be}
  \Lks{bool}
  \Lks{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lksb{class}
  \Lks{comp}
  \Lks{compose}
  \Lks{conc}
%#ifdef VICEMAN
  \Lks{cycles}
%#endif VICEMAN
  \Lks{dcl}
  \Lksb{def}
  \Lks{definitions}
%  \Lks{delay}
  \Lks{dinter}
  \Lks{div}
  \Lks{dlmodule}
  \Lksb{do}
  \Lks{dom}
  \Lks{dunion}
%#ifdef VICEMAN
  \Lks{duration}
%#endif VICEMAN
  \Lks{elems}
  \Lks{else}
  \Lksb{elseif}
  \Lks{end}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lksb{exit}
  \Lks{exports}
  \Lks{ext}
  \Lks{false}
  \Lksb{floor}
  \Lks{for}
  \Lks{forall}
  \Lks{from}
  \Lks{functions}
%  \Lks{general}
  \Lks{hd}
  \Lks{if}
  \Lksb{in}
  \Lks{inds}
 % \Lks{init}
  \Lks{inmap}
%  \Lks{input}
  \Lks{instance}
  \Lks{int}
  \Lksb{inter}
  \Lks{imports}
  \Lks{init}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lksb{is}
  \Lks{isofbaseclass}
  \Lks{isofclass}
  \Lks{lambda}
  \Lks{len}
  \Lksb{let}
  \Lks{map}
  \Lks{measure}
  \Lks{merge}
  \Lks{mod}
  \Lks{module}
  \Lksb{mu}
  \Lks{munion}
  \Lks{mutex}
  \Lks{nat}
  \Lks{nat1}
  \Lks{new}
  \Lks{nil}
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{others}
  \Lks{per}
  \Lks{periodic}
  \Lksb{post}
  \Lks{power}
  \Lks{pre}
  \Lks{private}
  \Lks{protected}
  \Lksb{psubset}
  \Lks{public}
  \Lks{pure}
 % \Lksb{qsync}
  \Lks{rat}
  \Lks{rd}
  \Lks{real}
  \Lks{rem}
  \Lksb{renamed}
  \Lks{responsibility}
  \Lks{return}
  \Lks{reverse}
  \Lksb{rng}
  \Lks{samebaseclass}
  \Lks{sameclass}
 % \Lksb{sel}
  \Lks{self}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{set1}
  \Lks{skip}
  \Lks{specified}
  \Lks{sporadic}
  \Lks{st}
  \Lksb{start}
  \Lks{startlist}
  \Lks{state}
  \Lks{stop}
  \Lksb{stoplist}
  \Lks{struct}
  \Lks{subclass}
  \Lks{subset}
  \Lksb{sync}
%#ifdef VICEMAN
  \Lks{system}
%#endif VICEMAN
%  \Lks{synonym}
%  \Lks{t\_}
  \Lks{then}
  \Lks{thread}
  \Lks{threadid}
%#ifdef VICEMAN
  \Lks{time}
%#endif VICEMAN
  \Lksb{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lks{traces}
  \Lks{trap}
  \Lks{true}
  \Lksb{types}
  \Lks{undefined}
  \Lks{union}
  \Lks{uselib}
  \Lksb{values}
  \Lks{variables}
%  \Lks{w\_}
  \Lks{while}
  \Lks{with}
  \Lks{wr}
  \Lks{yet}
  \Lop{RESULT}
%#endif VDMPP
  }

%\Ruledef{separator}{
%  \hyperlink{charSetTable}{newline} \dsepl
%  \hyperlink{charSetTable}{white space}
%  }

\Ruledef{identifier}{
  \Ruleref{initial letter},
  \SeqPt{following letter}
  }

\medskip


\noindent Note that in VDM-RT the \texttt{CPU} and \texttt{BUS} classes are
reserved and cannot be redefined by the user. These two predefined
classes contain the functionality described in
Section~\ref{sec:system} above.

All identifiers beginning with one of the reserved prefixes are
reserved: \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} and \keyw{pre\_}.

\Ruledef{type variable identifier}{
  \Lit{@}, \Ruleref{identifier}
  }

\Ruledef{is basic type}{
  \Lop{is\_},
  \Brack{%
    \Lop{bool} \dsepl
    \Lop{nat} \dsepl
    \Lop{nat1} \dsepl
    \Lop{int} \dsepl
    \Lop{rat} \dsep
    \Lop{real} \dsepl
    \Lop{char} \dsepl
    \Lop{token}
    }
  }

\Ruledef{symbolic literal}{
  \Ruleref{numeric literal} \dsepl
  \Ruleref{boolean literal} \dsep
  \Ruleref{nil literal} \dsepl
  \Ruleref{character literal} \dsepl
  \Ruleref{text literal} \dsep
  \Ruleref{quote literal}
  }

\Ruledef{numeral}{
  \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}
  }

\Ruledef{numeric literal}{
  \hyperlink{charSetTable}{decimal literal} \dsepl \hyperlink{charSetTable}{hexadecimal literal}
  }

\Ruledef{exponent}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{numeral}
  }

\Ruledef{decimal literal}{
  \Ruleref{numeral},
  \OptPt{\Lit{.}, \hyperlink{charSetTable}{digit}, \SeqPt{\hyperlink{charSetTable}{digit}}},
  \OptPt{\Ruleref{exponent}}
}

\Ruledef{hexadecimal literal}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{hexadecimal digit}, \SeqPt{\hyperlink{charSetTable}{hexadecimal digit}}
}

\Ruledef{boolean literal}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nil literal}{
  \Lop{nil}
  }

\Ruledef{character literal}{
  \Lit{\mbox{\,}'\mbox{\,}}, \Ruleref{character} \dsepl
  \Ruleref{escape sequence} \dsep
  \Lit{\mbox{\,}'\mbox{\,}}
  }\nonstandard{1}

\Ruledef{escape sequence}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x} \hyperlink{charSetTable}{hexadecimal
    digit},\hyperlink{charSetTable}{hexadecimal digit} \dsep
  \Lit{{\char'134}u} \hyperlink{charSetTable}{hexadecimal
    digit},\hyperlink{charSetTable}{hexadecimal digit},  \lfeed \hyperlink{charSetTable}{hexadecimal digit},\hyperlink{charSetTable}{hexadecimal digit} \dsep
  \Lit{{\char'134}c} \Ruleref{character} \dsep
  \Lit{{\char'134}} \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit}, \hyperlink{charSetTable}{octal digit} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'} \dsepl
  }

\Ruledef{text literal}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}\char'134"\mbox{\,}}\dsepl
     \Ruleref{character} \dsepl \Ruleref{escape sequence}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{quote literal}{
  \Lit{$<$}, \Ruleref{identifier}, \Lit{$>$}

  }

\Ruledef{Single-line comment}{
  \Lit{--}, \SeqPt{\Ruleref{character} -- newline}, newline
  }

\Ruledef{Multiple-line comment}{
  \Lit{/*}, \SeqPt{\Ruleref{character}}, \Lit{*/}
  }

The escape sequences given above are to be interpreted as follows:

\begin{table}[htb]
\begin{center}
\begin{tabular}{ll}\hline
Sequence & Interpretation\\ \hline
  \Lit{\char'134\char'134} & U+005C (backslash character)\\
  \Lit{{\char'134}r}       & U+000D (return character)\\
  \Lit{{\char'134}n}       & U+000A (newline character)\\
  \Lit{{\char'134}t}       & U+0009 (tab character)\\
  \Lit{{\char'134}f}       & U+000C (formfeed character)\\
  \Lit{{\char'134}e}       & U+001B (escape character)\\
  \Lit{{\char'134}a}       & U+0007 (alarm (bell))\\
  \Lit{{\char'134}x} hexadecimal digit, hexadecimal digit
                           & U+00xy (hex representation of character\\
                           & (e.g.\ \texttt{{\char'134}x41} is `A'))\\
  \Lit{{\char'134}u} hexadecimal digit, hexadecimal digit,
                           & U+abcd (hex representation of character\\
hexadecimal digit, hexadecimal digit  & (e.g.\ \texttt{{\char'134}u0041} is `A'))\\
  \Lit{{\char'134}c} character
                           & U+00nn (control character)\\
                           & (e.g.\ \texttt{{\char'134}cA} $\equiv$
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}} octal digit, octal digit, octal digit
                           & U+00nn (octal representation of character)\\
  \Lit{{\char'134}{\char'042}}       & U+0022 (double quote)\\
  \Lit{{\char'134}'}       & U+0027 (apostrophe) \\ \hline
\end{tabular}
\end{center}
\caption{Escape sequences}
\end{table}



\chapter{Operator Precedence}\label{app-c}

The precedence ordering for operators in the concrete syntax is defined
using a two-level approach: operators are divided into families, and an
upper-level precedence ordering, $>$, is given for the families, such that
if families $F\sb{1}$ and $F\sb{2}$ satisfy

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent then every operator in the family $F\sb{1}$ is of a higher precedence
than every operator in the family $F\sb{2}$.

The relative precedences of the operators within families is determined by
considering type information, and this is used to resolve ambiguity. The
type constructors are treated separately, and are not placed in a
precedence ordering with the other operators.

There are six families of operators, namely Combinators, Applicators,
Evaluators, Relations, Connectives and Constructors:

\begin{description}%{Connectivesxx}
\item[Combinators:] Operations that allow function and mapping values to be
  combined, and function, mapping and numeric values to be iterated.

\item[Applicators:] Function application, field selection, sequence
  indexing, etc.

\item[Evaluators:] Operators that are non-predicates.

\item[Relations:] Operators that are relations.

\item[Connectives:] The logical connectives.

\item[Constructors:] Operators that are used, implicitly or explicitly, in
  the construction of expressions; e.g.  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', etc.
\end{description}

\noindent The precedence ordering on the families is:

\begin{quote}
$\mbox{\small combinators} >
\mbox{\small applicators} >
\mbox{\small evaluators}  >
\mbox{\small relations}   >
\mbox{\small connectives} >
\mbox{\small constructors}$
\end{quote}

\section{The Family of Combinators}

These combinators have the highest family priority.

\Ruledef{combinator}{
  \Ruleref{iterate} \dsepl \Ruleref{composition}
  }

\Ruledef{iterate}{
  \Lit{**}
  }

\Ruledef{composition}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & combinator \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\section{The Family of Applicators}

All applicators have equal precedence.

\Ruledef{applicator}{
  \Ruleref{subsequence}
% \dsep \Ruleref{tuple constructor}
  \dsep \Ruleref{apply}
  \dsep \Ruleref{function type instantiation}
  \dsep \Ruleref{field select}
  }

\Rule{subsequence}{
  \Ruleref{expression}, \Lit{(}, \Ruleref{expression}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{expression}, \Lit{)}
  }

\Rule{apply}{
  \Ruleref{expression}, \Lit{(}, \OptPt{\Ruleref{expression list}}, \Lit{)}
  }

\Rule{function type instantiation}{
  \Ruleref{expression}, \Lit{[}, \Ruleref{type}, \SeqPt{\Lit{,}, \Ruleref{type}}, \Lit{]}
  }

\Rule{field select}{
  \Ruleref{expression}, \Lit{.}, \Ruleref{identifier}
  }

\section{The Family of Evaluators}

The family of evaluators is divided into nine groups, according to the type
of expression they are used in.

\Ruledef{evaluator}{
  \Ruleref{arithmetic prefix operator} \dsep
  \Ruleref{set prefix operator} \dsep
  \Ruleref{sequence prefix operator} \dsep
  \Ruleref{map prefix operator} \dsep
  \Ruleref{arithmetic infix operator} \dsep
  \Ruleref{set infix operator} \dsep
  \Ruleref{sequence infix operator} \dsep
  \Ruleref{map infix operator}
  }

\Ruledef{arithmetic prefix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{set prefix operator}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{sequence prefix operator}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc} \dsepl
  \Lop{reverse}
  }

\Ruledef{map prefix operator}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{arithmetic infix operator}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{set infix operator}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{sequence infix operator}{
  \Lit{\char'136}
  }

\Ruledef{map infix operator}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent The precedence ordering follows a pattern of analogous operators. The
family is defined in the following table.

\blankline
\begin{table}[thb]
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    precedence level & arithmetic       & set                   & map                    & sequence \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (unary) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (unary) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
                     &                  &                       &                        & \keyw{reverse}        \\
    \hline
  \end{tabular}
\end{center}
\caption{Operator precedence}
\end{table}

\section{The Family of Relations}

This family includes all the relational operators whose results are of type
\keyw{bool}.

\Ruledef{relation}{
  \Ruleref{relational infix operator} \dsepl \Ruleref{set relational operator}
  }

\Ruledef{relational infix operator}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{set relational operator}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    precedence level & relation \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent All operators in the Relations family have equal precedence.  Typing
dictates that there is no meaningful way of using them adjacently.

\section{The Family of Connectives}

This family includes all the logical operators whose result is of type
\keyw{bool}.

\Ruledef{connective}{
  \Ruleref{logical prefix operator} \dsepl \Ruleref{logical infix operator}
  }

\Ruledef{logical prefix operator}{
  \Lop{not}
  }

\Ruledef{logical infix operator}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    precedence level & connective \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\section{The Family of Constructors}

This family includes all the operators used to construct a value.  Their
priority is given either by brackets, which are an implicit part of the
operator, or by the syntax.

\section{Grouping}\label{grouping}

The grouping of operands of the binary operators are as follows:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[Combinators:] Right grouping.

\item[Applicators:] Left grouping.

\item[Connectives:] The `{\tt =>}' operator has right grouping.  The other
  operators are associative and therefore right and left grouping are
  equivalent.

\item[Evaluators:] Left grouping\footnote{Except the ``map domain restrict
    to'' and the ``map domain restrict by'' operators which have a right
    grouping. This is not standard.}.

\item[Relations:] No grouping, as it has no meaning.

\item[Constructors:] No grouping, as it has no meaning.
\end{list}

\section{The Type Operators}\label{preceedence}

Type operators have their own separate precedence ordering, as follows:
\begin{enumerate}
\item Function types: {\tt ->, +>} (right grouping).

\item Union type: {\tt |} (left grouping).

\item Other binary type operators: \verb+*+ (no grouping).

\item Map types: \keyw{map} \ldots \keyw{to} \ldots and \keyw{inmap} \ldots
  \keyw{to} \ldots\ (right grouping).\nonstandard{0}

\item Unary type operators: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}, \keyw{set1 of}.
\end{enumerate}

\chapter{Differences between the Concrete Syntaxes}\label{sec:diff}

When VDM was originally developed a mathematical syntax was used and
this have also been retained in the ISO/VDM-SL standard. However, most
VDM tools today mainly use an ASCII syntax. Below is a list of the
symbols which are different in the mathematical syntax and the ASCII
syntax:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 Mathematical syntax & ASCII syntax  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\X$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\bf\ttfamily munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\bf\ttfamily psubset}                     \\
 $\Subset$       & {\bf\ttfamily subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\bf\ttfamily dinter}                      \\
 $\Dunion$          & {\bf\ttfamily dunion}                      \\
 $\Power$          & {\bf\ttfamily power}                        \\
 \ldots$\Set$            & {\bf\ttfamily set of ...}                    \\
 \ldots$\Set_1$            & {\bf\ttfamily set1 of ...}                    \\
 \ldots$\Seq*$              & {\bf\ttfamily seq of ...}                 \\
 \ldots$\Seq+$              & {\bf\ttfamily seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\bf\ttfamily map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\bf\ttfamily inmap ... to ...}                 \\
 $\Muop$           & {\bf\ttfamily mu}                           \\
 $\Bool$           & {\bf\ttfamily bool}                         \\
 $\Nat$            & {\bf\ttfamily nat}                          \\
 $\Nat_1$            & {\bf\ttfamily nat1}                          \\
 $\Int$            & {\bf\ttfamily int}                          \\
 $\Real$           & {\bf\ttfamily real}                         \\
 $\Not$            & {\bf\ttfamily not}                          \\
 $\Inter$          & {\bf\ttfamily inter}                        \\
 $\Union$          & {\bf\ttfamily union}                        \\
 $\In$             & {\bf\ttfamily in set}                       \\
 $\Notin$          & {\bf\ttfamily not in set}                   \\
 $\And$            & {\bf\ttfamily and}                          \\
 $\Or$             & {\bf\ttfamily or}                           \\
 $\All$            & {\bf\ttfamily forall}                       \\
 $\Exists$         & {\bf\ttfamily exists}                       \\
 $\Exists!$        & {\bf\ttfamily exists1}                      \\
 $\Lambdaop$       & {\bf\ttfamily lambda} \\
 $\Iotaop$         & {\bf\ttfamily iota} \\
 $\ldots\Inverse$  & {\bf\ttfamily inverse ...} \\
\hline
\end{longtable}
% \end{center}


\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


